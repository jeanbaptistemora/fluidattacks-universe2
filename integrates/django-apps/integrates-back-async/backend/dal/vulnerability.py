"""DAL functions for vulnerabilities."""

import logging
from datetime import datetime
from typing import Dict, List, cast

import aioboto3
import pytz
from boto3.dynamodb.conditions import Attr, Key
from botocore.exceptions import ClientError
from django.conf import settings
from django.core.files.base import ContentFile

from backend.exceptions import ErrorUploadingFileS3
from backend.typing import (
    DynamoDelete as DynamoDeleteType,
    Finding as FindingType
)
from backend.dal.helpers import cloudfront, dynamodb, s3
from backend.utils import aio
from fluidintegrates.settings import LOGGING

from __init__ import (
    FI_AWS_S3_REPORTS_BUCKET as VULNS_BUCKET,
    FI_CLOUDFRONT_REPORTS_DOMAIN
)

logging.config.dictConfig(LOGGING)

# Constants
LOGGER = logging.getLogger(__name__)
TABLE_NAME: str = 'FI_vulnerabilities'


async def get_vulnerabilities_async(
        finding_id: str,
        table: aioboto3.session.Session.client,
        should_list_deleted: bool = False) -> List[Dict[str, FindingType]]:
    """Get vulnerabilities of the given finding"""
    query_attrs = {
        'KeyConditionExpression': Key('finding_id').eq(finding_id)
    }
    response = await table.query(**query_attrs)
    vulns = response.get('Items', [])
    while 'LastEvaluatedKey' in response:
        query_attrs.update(
            {'ExclusiveStartKey': response.get('LastEvaluatedKey')}
        )
        response = await table.query(**query_attrs)
        vulns += response.get('Items', [])

    return [
        vuln for vuln in vulns
        if vuln.get('historic_state', [{}])[-1].get('state') != 'DELETED' or
        should_list_deleted
    ]


async def update(
        finding_id: str,
        vuln_id: str,
        data: Dict[str, FindingType]) -> bool:
    success = False
    set_expression = ''
    remove_expression = ''
    expression_names = {}
    expression_values = {}
    for attr, value in data.items():
        if value is None:
            remove_expression += f'#{attr}, '
            expression_names.update({f'#{attr}': attr})
        else:
            set_expression += f'#{attr} = :{attr}, '
            expression_names.update({f'#{attr}': attr})
            expression_values.update({f':{attr}': value})

    if set_expression:
        set_expression = f'SET {set_expression.strip(", ")}'
    if remove_expression:
        remove_expression = f'REMOVE {remove_expression.strip(", ")}'

    update_attrs = {
        'Key': {
            'finding_id': finding_id,
            'UUID': vuln_id,
        },
        'UpdateExpression': f'{set_expression} {remove_expression}'.strip(),
    }
    if expression_values:
        update_attrs.update({'ExpressionAttributeValues': expression_values})
    if expression_names:
        update_attrs.update({'ExpressionAttributeNames': expression_names})
    try:
        success = await dynamodb.async_update_item(TABLE_NAME, update_attrs)
    except ClientError as ex:
        LOGGER.exception(ex, extra={'extra': locals()})
    return success


async def create(data: Dict[str, FindingType]) -> bool:
    """Add vulnerabilities."""
    resp = False
    try:
        item = {
            'finding_id': str(data.get('finding_id')),
            'UUID': str(data.get('UUID')),
            'vuln_type': data.get('vuln_type'),
            'where': data.get('where'),
            'source': str(data.get('source', 'integrates')),
            'specific': str(data.get('specific')),
            'historic_state': data.get('historic_state')
        }
        if 'treatment_manager' in data:
            item['treatment_manager'] = data.get('treatment_manager')
        resp = await dynamodb.async_put_item(TABLE_NAME, item)
    except ClientError as ex:
        LOGGER.exception(ex, extra={'extra': locals()})
    return resp


async def delete(uuid: str, finding_id: str) -> bool:
    """Delete a vulnerability of a finding."""
    resp = False
    try:
        delete_attrs = DynamoDeleteType(
            Key={
                'UUID': uuid,
                'finding_id': finding_id
            }
        )
        resp = await dynamodb.async_delete_item(TABLE_NAME, delete_attrs)
    except ClientError as ex:
        LOGGER.exception(ex, extra={'extra': locals()})
    return resp


async def get_by_finding(
        finding_id: str,
        vuln_type: str = '',
        where: str = '',
        specific: str = '',
        uuid: str = '') -> List[Dict[str, FindingType]]:
    """Get a vulnerability."""
    hash_key = 'finding_id'
    query_attrs = {
        'KeyConditionExpression': Key(hash_key).eq(finding_id),
    }
    if finding_id and uuid:
        range_key = 'UUID'
        query_attrs.update({
            'KeyConditionExpression': (
                Key(hash_key).eq(finding_id) & Key(range_key).eq(uuid)
            )
        })
    elif finding_id and vuln_type and where and specific:
        filtering_exp = (
            Attr('vuln_type').eq(vuln_type) &
            Attr('where').eq(where) &
            Attr('specific').eq(specific)
        )
        query_attrs.update({
            'FilterExpression': filtering_exp
        })

    return await dynamodb.async_query(TABLE_NAME, query_attrs)


async def get(vuln_uuid: str) -> List[Dict[str, FindingType]]:
    """Get a vulnerability by only its UUID."""
    hash_key = 'UUID'
    query_attrs = {
        'IndexName': 'gsi_uuid',
        'KeyConditionExpression': Key(hash_key).eq(vuln_uuid)
    }

    return await dynamodb.async_query(TABLE_NAME, query_attrs)


async def request_verification(vuln: Dict[str, FindingType]) -> bool:
    tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
    today = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    historic_verification = cast(
        List[Dict[str, str]],
        vuln.get('historic_verification', [])
    )
    new_state: Dict[str, str] = {
        'date': today,
        'status': 'REQUESTED',
    }
    historic_verification.append(new_state)
    return await update(
        str(vuln.get('finding_id', '')),
        str(vuln.get('UUID', '')),
        {'historic_verification': historic_verification}
    )


async def verify_vulnerability(vuln: Dict[str, FindingType]) -> bool:
    tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
    today = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    historic_verification = cast(
        List[Dict[str, str]],
        vuln.get('historic_verification', [])
    )
    new_state: Dict[str, str] = {
        'date': today,
        'status': 'VERIFIED',
    }
    historic_verification.append(new_state)
    return await update(
        str(vuln.get('finding_id', '')),
        str(vuln.get('UUID', '')),
        {'historic_verification': historic_verification}
    )


async def upload_file(vuln_file: ContentFile) -> str:
    file_path = vuln_file.name
    file_name = file_path.split('/')[-1]
    if not await s3.upload_memory_file(  # type: ignore
            VULNS_BUCKET, vuln_file, file_name):
        raise ErrorUploadingFileS3()
    return file_name


async def sign_url(vuln_file_name: str) -> str:
    return await aio.ensure_cpu_bound(
        cloudfront.sign_url,
        FI_CLOUDFRONT_REPORTS_DOMAIN,
        vuln_file_name,
        1.0 / 6
    )
