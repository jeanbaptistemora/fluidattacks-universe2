import logging
import sys
from typing import List, cast, Union, Any

# Third party libraries
from aioextensions import (
    in_thread,
)
from ariadne import convert_kwargs_to_snake_case
from mixpanel import Mixpanel
from graphql.type.definition import GraphQLResolveInfo

from backend.decorators import (
    concurrent_decorators,
    require_integrates,
    enforce_group_level_auth_async,
    require_login,
    require_finding_access,
)
from backend.domain.vulnerability import (
    delete_tags,
    delete_vulnerability,
    get_vulnerabilities_file,
    request_verification,
    update_last_vuln_date,
    update_treatments,
    upload_file,
    verify_vulnerabilities
)
from backend.exceptions import (
    ErrorUploadingFileS3,
    InvalidFileType,
    InvalidSeverity
)
from backend.typing import (
    DownloadFilePayload as DownloadFilePayloadType,
    SimplePayload as SimplePayloadType,
)
from backend import authz, util

from backend_new import settings

from fluidintegrates.settings import LOGGING

logging.config.dictConfig(LOGGING)

# Constants
LOGGER = logging.getLogger(__name__)


@convert_kwargs_to_snake_case  # type: ignore
async def resolve_vulnerability_mutation(
        obj: Any,
        info: GraphQLResolveInfo,
        **parameters: Any
) -> Union[SimplePayloadType, DownloadFilePayloadType]:
    """Wrap vulnerability mutations."""
    field = util.camelcase_to_snakecase(info.field_name)
    resolver_func = getattr(sys.modules[__name__], f'_do_{field}')
    return cast(
        Union[SimplePayloadType, DownloadFilePayloadType],
        await resolver_func(obj, info, **parameters)
    )


@concurrent_decorators(
    require_login,
    enforce_group_level_auth_async,
    require_integrates,
    require_finding_access,
)
async def _do_delete_tags(
        _: Any,
        info: GraphQLResolveInfo,
        finding_id: str,
        vulnerabilities: List[str],
        tag: str = '') -> SimplePayloadType:
    """Resolve delete_tags mutation."""
    success = await delete_tags(
        finding_id, vulnerabilities, tag
    )
    if success:
        finding_loader = info.context.loaders['finding']
        finding_data = await finding_loader.load(finding_id)
        project_name = finding_data['project_name']
        attrs_to_clean = {
            'vuln': finding_id,
            'vul': project_name
        }
        to_clean = util.format_cache_keys_pattern(attrs_to_clean)
        util.queue_cache_invalidation(*to_clean)
        for vuln in vulnerabilities:
            attrs_to_clean = {
                'tag': vuln
            }
            to_clean = util.format_cache_keys_pattern(attrs_to_clean)
            util.queue_cache_invalidation(*to_clean)
        util.cloudwatch_log(
            info.context,
            f'Delete tags from {finding_id}'  # pragma: no cover
        )
    return SimplePayloadType(success=success)


@concurrent_decorators(
    require_login,
    enforce_group_level_auth_async,
    require_integrates,
    require_finding_access,
)
async def _do_update_treatment_vuln(
        _: Any,
        info: GraphQLResolveInfo,
        **parameters: Any) -> SimplePayloadType:
    """Resolve update_treatment_vuln mutation."""
    min_value = 0
    max_value = 1000000000
    vulnerabilities = parameters.get('vulnerabilities', [])
    finding_id = parameters.get('finding_id', '')
    severity = parameters.get('severity')
    if severity and severity != -1:
        if min_value > severity > max_value:
            raise InvalidSeverity([min_value, max_value])
    user_data = await util.get_jwt_content(info.context)
    user_email = user_data['user_email']
    finding_loader = info.context.loaders['finding']
    finding_data = await finding_loader.load(finding_id)
    project_name = finding_data['project_name']

    user_role = await authz.get_group_level_role(
        user_email, project_name
    )

    is_customer_admin = user_role in ['customeradmin', 'group_manager']
    result_update_vuln = await update_treatments(
        vulnerabilities,
        finding_id,
        parameters,
        info,
        is_customer_admin
    )

    if result_update_vuln:
        util.queue_cache_invalidation(
            f'vuln*{finding_id}',
            f'historic*{finding_id}',
            f'severity*{finding_id}',
            *[f'vuln*{vuln}' for vuln in vulnerabilities]
        )
        util.forces_trigger_deployment(project_name)
    return SimplePayloadType(success=result_update_vuln)


@concurrent_decorators(
    require_login,
    enforce_group_level_auth_async,
    require_integrates,
    require_finding_access,
)
async def _do_request_verification_vuln(
        _: Any,
        info: GraphQLResolveInfo,
        finding_id: str,
        justification: str,
        vulnerabilities: List[str]) -> SimplePayloadType:
    """Resolve request_verification_vuln mutation."""
    user_info = await util.get_jwt_content(info.context)
    success = await request_verification(
        finding_id,
        user_info['user_email'],
        ' '.join(
            [user_info.get('first_name', ''), user_info.get('last_name', '')]
        ),
        justification,
        vulnerabilities
    )

    if success:
        finding_loader = info.context.loaders['finding']
        finding_data = await finding_loader.load(finding_id)
        project_name = finding_data['project_name']
        attrs_to_clean = {
            'historic': finding_id,
            'severity': finding_id,
            'tracking': finding_id,
            'state': finding_id,
            'remediated': finding_id,
            'verified': finding_id,
            'vuln': finding_id,
            'consult': finding_id,
            'comment': finding_id,
            'vul': project_name,
            'findings': project_name,
            'max*severity': project_name,
            'remediate': project_name,
            'total_treatment': project_name
        }
        to_clean = util.format_cache_keys_pattern(attrs_to_clean)
        util.queue_cache_invalidation(*to_clean)
        util.cloudwatch_log(
            info.context,
            ('Security: Verified a request '
             f'in finding_id: {finding_id}')  # pragma: no cover
        )
    return SimplePayloadType(success=success)


@concurrent_decorators(
    require_login,
    enforce_group_level_auth_async,
    require_integrates,
    require_finding_access,
)
async def _do_verify_request_vuln(
        _: Any,
        info: GraphQLResolveInfo,
        **parameters: Any) -> SimplePayloadType:
    """Resolve verify_request_vuln mutation."""
    finding_id = parameters.get('finding_id', '')
    user_info = await util.get_jwt_content(info.context)
    success = await verify_vulnerabilities(
        finding_id,
        user_info['user_email'],
        ' '.join(
            [user_info.get('first_name', ''), user_info.get('last_name', '')]
        ),
        info,
        parameters
    )
    if success:
        finding_loader = info.context.loaders['finding']
        finding_data = await finding_loader.load(finding_id)
        project_name = finding_data['project_name']
        attrs_to_clean = {
            'historic': finding_id,
            'severity': finding_id,
            'tracking': finding_id,
            'state': finding_id,
            'remediated': finding_id,
            'verified': finding_id,
            'vuln': finding_id,
            'consult': finding_id,
            'comment': finding_id,
            'vul': project_name,
            'findings': project_name,
            'max*severity': project_name,
            'remediate': project_name,
            'total_treatment': project_name
        }
        to_clean = util.format_cache_keys_pattern(attrs_to_clean)
        util.queue_cache_invalidation(*to_clean)
        util.cloudwatch_log(
            info.context,
            ('Security: Verified a request '
             f'in finding_id: {finding_id}')  # pragma: no cover
        )
    return SimplePayloadType(success=success)


@concurrent_decorators(
    require_login,
    enforce_group_level_auth_async,
    require_integrates,
    require_finding_access,
)
async def _do_delete_vulnerability(
        _: Any,
        info: GraphQLResolveInfo,
        **kwargs: Any) -> SimplePayloadType:
    """Resolve delete_vulnerability mutation."""
    finding_id = kwargs.get('finding_id', '')
    uuid = kwargs.get('id', '')
    justification = kwargs.get('justification', '')
    user_data = await util.get_jwt_content(info.context)
    user_email = user_data.get('user_email', '')
    finding_loader = info.context.loaders['finding']
    finding_data = await finding_loader.load(finding_id)
    project_name = finding_data['project_name']
    success = await delete_vulnerability(
        finding_id,
        uuid,
        justification,
        user_email
    )

    if success:
        attrs_to_clean = {
            'historic': finding_id,
            'report_date': finding_id,
            'severity': finding_id,
            'tracking': finding_id,
            'state': finding_id,
            'remediated': finding_id,
            'verified': finding_id,
            'vuln': finding_id,
            'vul': project_name,
            'findings': project_name,
            'max*severity': project_name,
            'remediate': project_name,
            'total_treatment': project_name
        }
        to_clean = util.format_cache_keys_pattern(attrs_to_clean)
        util.queue_cache_invalidation(*to_clean)
        util.forces_trigger_deployment(project_name)
        util.cloudwatch_log(
            info.context,
            (f'Security: Deleted vulnerability: {uuid} '
             f'from {project_name} project successfully')  # pragma: no cover
        )
    else:
        util.cloudwatch_log(
            info.context,
            ('Security: Attempted to delete vulnerability: '
             f'{uuid} from {project_name} project')  # pragma: no cover
        )
    return SimplePayloadType(success=success)


@concurrent_decorators(
    require_login,
    enforce_group_level_auth_async,
    require_integrates,
    require_finding_access,
)
async def _do_upload_file(
        _: Any,
        info: GraphQLResolveInfo,
        **kwargs: Any) -> SimplePayloadType:
    """Resolve upload_file mutation."""
    success = False
    finding_id = kwargs.get('finding_id', '')
    file_input = kwargs.get('file', '')
    finding_loader = info.context.loaders['finding']
    finding_data = await finding_loader.load(finding_id)
    project_name = finding_data['project_name']
    allowed_mime_type = await util.assert_uploaded_file_mime(
        file_input,
        ['text/x-yaml', 'text/plain', 'text/html']
    )
    if file_input and allowed_mime_type:
        success = await upload_file(
            file_input,
            finding_data,
            info
        )
        await update_last_vuln_date(finding_id)
    else:
        raise InvalidFileType()
    if success:
        attrs_to_clean = {
            'historic': finding_id,
            'tracking': finding_id,
            'report_date': finding_id,
            'severity': finding_id,
            'state': finding_id,
            'vuln': finding_id,
            'vul': project_name,
            'finding': project_name,
            'drafts': project_name,
            'max*severity': project_name,
            'remediate': project_name,
            'total_treatment': project_name,
        }
        to_clean = util.format_cache_keys_pattern(attrs_to_clean)
        util.queue_cache_invalidation(*to_clean)
        util.cloudwatch_log(
            info.context,
            (f'Security: Uploaded file in {project_name} '
             'project successfully')  # pragma: no cover
        )
    else:
        util.cloudwatch_log(
            info.context,
            ('Security: Attempted to delete file '
             f'from {project_name} project')  # pragma: no cover
        )
        raise ErrorUploadingFileS3()
    return SimplePayloadType(success=success)


@concurrent_decorators(
    require_login,
    enforce_group_level_auth_async,
    require_integrates,
    require_finding_access,
)
async def _do_download_vuln_file(
        _: Any,
        info: GraphQLResolveInfo,
        **kwargs: Any) -> DownloadFilePayloadType:
    """Resolve download_vuln file mutation."""
    success = False
    finding_id = kwargs.get('finding_id', '')
    user_info = await util.get_jwt_content(info.context)
    user_email = user_info['user_email']
    finding_loader = info.context.loaders['finding']
    finding_data = await finding_loader.load(finding_id)
    project_name = finding_data['project_name']
    payload_data = {
        'finding_id': finding_id,
        'project_name': project_name,
        'user_email': user_email
    }

    try:
        file_path = await get_vulnerabilities_file(finding_id, project_name)
        if file_path:
            msg = (
                'Security: Downloaded vulnerabilities'
                f'file in finding {finding_id} successfully'
            )
            util.cloudwatch_log(info.context, msg)
            mp_obj = Mixpanel(settings.MIXPANEL_API_TOKEN)
            await in_thread(
                mp_obj.track,
                user_email,
                'DownloadVulnFile',
                {
                    'Project': project_name.upper(),
                    'Email': user_email,
                    'FileName': file_path,
                }
            )
            success = True
        else:
            msg = (
                'A CloudFront error occurred while getting '
                'the vuln file assotiated to finding in project'
            )
            LOGGER.error(msg, extra={'extra': payload_data})
    except ErrorUploadingFileS3:
        msg_cw = (
            f'Security: Attempted to download vulnerabilities file '
            f'assotiated to finding {finding_id} in project {project_name}'
        )
        util.cloudwatch_log(info.context, msg_cw)
        msg_log = (
            'An error occurred uploading a vuln file to S3 '
            'assotiated to finding in project'
        )
        LOGGER.error(msg_log, extra={'extra': payload_data})

    return DownloadFilePayloadType(success=success, url=str(file_path))
