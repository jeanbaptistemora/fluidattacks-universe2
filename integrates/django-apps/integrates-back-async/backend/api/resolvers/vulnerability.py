import logging
import sys
from typing import List, cast, Union, Any

# Third party libraries
from aioextensions import (
    collect,
    unblock,
)
from ariadne import convert_camel_case_to_snake, convert_kwargs_to_snake_case
from django.conf import settings
from django.core.files.uploadedfile import (
    InMemoryUploadedFile, TemporaryUploadedFile
)
from magic import Magic
from mixpanel import Mixpanel
from graphql.language.ast import FieldNode
from graphql.type.definition import GraphQLResolveInfo

from backend.decorators import (
    require_integrates,
    enforce_group_level_auth_async, require_login, require_finding_access,
    get_entity_cache_async, rename_kwargs
)
from backend.domain.vulnerability import (
    delete_tags, delete_vulnerability, get_vulnerabilities_file,
    process_file, request_verification,
    update_approval_status, update_last_vuln_date, update_all_pending_vulns,
    update_treatments, verify_vulnerabilities
)
from backend.exceptions import (
    ErrorUploadingFileS3, InvalidFileSize,
    InvalidFileType, InvalidSeverity
)
from backend.domain import (
    finding as finding_domain,
)
from backend.typing import (
    DownloadFilePayload as DownloadFilePayloadType,
    Historic as HistoricType,
    SimplePayload as SimplePayloadType,
    Vulnerability as VulnerabilityType
)
from backend import authz, util
from fluidintegrates.settings import LOGGING

logging.config.dictConfig(LOGGING)

# Constants
LOGGER = logging.getLogger(__name__)


@convert_kwargs_to_snake_case  # type: ignore
async def resolve_vulnerability_mutation(
        obj: Any,
        info: GraphQLResolveInfo,
        **parameters: Any
) -> Union[SimplePayloadType, DownloadFilePayloadType]:
    """Wrap vulnerability mutations."""
    field = util.camelcase_to_snakecase(info.field_name)
    resolver_func = getattr(sys.modules[__name__], f'_do_{field}')
    return cast(
        Union[SimplePayloadType, DownloadFilePayloadType],
        await resolver_func(obj, info, **parameters)
    )


@convert_kwargs_to_snake_case  # type: ignore
@require_login
@rename_kwargs({'uuid': 'vuln_uuid'})
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
@rename_kwargs({'vuln_uuid': 'uuid'})
async def resolve_vulnerability(
        _: Any,
        info: GraphQLResolveInfo,
        uuid: str) -> VulnerabilityType:
    """Resolve vulnerability query."""
    return await resolve(info, uuid)


def _get_requested_fields(
        info: GraphQLResolveInfo,
        as_field: bool) -> List[FieldNode]:
    if as_field:
        to_extend = util.get_requested_fields(
            'vulnerabilities',
            info.field_nodes[0].selection_set
        )
    else:
        to_extend = info.field_nodes[0].selection_set.selections
    return to_extend


async def resolve(
    info: GraphQLResolveInfo,
    uuid: str,
    as_field: bool = False,
) -> VulnerabilityType:
    """Async resolve vulnerability fields."""
    result = dict()
    requested_fields = _get_requested_fields(info, as_field)

    for requested_field in requested_fields:
        if util.is_skippable(info, requested_field):
            continue
        params = {
            'vuln_uuid': uuid
        }
        field_params = util.get_field_parameters(requested_field)
        if field_params:
            params.update(field_params)
        requested_field = convert_camel_case_to_snake(
            requested_field.name.value
        )
        if requested_field.startswith('_'):
            continue
        resolver_func = getattr(
            sys.modules[__name__],
            f'_get_{requested_field}'
        )
        result[requested_field] = resolver_func(info, **params)

    # At this point result is a dict(string -> coroutine)
    # Ariadne resolves the coroutines before sending them to the user as result
    #   however, returning a coroutine is not cacheable by Redis etc

    # Resolve the coroutines here so we return plain objects that can be cached
    # by upstream components, this adds no cost as it's done by ariadne anyway
    return dict(zip(result, await collect(result.values())))


@enforce_group_level_auth_async
@get_entity_cache_async
async def _get_historic_verification(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> HistoricType:
    vunerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vunerability.historic_verification


@get_entity_cache_async
async def _get_specific(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> str:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.specific


@get_entity_cache_async
async def _get_where(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> str:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.where


@get_entity_cache_async
async def _get_vuln_type(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> str:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.vuln_type


@get_entity_cache_async
async def _get_historic_state(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> str:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.historic_state


@get_entity_cache_async
async def _get_id(
        _: GraphQLResolveInfo,
        vuln_uuid: str) -> str:
    """ resolves vulerability's UUID"""
    return vuln_uuid


@get_entity_cache_async
async def _get_finding_id(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> str:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.finding_id


@get_entity_cache_async
async def _get_current_approval_status(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> str:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.current_approval_status


@get_entity_cache_async
async def _get_current_state(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> str:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.current_state


@get_entity_cache_async
async def _get_last_approved_status(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> str:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.last_approved_status


@get_entity_cache_async
async def _get_treatment_manager(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> str:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.treatment_manager


@get_entity_cache_async
async def _get_source(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> str:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.source


@get_entity_cache_async
async def _get_analyst(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> str:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.analyst


@get_entity_cache_async
async def _get_last_analyst(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> str:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.last_analyst


@get_entity_cache_async
async def _get_remediated(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> bool:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.remediated


@get_entity_cache_async
async def _get_severity(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> str:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.severity


@get_entity_cache_async
async def _get_tag(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> str:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.tag


@get_entity_cache_async
async def _get_tags(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> List[str]:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.tags


@get_entity_cache_async
async def _get_verification(
        info: GraphQLResolveInfo,
        vuln_uuid: str) -> HistoricType:
    vulnerability = \
        await info.context.loaders['single_vulnerability'].load(vuln_uuid)
    return vulnerability.verification


@require_login
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
async def _do_approve_vulnerability(
        _: Any,
        info: GraphQLResolveInfo,
        finding_id: str,
        approval_status: bool,
        uuid: str = '') -> SimplePayloadType:
    """Resolve approve_vulnerability mutation."""
    success = False
    if uuid:
        success = await update_approval_status(
            finding_id,
            uuid,
            approval_status
        )
    else:
        success = await update_all_pending_vulns(
            finding_id,
            approval_status
        )
    finding_loader = info.context.loaders['finding']
    finding_data = await finding_loader.load(finding_id)
    project_name = finding_data['project_name']
    if success:
        await update_last_vuln_date(finding_id)
        finding_loader.clear(finding_id)
        await util.invalidate_cache(finding_id, project_name)
        util.cloudwatch_log(
            info.context,
            ('Security: Approve vulnerability from '
             f'{project_name} project successfully')  # pragma: no cover
        )
    else:
        util.cloudwatch_log(
            info.context,
            ('Security: Attempted to approve '
             f'vulnerability from {project_name} project')  # pragma: no cover
        )
    return SimplePayloadType(success=success)


@require_login
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
async def _do_delete_tags(
        _: Any,
        info: GraphQLResolveInfo,
        finding_id: str,
        vulnerabilities: List[str],
        tag: str = '') -> SimplePayloadType:
    """Resolve delete_tags mutation."""
    success = await delete_tags(
        finding_id, vulnerabilities, tag
    )
    if success:
        finding_loader = info.context.loaders['finding']
        finding_data = await finding_loader.load(finding_id)
        project_name = finding_data['project_name']
        finding_loader.clear(finding_id)
        await util.invalidate_cache(finding_id, project_name)
        util.cloudwatch_log(
            info.context,
            f'Delete tags from {finding_id}'  # pragma: no cover
        )
    return SimplePayloadType(success=success)


@require_login
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
async def _do_update_treatment_vuln(
        _: Any,
        info: GraphQLResolveInfo,
        **parameters: Any) -> SimplePayloadType:
    """Resolve update_treatment_vuln mutation."""
    min_value = 0
    max_value = 1000000000
    vulnerabilities = parameters.get('vulnerabilities', [])
    finding_id = parameters.get('finding_id', '')
    severity = parameters.get('severity')
    if severity and severity != -1:
        if min_value > severity > max_value:
            raise InvalidSeverity([min_value, max_value])
    user_data = util.get_jwt_content(info.context)
    user_email = user_data['user_email']
    finding_loader = info.context.loaders['finding']
    finding_data = await finding_loader.load(finding_id)
    project_name = finding_data['project_name']

    user_role = await authz.get_group_level_role(
        user_email, project_name
    )

    is_customer_admin = user_role == 'customeradmin'
    result_update_vuln = await update_treatments(
        vulnerabilities,
        finding_id,
        parameters,
        info,
        is_customer_admin
    )

    if result_update_vuln:
        finding_loader.clear(finding_id)
        await util.invalidate_cache(finding_id)
        util.forces_trigger_deployment(project_name)
    return SimplePayloadType(success=result_update_vuln)


@require_login
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
async def _do_request_verification_vuln(
        _: Any,
        info: GraphQLResolveInfo,
        finding_id: str,
        justification: str,
        vulnerabilities: List[str]) -> SimplePayloadType:
    """Resolve request_verification_vuln mutation."""
    user_info = util.get_jwt_content(info.context)
    success = await request_verification(
        finding_id,
        user_info['user_email'],
        ' '.join(
            [user_info.get('first_name', ''), user_info.get('last_name', '')]
        ),
        justification,
        vulnerabilities
    )
    if success:
        finding_loader = info.context.loaders['finding']
        finding_data = await finding_loader.load(finding_id)
        project_name = finding_data['project_name']
        finding_loader.clear(finding_id)
        await util.invalidate_cache(finding_id, project_name)
        util.cloudwatch_log(
            info.context,
            ('Security: Verified a request '
             f'in finding_id: {finding_id}')  # pragma: no cover
        )
    return SimplePayloadType(success=success)


@require_login
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
async def _do_verify_request_vuln(
        _: Any,
        info: GraphQLResolveInfo,
        **parameters: Any) -> SimplePayloadType:
    """Resolve verify_request_vuln mutation."""
    finding_id = parameters.get('finding_id', '')
    user_info = util.get_jwt_content(info.context)
    success = await verify_vulnerabilities(
        finding_id,
        user_info['user_email'],
        ' '.join(
            [user_info.get('first_name', ''), user_info.get('last_name', '')]
        ),
        info,
        parameters
    )
    if success:
        finding_loader = info.context.loaders['finding']
        finding_data = await finding_loader.load(finding_id)
        project_name = finding_data['project_name']
        finding_loader.clear(finding_id)
        await util.invalidate_cache(finding_id, project_name)
        util.cloudwatch_log(
            info.context,
            ('Security: Verified a request '
             f'in finding_id: {finding_id}')  # pragma: no cover
        )
    return SimplePayloadType(success=success)


@require_login
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
async def _do_delete_vulnerability(
        _: Any,
        info: GraphQLResolveInfo,
        **kwargs: Any) -> SimplePayloadType:
    """Resolve delete_vulnerability mutation."""
    finding_id = kwargs.get('finding_id', '')
    uuid = kwargs.get('id', '')
    justification = kwargs.get('justification', '')
    user_email = util.get_jwt_content(info.context).get('user_email', '')
    finding_loader = info.context.loaders['finding']
    finding_data = await finding_loader.load(finding_id)
    project = finding_data['project_name']
    success = await delete_vulnerability(
        finding_id,
        uuid,
        justification,
        user_email
    )

    if success:
        finding_loader.clear(finding_id)
        await util.invalidate_cache(finding_id, project)
        util.forces_trigger_deployment(project)
        util.cloudwatch_log(
            info.context,
            (f'Security: Deleted vulnerability: {uuid} '
             f'from {project} project successfully')  # pragma: no cover
        )
    else:
        util.cloudwatch_log(
            info.context,
            ('Security: Attempted to delete vulnerability: '
             f'{uuid} from {project} project')  # pragma: no cover
        )
    return SimplePayloadType(success=success)


async def _upload_file(
        file_input: Union[InMemoryUploadedFile, TemporaryUploadedFile],
        finding_id: str,
        info: GraphQLResolveInfo) -> bool:
    mib = 1048576
    success = False
    if file_input.size < 1 * mib:
        success = await process_file(file_input, finding_id, info)
    else:
        raise InvalidFileSize()
    return success


def _get_mime_type(
        file_input: Union[InMemoryUploadedFile, TemporaryUploadedFile],
        mime: Magic) -> str:
    mime_type = ''
    if isinstance(file_input, TemporaryUploadedFile):
        mime_type = mime.from_file(file_input.temporary_file_path())
    elif isinstance(file_input, InMemoryUploadedFile):
        mime_type = mime.from_buffer(file_input.file.getvalue())
    return mime_type


@require_login
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
async def _do_upload_file(
        _: Any,
        info: GraphQLResolveInfo,
        **kwargs: Any) -> SimplePayloadType:
    """Resolve upload_file mutation."""
    finding_id = kwargs.get('finding_id', '')
    file_input = kwargs.get('file')
    project = await finding_domain.get_project(finding_id)
    mime = Magic(mime=True)
    mime_type = _get_mime_type(file_input, mime)
    if (file_input and
            mime_type in ['text/x-yaml', 'text/plain', 'text/html']):
        success = await _upload_file(
            file_input,
            finding_id,
            info
        )
    else:
        raise InvalidFileType()
    if success:
        await update_last_vuln_date(finding_id)
        await util.invalidate_cache(finding_id, project)
        util.cloudwatch_log(
            info.context,
            (f'Security: Uploaded file in {project} '
             'project successfully')  # pragma: no cover
        )
    else:
        util.cloudwatch_log(
            info.context,
            ('Security: Attempted to delete file '
             f'from {project} project')  # pragma: no cover
        )
        raise ErrorUploadingFileS3()
    return SimplePayloadType(success=success)


@require_login
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
async def _do_download_vuln_file(
        _: Any,
        info: GraphQLResolveInfo,
        **kwargs: Any) -> DownloadFilePayloadType:
    """Resolve download_vuln file mutation."""
    success = False
    finding_id = kwargs.get('finding_id', '')
    user_email = util.get_jwt_content(info.context)['user_email']
    project_name = await finding_domain.get_project(finding_id)
    payload_data = {
        'finding_id': finding_id,
        'project_name': project_name,
        'user_email': user_email
    }

    try:
        file_path = await get_vulnerabilities_file(finding_id, project_name)
        if file_path:
            msg = (
                'Security: Downloaded vulnerabilities'
                f'file in finding {finding_id} successfully'
            )
            util.cloudwatch_log(info.context, msg)
            mp_obj = Mixpanel(settings.MIXPANEL_API_TOKEN)
            await unblock(
                mp_obj.track,
                user_email,
                'DownloadVulnFile',
                {
                    'Project': project_name.upper(),
                    'Email': user_email,
                    'FileName': file_path,
                }
            )
            success = True
        else:
            msg = (
                'A CloudFront error occurred while getting '
                'the vuln file assotiated to finding in project'
            )
            LOGGER.error(msg, extra={'extra': payload_data})
    except ErrorUploadingFileS3:
        msg_cw = (
            f'Security: Attempted to download vulnerabilities file '
            f'assotiated to finding {finding_id} in project {project_name}'
        )
        util.cloudwatch_log(info.context, msg_cw)
        msg_log = (
            'An error occurred uploading a vuln file to S3 '
            'assotiated to finding in project'
        )
        LOGGER.error(msg_log, extra={'extra': payload_data})

    return DownloadFilePayloadType(success=success, url=str(file_path))
