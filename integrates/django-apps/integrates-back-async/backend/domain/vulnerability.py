"""Domain functions for vulnerabilities."""   # pylint:disable=too-many-lines

import asyncio
import copy
import html
import html.parser
import logging
import os
import uuid
from datetime import datetime
from contextlib import AsyncExitStack
from itertools import (
    chain,
)
from time import time
from typing import (
    Collection, Dict, List,
    Iterable, Optional, Set,
    Union, cast, Any, Awaitable
)

import aioboto3
from aioextensions import (
    collect,
)
import yaml
import pytz
from django.conf import settings
from django.core.files.base import ContentFile
from django.core.files.uploadedfile import InMemoryUploadedFile
from graphql import GraphQLError
from graphql.type.definition import GraphQLResolveInfo
from pykwalify.core import Core
from pykwalify.errors import CoreError, SchemaError


from backend import authz, mailer, util
from backend.exceptions import (
    AlreadyRequested,
    InvalidPath,
    InvalidPort,
    InvalidSchema,
    InvalidSpecific,
    NotVerificationRequested,
    VulnAlreadyClosed,
    VulnNotFound
)
from backend.utils import (
    vulnerabilities as vuln_utils,
    findings as finding_utils,
    validations
)
from backend.dal.helpers.dynamodb import start_context
from backend.dal import (
    finding as finding_dal,
    project as project_dal,
    vulnerability as vuln_dal,
    comment as comment_dal
)
from backend.typing import (
    Finding as FindingType,
    User as UserType,
    Vulnerability as VulnerabilityType,
)
from backend.utils import aio
from fluidintegrates.settings import (
    LOGGING,
    NOEXTRA
)
from __init__ import BASE_URL

logging.config.dictConfig(LOGGING)

# Constants
LOGGER = logging.getLogger(__name__)


def filter_open_vulnerabilities(
    vulnerabilities: List[VulnerabilityType],
) -> List[VulnerabilityType]:
    return [
        vulnerability
        for vulnerability in vulnerabilities
        if (vulnerability['current_state'] == 'open' and
            (vulnerability['current_approval_status'] != 'PENDING' or
             vulnerability['last_approved_status']))
    ]


async def approve_vulnerability(
        finding_id: str,
        historic_state: List[Dict[str, str]],
        last_state: Dict[str, str],
        vuln_id: str) -> bool:
    """ Approve vulnerability """
    tzn = pytz.timezone(settings.TIME_ZONE)
    current_day = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    current_state = {
        'date': current_day,
        'state': last_state.get('state', ''),
        'approval_status': 'APPROVED',
        'analyst': last_state.get('analyst', '')
    }

    historic_state.append(current_state)
    return await vuln_dal.update(
        finding_id,
        vuln_id,
        {'historic_state': historic_state}
    )


async def reject_vulnerability(
        finding_id: str,
        historic_state: List[Dict[str, str]],
        vuln_id: str) -> bool:
    """ Reject vulnerability: remove last_state of historic_state or remove
        if only one state present in historic_state """
    historic_state.pop()
    response = False
    if historic_state:
        response = await vuln_dal.update(
            finding_id,
            vuln_id,
            {'historic_state': historic_state}
        )
    else:
        response = await vuln_dal.delete(vuln_id, finding_id)
    return response


async def update_vuln_state(
        info: GraphQLResolveInfo,
        vulnerability: Dict[str, FindingType],
        item: Dict[str, str],
        finding_id: str,
        current_day: str) -> bool:
    """Update vulnerability state."""
    historic_state = cast(
        List[Dict[str, str]],
        vulnerability.get('historic_state')
    )
    last_state = historic_state[-1]
    response = False
    if last_state.get('state') != item.get('state'):
        user_data = cast(UserType, util.get_jwt_content(info.context))
        analyst = str(user_data['user_email'])
        current_state = {
            'date': current_day,
            'state': item.get('state', ''),
            'analyst': analyst
        }
        if util.is_api_token(user_data):
            current_state['analyst'] = f'api-{analyst}'

        historic_state.append(current_state)
        data_to_update: Dict[str, FindingType] = {
            'historic_state': historic_state
        }
        if item.get('state') == 'closed':
            data_to_update.update({'treatment_manager': None})

        response = await vuln_dal.update(
            finding_id,
            str(vulnerability.get('UUID')),
            data_to_update
        )
    else:
        response = True
    return response


async def add_vuln_to_dynamo(
        item: Dict[str, str],
        specific: str,
        finding_id: str,
        info: GraphQLResolveInfo,
        vulnerability: Optional[Dict[str, FindingType]]) -> bool:
    """Add vulnerability to dynamo."""
    historic_state = []
    response = False
    tzn = pytz.timezone(settings.TIME_ZONE)
    current_day = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    user_data = cast(UserType, util.get_jwt_content(info.context))
    email = str(user_data['user_email'])
    if vulnerability:
        response = await update_vuln_state(
            info, vulnerability, item, finding_id, current_day
        )
    else:
        data: Dict[str, FindingType] = {}
        data['vuln_type'] = item.get('vuln_type', '')
        data['where'] = item.get('where', '')
        data['source'] = item.get('source', 'integrates')
        data['specific'] = specific
        data['finding_id'] = finding_id
        data['UUID'] = str(uuid.uuid4())
        data['treatment'] = 'NEW'
        if 'treatment_manager' in item:
            data.update({'treatment_manager': item.get('treatment_manager')})
        if item.get('state'):
            new_state = {
                'date': current_day,
                'state': item.get('state', ''),
                'analyst': email
            }
            if util.is_api_token(user_data):
                new_state['analyst'] = f'api-{email}'
            historic_state.append(new_state)
            data['historic_state'] = historic_state
            response = await vuln_dal.create(data)
        else:
            util.cloudwatch_log(
                info.context,
                'Security: Attempted to add vulnerability without state'
            )
    return response


async def process_file(
    file_input: InMemoryUploadedFile,
    finding_id: str,
    info: GraphQLResolveInfo,
) -> bool:
    """Process a file."""
    success = False
    raw_content = file_input.read()
    raw_content = raw_content.decode()
    file_content = html.escape(raw_content, quote=False)
    file_input.seek(0)
    vulnerabilities = yaml.safe_load(file_content)
    file_url = f'/tmp/vulnerabilities-{uuid.uuid4()}-{finding_id}.yaml'
    with open(file_url, 'w') as stream:
        yaml.safe_dump(vulnerabilities, stream)
    if validate_file_schema(file_url, info):
        success = await map_vulns_to_dynamo(
            vulnerabilities,
            finding_id,
            info,
        )
    else:
        success = False
    return success


async def map_vulns_to_dynamo(
    vulnerabilities: Dict[str, List[VulnerabilityType]],
    finding_id: str,
    info: GraphQLResolveInfo
) -> bool:
    """Map vulnerabilities and send it to dynamo."""
    coroutines: List[Awaitable[bool]] = []
    where = ['inputs', 'lines', 'ports']
    vulns_to_add: List[Dict[str, str]] = []
    for vuln_type in where:
        file_vuln = vulnerabilities.get(vuln_type)
        if file_vuln:
            inputs_added = await aio.materialize(
                map_vulnerability_type(
                    vuln,
                    vuln_type,
                    finding_id,
                )
                for vuln in file_vuln
            )
            vulns_to_add.extend(chain.from_iterable(inputs_added))
        else:
            pass
            # If a file does not have a type of vulnerabilities,
            # this does not represent an error or an exceptional condition.

    vulns = await collect(
        vuln_dal.get_by_finding(
            finding_id,
            vuln_type=vuln_to_add.get('vuln_type', ''),
            where=vuln_to_add.get('where', ''),
            specific=vuln_to_add.get('specific', '')
        )
        for vuln_to_add in vulns_to_add
    )
    vulns = [
        vuln[0] if vuln else {}
        for vuln in vulns
    ]

    closed_vulns_to_reattack = [
        str(vuln.get('UUID'))
        for vuln, vuln_to_add in zip(vulns, vulns_to_add)
        if (is_reattack_requested(vuln)
            and get_last_approved_status(vuln) == 'open'
            and vuln_to_add.get('state') == 'closed')
    ]

    coroutines.extend([
        add_vuln_to_dynamo(
            vuln_to_add,
            str(vuln_to_add.get('specific')),
            finding_id,
            info,
            vuln
        )
        for vuln_to_add, vuln in zip(vulns_to_add, vulns)
        if str(vuln.get('UUID', '')) not in closed_vulns_to_reattack
    ])
    if closed_vulns_to_reattack:
        user_data = cast(UserType, util.get_jwt_content(info.context))
        analyst = str(user_data['user_email'])
        coroutines.append(
            verify_vulnerabilities(
                finding_id,
                analyst,
                f'{user_data.get("first_name", "")}'
                f' {user_data.get("last_name", "")}',
                info,
                {
                    'justification': 'The vulnerability was verified'
                                     ' by closing it',
                    'closed_vulns': closed_vulns_to_reattack,
                }
            )
        )

    return all(await collect(coroutines))


def validate_file_schema(file_url: str, info: GraphQLResolveInfo) -> bool:
    """Validate if a file has the correct schema."""
    schema_dir = os.path.dirname(os.path.abspath(__file__))
    schema_dir = os.path.join(schema_dir, 'vuln_template.yaml')
    core = Core(source_file=file_url, schema_files=[schema_dir])
    is_valid = False
    try:
        core.validate(raise_exception=True)
        is_valid = True
    except SchemaError:
        lines_of_exceptions = core.errors
        errors_values = [
            x.value
            for x in lines_of_exceptions
            if not hasattr(x, 'key')
        ]
        errors_keys = [
            x
            for x in lines_of_exceptions
            if hasattr(x, 'key')
        ]
        errors_values_formated = [f'"{x}"' for x in errors_values]
        errors_keys_formated = [
            f'"{x.key}"'
            for x in errors_keys
            if x.msg and str(x.msg).find('was not defined') >= 0
        ]
        errors_keys_joined = ','.join(errors_keys_formated)
        errors_values_joined = ','.join(errors_values_formated)
        error_value = (
            f'"values": [{errors_values_joined}], '
            f'"keys": [{errors_keys_joined}]'
        )
        util.cloudwatch_log_sync(
            info.context,
            'Error: An error occurred validating vulnerabilities file'
        )
        raise InvalidSchema(expr=error_value)
    except CoreError:
        raise InvalidSchema()
    finally:
        os.unlink(file_url)
    return is_valid


async def update_last_vuln_date(finding_id: str) -> bool:
    inc = 0
    has_new_open_vulns = False
    vulnerabilities = await list_vulnerabilities_async([finding_id])
    today_date = str(datetime.today().strftime('%Y-%m-%d %H:%M:%S'))
    while inc < len(vulnerabilities) and has_new_open_vulns is False:
        vuln_historics = cast(
            List[Dict[str, str]],
            vulnerabilities[inc].get('historic_state')
        )
        current_state = vuln_historics[-1].get('state', '')
        current_date = vuln_historics[-1].get('date', '')
        if (current_state == 'open' and
            current_date.split(' ')[0] == today_date.split(' ')[0] and
            ('approval_status' not in vuln_historics[-1] or
                vuln_historics[-1].get('approval_status') == 'APPROVED')):
            description: Dict[str, FindingType] = {
                'lastVulnerability': today_date
            }
            await finding_dal.update(finding_id, description)
            has_new_open_vulns = True
        else:
            inc += 1
    success = has_new_open_vulns
    return success


async def update_treatment_vuln(
        vulnerabilities: List[str],
        finding_id: str,
        updated_values: Dict[str, FindingType],
        info: GraphQLResolveInfo) -> bool:
    del updated_values['finding_id']
    updated_vuln_description = []
    for vulnerability in vulnerabilities:
        vuln_info = await vuln_dal.get(vulnerability)
        new_info = copy.copy(updated_values)
        if new_info.get('tag'):
            new_info['tag'] = cast(
                List[str],
                vuln_info[0].get('tag', [])
            )
            tags = str(updated_values['tag']).split(',')
            validations.validate_fields(tags)
            for tag in tags:
                if tag.strip():
                    cast(List[str], new_info['tag']).append(tag.strip())
            new_info['tag'] = cast(
                # conflict between mypy and pylint -> \
                # 'github.com/PyCQA/pylint/issues/2377'
                # pylint: disable=unsubscriptable-object
                List[str],
                list(set(cast(
                    Iterable[Collection[str]],
                    new_info['tag']
                )))
            )
            new_info['tag'] = [
                html.unescape(tag)
                for tag in cast(List[str], new_info['tag'])
            ]
        new_info = {
            key: None
            if not value
            else value
            for key, value in new_info.items()
        }
        new_info = {
            util.camelcase_to_snakecase(k): new_info.get(k)
            for k in new_info
        }
        result_update_vuln = await vuln_dal.update(
            finding_id,
            vulnerability,
            new_info
        )
        if 'lines' in str(vuln_info[0]['vuln_type']):
            where = 'Path'
            specific = 'Line'
        elif 'ports' in str(vuln_info[0]['vuln_type']):
            where = 'Host'
            specific = 'Port'
        else:
            where = 'URL'
            specific = 'Field'
        mail_description = (
            f'<b>{where}:</b>{vuln_info[0]["where"]}&nbsp;'
            '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'
            f'<b>{specific}:</b> {vuln_info[0]["specific"]}'
        )
        updated_vuln_description.append(
            {'updated_vuln_description': mail_description}
        )
        if not result_update_vuln:
            util.cloudwatch_log_sync(
                info.context,
                ('Security: Attempted to update vulnerability'
                 f':{vulnerability} from finding:{finding_id}')
            )
            return False
        util.cloudwatch_log_sync(
            info.context,
            ('Security: Updated vulnerability:'
             f'{vulnerability} from finding:{finding_id} successfully')
        )

    return True


async def update_treatments(
        vulnerabilities: List[str],
        finding_id: str,
        updated_values: Dict[str, FindingType],
        info: GraphQLResolveInfo,
        is_customer_admin: bool) -> bool:
    """Update treatments data in vulnerability"""
    user_data = util.get_jwt_content(info.context)
    finding = await finding_dal.get_finding(finding_id)
    updated_values['treatment'] = cast(
        List[Dict[str, str]],
        finding.get('historic_treatment')
    )[-1]['treatment']
    updated_values['treatment_manager'] = await set_treatment_manager(
        str(updated_values.get('treatment', '')),
        str(updated_values.get('treatment_manager', '')),
        finding, is_customer_admin, user_data['user_email']
    )
    updated_values.pop('vulnerabilities', None)
    if updated_values.get('tag') == '':
        updated_values.pop('tag', None)
    updated_vulns = await get_by_ids(vulnerabilities)
    if any([
        (
            vulnerability.get('treatment_manager', '') !=
            str(updated_values.get('treatment_manager', ''))
        )
        for vulnerability in updated_vulns
    ]):
        vulns_grouped = group_vulnerabilities(updated_vulns)
        vulns_data = vuln_utils.format_vulnerabilities(
            cast(List[Dict[str, FindingType]], vulns_grouped)
        )
        mail_content = set_updated_manager_mail_content(
            cast(Dict[str, List[Dict[str, str]]], vulns_data)
        )
        await send_updated_manager_mail(
            str(updated_values.get('treatment_manager', '')),
            finding,
            mail_content
        )

    return await update_treatment_vuln(
        vulnerabilities,
        finding_id,
        updated_values,
        info
    )


async def set_treatment_manager(
        treatment: str,
        treatment_manager: str,
        finding: Dict[str, FindingType],
        is_customer_admin: bool,
        user_mail: str) -> str:
    if treatment == 'ACCEPTED':
        treatment_manager = user_mail
    elif treatment == 'ACCEPTED_UNDEFINED':
        last_state = cast(
            List[Dict[str, str]],
            finding.get('historic_treatment')
        )[-1]
        if last_state['acceptance_status'] == 'SUBMITTED':
            treatment_manager = user_mail
        else:
            treatment_manager = last_state['user']
    else:
        if not is_customer_admin:
            treatment_manager = user_mail
        if treatment_manager:
            group_name = cast(str, finding.get('project_name', ''))
            project_users = await project_dal.get_users(group_name)
            users_roles = await aio.materialize([
                authz.get_group_level_role(user, group_name)
                for user in project_users
            ])
            customer_roles = ['customer', 'customeradmin', 'group_manager']
            customer_users = [
                user
                for user, role in zip(project_users, users_roles)
                if role in customer_roles
            ]
            if treatment_manager not in customer_users:
                raise GraphQLError('Invalid treatment manager')
        else:
            raise GraphQLError('Invalid treatment manager')

    return treatment_manager


def set_updated_manager_mail_content(
        vulnerabilities: Dict[str, List[Dict[str, str]]]) -> str:
    mail_content = ''
    for vuln_type in ['ports', 'lines', 'inputs']:
        type_vulns = vulnerabilities.get(vuln_type)
        if type_vulns:
            mail_content += '<br />'.join([
                f'- {list(vuln.values())[0]} ({list(vuln.values())[1]})'
                for vuln in type_vulns
            ])
            mail_content += '<br />'
    return mail_content


async def send_updated_manager_mail(
        treatment_manager: str,
        finding: Dict[str, FindingType],
        vulnerabilities: str) -> None:
    finding_id = str(finding.get('finding_id'))
    project_name = str(finding.get('project_name')).upper()
    asyncio.create_task(
        mailer.send_mail_updated_manager(
            [treatment_manager],
            {
                'finding': str(finding.get('finding')),
                'vulnerabilities': vulnerabilities,
                'finding_link':
                    f'{BASE_URL}/groups/{project_name}/vulns/{finding_id}'
            }
        )
    )


async def get_open_vuln_by_type(
        finding_id: str,
        context: Any) -> Dict[str, Union[int, List[str]]]:
    """Get open vulnerabilities group by type."""
    vulnerabilities = await list_vulnerabilities_async([finding_id])
    finding: Dict[str, Union[int, List[str]]] = {
        'openVulnerabilities': 0,
        'closedVulnerabilities': 0,
        'portsVulns': [],
        'linesVulns': [],
        'inputsVulns': []
    }
    vulns_types = ['ports', 'lines', 'inputs']
    for vuln in vulnerabilities:
        current_state = get_last_approved_status(vuln)
        if current_state == 'open':
            finding['openVulnerabilities'] += 1  # type: ignore
            if vuln.get('vuln_type') in vulns_types:
                finding[  # type: ignore
                    f'{vuln.get("vuln_type", "")}Vulns'
                ].append({  # type: ignore
                    'where': vuln.get('where'),
                    'specific': vuln.get('specific')
                })
            else:
                LOGGER.error(
                    'Vulnerability does not have the right type',
                    extra={
                        'extra': {
                            'vuln_uuid': vuln.get("UUID"),
                            'finding_id': finding_id
                        }
                    })
        elif current_state == 'closed':
            finding['closedVulnerabilities'] += 1  # type: ignore
        else:
            error_msg = (
                f'Error: Vulnerability {vuln.get("UUID")} of finding '
                f'{finding_id} does not have the right state'
            )
            util.cloudwatch_log(context, error_msg)
    return finding


async def get_vulnerabilities_by_type(
        finding_id: str) -> Dict[str, List[FindingType]]:
    """Get vulnerabilities group by type."""
    vulnerabilities = await list_vulnerabilities_async([finding_id])
    vulnerabilities_grouped = cast(
        List[Dict[str, FindingType]],
        await aio.ensure_cpu_bound(group_vulnerabilities, vulnerabilities)
    )
    vulnerabilities_formatted = vuln_utils.format_vulnerabilities(
        vulnerabilities_grouped
    )
    return vulnerabilities_formatted


def group_vulnerabilities(vulnerabilities: List[Dict[str, FindingType]]) -> \
        List[FindingType]:
    """Group vulnerabilities by specific field."""
    vuln_types = ['lines', 'ports', 'inputs']
    vuln_states = ['open', 'closed']
    total_vulnerabilities: Dict[str, Dict[str, FindingType]] = {}
    result_vulns: List[FindingType] = []
    for vuln_type in vuln_types:
        total_vulnerabilities[vuln_type] = {}
        for vuln_state in vuln_states:
            total_vulnerabilities[vuln_type][vuln_state] = []

    for vuln in vulnerabilities:
        all_states = cast(
            List[Dict[str, FindingType]],
            vuln.get('historic_state', [{}])
        )
        current_state = str(
            all_states[-1].get('state', '')
        )
        current_approval_status = all_states[-1].get('approval_status', '')
        vuln_type = str(vuln.get('vuln_type', ''))
        if (current_approval_status != 'PENDING' or
                get_last_approved_status(vuln)):
            cast(List[Dict[str, FindingType]],
                 total_vulnerabilities[vuln_type][current_state]).append(vuln)
        else:
            # vuln has pending approval_status
            pass

    for vuln_type in vuln_types:
        for vuln_state in vuln_states:
            vulns_grouped = cast(
                Iterable[FindingType],
                vuln_utils.group_specific(
                    cast(
                        List[str],
                        total_vulnerabilities[vuln_type][vuln_state]
                    ),
                    vuln_type
                )
            )
            result_vulns.extend(vulns_grouped)
    return result_vulns


async def get_vulnerabilities_async(
        finding_id: str,
        table: aioboto3.session.Session.client,
        should_list_deleted: bool = False) -> List[Dict[str, FindingType]]:
    vulnerabilities = await vuln_dal.get_vulnerabilities_async(
        finding_id,
        table,
        should_list_deleted
    )
    return [
        vuln_utils.format_data(vuln)
        for vuln in vulnerabilities
    ]


async def list_vulnerabilities_async(
        finding_ids: List[str],
        should_list_deleted: bool = False) -> List[Dict[str, FindingType]]:
    """Retrieves all vulnerabilities for the requested findings"""
    vulns: List[Dict[str, FindingType]] = []
    async with AsyncExitStack() as stack:
        resource = await stack.enter_async_context(start_context())
        table = await resource.Table(vuln_dal.TABLE_NAME)
        vulns_tasks = [
            asyncio.create_task(
                get_vulnerabilities_async(
                    finding_id,
                    table,
                    should_list_deleted
                )
            )
            for finding_id in finding_ids
        ]
        vulns = await asyncio.gather(*vulns_tasks)

    result: List[Dict[str, FindingType]] = []
    for result_list in vulns:
        result.extend(cast(
            Iterable[Dict[str, FindingType]],
            result_list
        ))
    return result


def get_last_approved_status(vuln: Dict[str, FindingType]) -> str:
    historic_state = cast(List[Dict[str, str]], vuln['historic_state'])
    last_approved = ''
    for state in list(reversed(historic_state)):
        if (state.get('approval_status') == 'APPROVED' or
                not state.get('approval_status')):
            last_approved = state.get('state', '')
            break
    return last_approved


def filter_deleted_status(vuln: Dict[str, FindingType]) -> bool:
    historic_state = cast(List[Dict[str, str]], vuln['historic_state'])
    last_approved = True
    for state in historic_state:
        if state.get('state') == 'DELETED':
            last_approved = False
            break
    return last_approved


def get_last_approved_analyst(vuln: Dict[str, FindingType]) -> str:
    historic_state = cast(List[Dict[str, str]], vuln['historic_state'])
    last_analyst = ''
    for state in list(reversed(historic_state)):
        if (state.get('approval_status') == 'APPROVED' or
                not state.get('approval_status')):
            last_analyst = state.get('analyst', '')
            break
    return last_analyst


def get_last_approved_state(vuln: Dict[str, FindingType]) -> Dict[str, str]:
    historic_state = cast(List[Dict[str, str]], vuln['historic_state'])
    last_approved_state: Dict[str, str] = {}
    for state in list(reversed(historic_state)):
        if (state.get('approval_status') == 'APPROVED' or
                not state.get('approval_status')):
            last_approved_state = state
            break
    return last_approved_state


async def delete_vulnerability(
        finding_id: str,
        vuln_id: str,
        justification: str,
        user_email: str) -> bool:
    vulnerability = await vuln_dal.get(vuln_id)
    success = False
    if vulnerability and vulnerability[0].get('historic_state'):
        all_states = cast(
            List[Dict[str, str]],
            vulnerability[0].get('historic_state')
        )
        current_state = all_states[-1].get('state')
        if current_state == 'open':
            tzn = pytz.timezone(settings.TIME_ZONE)
            current_day = datetime.now(tz=tzn).today().strftime(
                '%Y-%m-%d %H:%M:%S'
            )
            new_state = {
                'date': current_day,
                'state': 'DELETED',
                'justification': justification,
                'analyst': user_email
            }
            all_states.append(new_state)
            success = await vuln_dal.update(
                finding_id,
                str(vulnerability[0].get('UUID', '')),
                {'historic_state': all_states}
            )
    return success


async def delete_tags(
        finding_id: str,
        vulnerabilities: List[str],
        tag: str) -> bool:
    vuln_update_tasks = []
    vuln_info = await get_by_ids(vulnerabilities)
    for index, vulnerability in enumerate(vulnerabilities):
        tag_info: Dict[str, Optional[Set[str]]] = {'tag': set()}
        if tag:
            if vuln_info[index]:
                tag_info['tag'] = cast(
                    Set[str],
                    vuln_info[index].get('tag', [])
                )
            if tag in cast(Set[str], tag_info.get('tag', [])):
                cast(Set[str], tag_info.get('tag')).remove(tag)
        if tag_info.get('tag') == set():
            tag_info['tag'] = None
        vuln_update_task = asyncio.create_task(
            vuln_dal.update(
                finding_id,
                vulnerability,
                cast(Dict[str, FindingType], tag_info)
            )
        )
        vuln_update_tasks.append(vuln_update_task)
    success = await asyncio.gather(*vuln_update_tasks)
    return all(success)


def ungroup_vulnerability_specific(
        vuln: str,
        specific: str,
        data: Dict[str, str]) -> List[Dict[str, str]]:
    """Add vulnerability auxiliar."""
    if vuln in ('lines', 'ports'):
        specific_values = vuln_utils.ungroup_specific(specific)
    else:
        specific_values = [
            spec
            for spec in specific.split(',')
            if spec
        ]
    if (vuln == 'ports' and
        not all((0 <= int(i) <= 65535)
                for i in specific_values)):
        error_value = f'"values": "{specific}"'
        raise InvalidPort(expr=error_value)
    if not specific_values:
        raise InvalidSpecific()

    return [
        {**data, 'specific': specific}
        for specific in specific_values
    ]


async def map_vulnerability_type(
    item: VulnerabilityType,
    vuln_type: str,
    finding_id: str,
) -> List[Dict[str, str]]:
    """Add vulnerability to dynamo."""
    response = []
    where_headers = {
        'inputs': {'where': 'url', 'specific': 'field'},
        'lines': {'where': 'path', 'specific': 'line'},
        'ports': {'where': 'host', 'specific': 'port'}
    }
    finding = await finding_dal.get_finding(finding_id)
    last_finding_state = cast(
        List[Dict[str, str]],
        finding['historic_treatment']
    )[-1]
    treatment_manager = ''
    if last_finding_state['treatment'] != 'NEW':
        treatment_manager = last_finding_state.get('user', '')

    for vuln, vuln_info in list(where_headers.items()):
        if vuln_type == vuln:
            specific = str(item.get(vuln_info.get('specific', '')))
            data: Dict[str, str] = {
                'where': str(item.get(vuln_info.get('where', ''))),
                'state': str(item.get('state', '')),
                'source': str(item.get('source', 'integrates')),
                'vuln_type': vuln_type,
            }
            if treatment_manager:
                data.update({'treatment_manager': treatment_manager})
            if vuln == 'lines' and data['where'].find('\\') >= 0:
                path = data['where'].replace('\\', '\\\\')
                raise InvalidPath(expr=f'"values": "{path}"')
            if (vuln_utils.is_range(specific) or
                    vuln_utils.is_sequence(specific)):
                response.extend(
                    ungroup_vulnerability_specific(vuln, specific, data)
                )
            else:
                if (vuln == 'ports' and
                        not 0 <= int(specific) <= 65535):
                    raise InvalidPort(expr=f'"values": "{specific}"')
                response.append(
                    {**data, 'specific': specific}
                )
    return response


async def get_by_finding(
    finding_id: str,
    vuln_id: str
) -> Dict[str, FindingType]:
    vuln = await vuln_dal.get_by_finding(finding_id, uuid=vuln_id)
    first_vuln = cast(Dict[str, List[Dict[str, str]]], vuln[0])
    if not vuln:
        raise VulnNotFound()
    if first_vuln.get(
        'historic_state', [{}]
    )[-1].get('state', '') == 'DELETED':
        raise VulnNotFound()
    return vuln[0]


async def get(vuln_id: str) -> Dict[str, FindingType]:
    vuln = await vuln_dal.get(vuln_id)
    first_vuln = cast(Dict[str, List[Dict[str, str]]], vuln[0])
    if not vuln:
        raise VulnNotFound()
    if first_vuln.get(
        'historic_state', [{}]
    )[-1].get('state', '') == 'DELETED':
        raise VulnNotFound()
    return vuln[0]


async def get_by_ids(vulns_ids: List[str]) -> List[Dict[str, FindingType]]:
    result: List[Dict[str, FindingType]] = await aio.materialize(
        get(vuln_id)
        for vuln_id in vulns_ids
    )
    return result


def validate_requested_verification(
        vuln: Dict[str, FindingType]) -> Dict[str, FindingType]:
    """ Validate vuln is not resquested """
    historic_verification = cast(
        List[Dict[str, FindingType]],
        vuln.get('historic_verification', [{}])
    )
    if historic_verification[-1].get('status', '') == 'REQUESTED':
        raise AlreadyRequested()
    return vuln


def validate_closed(vuln: Dict[str, FindingType]) -> Dict[str, FindingType]:
    """ Validate vuln closed """
    if cast(
        List[Dict[str, FindingType]],
        vuln.get('historic_state', [{}])
    )[-1].get('state') == 'closed':
        raise VulnAlreadyClosed()
    return vuln


async def request_verification(
        finding_id: str,
        user_email: str,
        user_fullname: str,
        justification: str,
        vuln_ids: List[str]) -> bool:
    finding = await finding_dal.get_finding(finding_id)
    vulnerabilities = await get_by_ids(vuln_ids)
    vulnerabilities = [
        validate_requested_verification(vuln)
        for vuln in vulnerabilities
    ]
    vulnerabilities = [validate_closed(vuln) for vuln in vulnerabilities]
    if not vulnerabilities:
        raise VulnNotFound()
    comment_id = int(round(time() * 1000))
    tzn = pytz.timezone(settings.TIME_ZONE)
    today = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    historic_verification = cast(
        List[Dict[str, Union[str, int, List[str]]]],
        finding.get('historic_verification', [])
    )
    historic_verification.append({
        'date': today,
        'user': user_email,
        'status': 'REQUESTED',
        'comment': comment_id,
        'vulns': vuln_ids
    })
    update_finding = await finding_dal.update(
        finding_id, {'historic_verification': historic_verification})
    comment_data = {
        'comment_type': 'verification',
        'content': justification,
        'created': today,
        'email': user_email,
        'finding_id': int(finding_id),
        'fullname': user_fullname,
        'modified': today,
        'parent': 0,
    }
    await comment_dal.create(comment_id, comment_data)
    update_vulns = await aio.materialize(
        map(vuln_dal.request_verification, vulnerabilities)
    )
    if all(update_vulns) and update_finding:
        await finding_utils.send_remediation_email(
            user_email, finding_id, str(finding.get('finding', '')),
            str(finding.get('project_name', '')),
            justification
        )
    else:
        LOGGER.error('An error occurred remediating', **NOEXTRA)
    return all(update_vulns)


def is_reattack_requested(vuln: Dict[str, FindingType]) -> bool:
    response = False
    historic_verification = vuln.get('historic_verification', [{}])
    if cast(
        List[Dict[str, str]],
        historic_verification
    )[-1].get('status', '') == 'REQUESTED':
        response = True

    return response


def validate_verify(vuln: Dict[str, FindingType]) -> Dict[str, FindingType]:
    """ Validate vuln is resquested """
    if not is_reattack_requested(vuln):
        raise NotVerificationRequested()
    return vuln


async def verify_vulnerabilities(
        finding_id: str,
        user_email: str,
        user_fullname: str,
        info: GraphQLResolveInfo,
        parameters: Dict[str, FindingType]) -> bool:
    finding = await finding_dal.get_finding(finding_id)
    vuln_ids = (
        cast(List[str], parameters.get('open_vulns', [])) +
        cast(List[str], parameters.get('closed_vulns', []))
    )
    vulnerabilities = await get_by_ids(vuln_ids)
    vulnerabilities = [validate_verify(vuln) for vuln in vulnerabilities]
    vulnerabilities = [validate_closed(vuln) for vuln in vulnerabilities]
    if not vulnerabilities:
        raise VulnNotFound()
    tzn = pytz.timezone(settings.TIME_ZONE)
    today = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    comment_id = int(round(time() * 1000))
    historic_verification = cast(
        List[Dict[str, Union[str, int, List[str]]]],
        finding.get('historic_verification', [])
    )
    historic_verification.append({
        'date': today,
        'user': user_email,
        'status': 'VERIFIED',
        'comment': comment_id,
        'vulns': vuln_ids
    })
    update_finding = await finding_dal.update(
        finding_id,
        {'historic_verification': historic_verification}
    )
    comment_data: comment_dal.CommentType = {
        'comment_type': 'verification',
        'content': parameters.get('justification', ''),
        'created': today,
        'email': user_email,
        'finding_id': int(finding_id),
        'fullname': user_fullname,
        'modified': today,
        'parent': 0,
    }
    await comment_dal.create(comment_id, comment_data)
    success = await aio.materialize(
        map(vuln_dal.verify_vulnerability, vulnerabilities)
    )
    if all(success) and update_finding:
        success = await verify(
            info,
            finding_id,
            vulnerabilities,
            cast(List[str], parameters.get('closed_vulns', [])),
            today
        )
    else:
        LOGGER.error('An error occurred verifying', **NOEXTRA)
    return all(success)


async def verify(
        info: GraphQLResolveInfo,
        finding_id: str,
        vulnerabilities: List[Dict[str, FindingType]],
        closed_vulns: List[str],
        date: str) -> List[bool]:
    finding = await finding_dal.get_finding(finding_id)
    success: List[bool] = await aio.materialize(
        update_vuln_state(
            info, vuln, {'state': 'closed'}, finding_id, date
        )
        for vuln in vulnerabilities
        if vuln.get('UUID') in closed_vulns
    )
    await finding_utils.send_finding_verified_email(
        finding_id,
        str(finding.get('finding', '')),
        str(finding.get('project_name', ''))
    )
    return success


async def get_vulnerabilities_file(finding_id: str, project_name: str) -> str:
    vulnerabilities = await get_vulnerabilities_by_type(finding_id)
    file_name = f'/tmp/{project_name}-{finding_id}_{str(uuid.uuid4())}.yaml'
    with open(file_name, 'w') as stream:
        yaml.safe_dump(vulnerabilities, stream, default_flow_style=False)
    uploaded_file_url = ''
    with open(file_name, 'rb') as bstream:
        uploaded_file_name = await vuln_dal.upload_file(
            ContentFile(bstream.read(), name=bstream.name)
        )
        uploaded_file_url = await vuln_dal.sign_url(uploaded_file_name)

    return uploaded_file_url
