# pylint: disable=import-error
from api.schema import (
    SCHEMA,
)
from ariadne import (
    graphql,
)
from back.test.unit.src.utils import (
    create_dummy_session,
)
from custom_exceptions import (
    AcceptanceNotRequested,
    InvalidAssigned,
    InvalidSchema,
    InvalidStream,
    RootNotFound,
    VulnNotFound,
)
from dataloaders import (
    apply_context_attrs,
    Dataloaders,
    get_new_context,
)
from datetime import (
    datetime,
)
from db_model import (
    toe_inputs as toe_inputs_model,
)
from db_model.enums import (
    Source,
)
from db_model.finding_comments.enums import (
    CommentType,
)
from db_model.finding_comments.types import (
    FindingComment,
    FindingCommentsRequest,
)
from db_model.findings.types import (
    Finding,
)
from db_model.roots.types import (
    Root,
)
from db_model.toe_inputs.types import (
    ToeInput,
    ToeInputState,
)
from db_model.vulnerabilities.enums import (
    VulnerabilityStateStatus,
    VulnerabilityType,
    VulnerabilityVerificationStatus as VVerifStatus,
)
from db_model.vulnerabilities.types import (
    Vulnerability,
)
from findings import (
    domain as findings_domain,
)
from freezegun import (
    freeze_time,
)
import json
from organizations_finding_policies import (
    domain as policies_domain,
)
import os
import pytest
from starlette.datastructures import (
    UploadFile,
)
from typing import (
    Any,
    Dict,
    Tuple,
)

pytestmark = pytest.mark.asyncio


async def _get_result_async(
    data: Dict[str, Any], user: str = "integratesmanager@gmail.com"
) -> Dict[str, Any]:
    """Get result."""
    request = await create_dummy_session(user)
    request = apply_context_attrs(request)  # type: ignore
    _, result = await graphql(SCHEMA, data, context_value=request)

    return result


@pytest.mark.changes_db
async def test_remove_vulnerability() -> None:
    """Check for removeVulnerability mutation."""
    query = """
        mutation{
            removeVulnerability (
            id: "a8c0ff07-bb21-4cd5-bb9f-4d716fc69320"
            findingId: "475041513"
            justification: REPORTING_ERROR
            ) {
            success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data)
    assert "errors" not in result
    assert "success" in result["data"]["removeVulnerability"]
    with pytest.raises(VulnNotFound):
        loaders = get_new_context()
        assert await loaders.vulnerability.load(
            "a8c0ff07-bb21-4cd5-bb9f-4d716fc69320"
        )


@pytest.mark.changes_db
async def test_upload_file() -> None:
    """Check for uploadFile mutation."""
    # pylint: disable=too-many-locals
    finding_id = "463558592"
    vuln_uuid = "74632c0c-db08-47c2-b013-c70e5b67c49f"
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "./mock/evidences/test-vulns.yaml")
    loaders: Dataloaders = get_new_context()
    vuln: Vulnerability = await loaders.vulnerability.load(vuln_uuid)
    assert vuln.verification.status == VVerifStatus.REQUESTED  # type: ignore

    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name,
            file=test_file,
            content_type="text/x-yaml",  # NOSONAR
        )
        query = """
            mutation UploadFileMutation(
                $file: Upload!, $findingId: String!
            ) {
                uploadFile (
                    file: $file,
                    findingId: $findingId
                ) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": finding_id,
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" not in result
    assert "success" in result["data"]["uploadFile"]
    loaders.vulnerability.clear(vuln_uuid)
    vuln = await loaders.vulnerability.load(vuln_uuid)
    assert vuln.verification.status == VVerifStatus.VERIFIED  # type: ignore
    finding: Finding = await loaders.finding.load(finding_id)
    assert len(finding.verification.vulnerability_ids) == 2  # type: ignore

    query = """
        query GetFindingVulnInfo($findingId: String!) {
            finding(identifier: $findingId) {
                title
                vulnerabilitiesConnection {
                    edges {
                        node {
                            commitHash
                            stream
                            specific
                            where
                            historicTreatment {
                                user
                                treatment
                            }
                        }
                    }
                }
            }
        }
    """
    data = {"query": query, "variables": {"findingId": finding_id}}
    result = await _get_result_async(data)
    assert "errors" not in result
    finding_name: str = result["data"]["finding"]["title"]
    loaders = get_new_context()
    finding_policy = await policies_domain.get_finding_policy_by_name(
        loaders=loaders,
        organization_name="okada",
        finding_name=finding_name.lower(),
    )
    assert finding_policy is not None
    user_policy = finding_policy.state.modified_by
    vulnerabilities = result["data"]["finding"]["vulnerabilitiesConnection"][
        "edges"
    ]
    for edge in vulnerabilities:
        vuln = edge["node"]
        if (
            vuln["where"] == "https://example.com"  # type: ignore
            and vuln["specific"] == "phone"  # type: ignore
        ):
            assert vuln["stream"] == "home > blog > articulo"  # type: ignore
            assert (
                vuln["historicTreatment"][-1]["treatment"]  # type: ignore
                == "ACCEPTED_UNDEFINED"
            )
            assert (
                vuln["historicTreatment"][-1]["user"]  # type: ignore
                == user_policy
            )
        if (
            vuln["where"] == "path/to/file3.ext"  # type: ignore
            and vuln["specific"] == "345"  # type: ignore
        ):
            assert (
                vuln["commitHash"]  # type: ignore
                == "e17059d1e17059d1e17059d1e17059d1e17059d1"
            )


@pytest.mark.changes_db
async def test_upload_file_reopen() -> None:
    """Check if a new vuln is created when a closed vuln is reopen"""
    closed_vuln_uuid = "74632c0c-db08-47c2-b013-c70e5b67c49f"
    loaders: Dataloaders = get_new_context()
    vuln: Vulnerability = await loaders.vulnerability.load(closed_vuln_uuid)
    assert vuln.verification.status == VVerifStatus.VERIFIED  # type: ignore
    assert vuln.state.status == VulnerabilityStateStatus.SAFE

    finding_id = "463558592"
    finding: Finding = await loaders.finding.load(finding_id)
    finding_vulns_before = await loaders.finding_vulnerabilities.load(
        finding_id
    )

    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(
        filename, "./mock/evidences/test-vulns-reopen.yaml"
    )
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name,
            file=test_file,
            content_type="text/x-yaml",  # NOSONAR
        )
        query = """
            mutation UploadFileMutation(
                $file: Upload!, $findingId: String!
            ) {
                uploadFile (
                    file: $file,
                    findingId: $findingId
                ) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": finding_id,
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" not in result
    assert "success" in result["data"]["uploadFile"]
    loaders.finding_vulnerabilities.clear(finding_id)
    finding_vulns = await loaders.finding_vulnerabilities.load(finding_id)
    assert len(finding_vulns) == len(finding_vulns_before) + 1

    vuln = await loaders.vulnerability.load(closed_vuln_uuid)
    assert vuln.verification.status == VVerifStatus.VERIFIED  # type: ignore
    assert vuln.state.status == VulnerabilityStateStatus.SAFE

    for vuln in finding_vulns:
        if (
            vuln.state.where == "test/test#.config"
            and vuln.state.specific == "123"
            and vuln.id != closed_vuln_uuid
        ):
            root: Root = await loaders.root.load(
                (finding.group_name, vuln.root_id)
            )
            assert vuln.type == VulnerabilityType.LINES
            assert (
                vuln.state.commit == "5b5c92105b5c92105b5c92105b5c92105b5c9210"
            )
            assert root.state.nickname == "universe"
            assert vuln.state.status == VulnerabilityStateStatus.VULNERABLE


@pytest.mark.changes_db
async def test_upload_file_with_escaper() -> None:
    """Test fields source and escaper"""
    finding_id = "463558592"
    loaders: Dataloaders = get_new_context()
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(
        filename, "./mock/evidences/test-vulns-escaper.yaml"
    )
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name,
            file=test_file,
            content_type="text/x-yaml",  # NOSONAR
        )
        query = """
            mutation UploadFileMutation(
                $file: Upload!, $findingId: String!
            ) {
                uploadFile (
                    file: $file,
                    findingId: $findingId
                ) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": finding_id,
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" not in result
    assert "success" in result["data"]["uploadFile"]

    finding_vulns: Tuple[
        Vulnerability, ...
    ] = await loaders.finding_vulnerabilities.load(finding_id)
    vuln_escaped = next(
        vuln
        for vuln in finding_vulns
        if vuln.state.where == "test/test#.config"
        and vuln.state.specific == "89"
        and vuln.type == VulnerabilityType.LINES
    )
    assert vuln_escaped.state.status == VulnerabilityStateStatus.VULNERABLE
    assert vuln_escaped.state.source == Source.ESCAPE


@pytest.mark.changes_db
@freeze_time("2022-10-28")
async def test_upload_file_reattack_requested() -> None:
    """Existing vulns with reattacks requested are verified."""
    finding_id = "463558592"
    loaders: Dataloaders = get_new_context()
    finding_vulns: Tuple[
        Vulnerability, ...
    ] = await loaders.finding_vulnerabilities.load(finding_id)
    vuln_to_verify_open: Vulnerability = next(
        vuln
        for vuln in finding_vulns
        if vuln.state.where == "test/test#.config"
        and vuln.state.specific == "123"
        and vuln.type == VulnerabilityType.LINES
        and vuln.state.status == VulnerabilityStateStatus.VULNERABLE
    )
    vuln_to_verify_closed: Vulnerability = next(
        vuln
        for vuln in finding_vulns
        if vuln.state.where == "test/test#.config"
        and vuln.state.specific == "89"
        and vuln.type == VulnerabilityType.LINES
        and vuln.state.status == VulnerabilityStateStatus.VULNERABLE
    )
    await findings_domain.request_vulnerabilities_verification(
        loaders=loaders,
        finding_id=finding_id,
        user_info={
            "user_email": "verifier@test.com",
            "first_name": "Akira",
            "last_name": "Toriyama",
        },
        justification=(
            "We are requesting reattacks, before verification "
            "through the uploaded vuln yaml file"
        ),
        vulnerability_ids={vuln_to_verify_open.id, vuln_to_verify_closed.id},
    )

    loaders.vulnerability.clear(vuln_to_verify_open.id)
    vuln_to_verify_open = await loaders.vulnerability.load(
        vuln_to_verify_open.id
    )
    assert (
        vuln_to_verify_open.verification.status  # type: ignore
        == VVerifStatus.REQUESTED
    )
    finding_comments: tuple[
        FindingComment, ...
    ] = await loaders.finding_comments.load(
        FindingCommentsRequest(
            comment_type=CommentType.COMMENT, finding_id=finding_id
        )
    ) + await loaders.finding_comments.load(
        FindingCommentsRequest(
            comment_type=CommentType.VERIFICATION, finding_id=finding_id
        )
    )
    assert finding_comments[-1].comment_type == CommentType.VERIFICATION
    assert finding_comments[-1].full_name == "Akira Toriyama"
    assert (
        finding_comments[-1].content
        == "We are requesting reattacks, before verification "
        "through the uploaded vuln yaml file"
    )

    loaders.vulnerability.clear(vuln_to_verify_closed.id)
    vuln_to_verify_closed = await loaders.vulnerability.load(
        vuln_to_verify_closed.id
    )
    assert (
        vuln_to_verify_closed.verification.status  # type: ignore
        == VVerifStatus.REQUESTED
    )

    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(
        filename, "./mock/evidences/test-vulns-reattack-requested.yaml"
    )
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name,
            file=test_file,
            content_type="text/x-yaml",  # NOSONAR
        )
        query = """
            mutation UploadFileMutation(
                $file: Upload!, $findingId: String!
            ) {
                uploadFile (
                    file: $file,
                    findingId: $findingId
                ) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": finding_id,
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" not in result
    assert "success" in result["data"]["uploadFile"]

    loaders.vulnerability.clear(vuln_to_verify_open.id)
    vuln_to_verify_open = await loaders.vulnerability.load(
        vuln_to_verify_open.id
    )
    assert (
        vuln_to_verify_open.state.status == VulnerabilityStateStatus.VULNERABLE
    )
    assert (
        vuln_to_verify_open.verification.status  # type: ignore
        == VVerifStatus.VERIFIED
    )

    loaders.vulnerability.clear(vuln_to_verify_closed.id)
    vuln_to_verify_closed = await loaders.vulnerability.load(
        vuln_to_verify_closed.id
    )
    assert vuln_to_verify_closed.state.status == VulnerabilityStateStatus.SAFE
    assert (
        vuln_to_verify_closed.verification.status  # type: ignore
        == VVerifStatus.VERIFIED
    )


@pytest.mark.changes_db
async def test_upload_file_deduplicate_vulns() -> None:
    """With repeated vulns, only the latest will be taken into account."""
    await toe_inputs_model.add(
        toe_input=ToeInput(
            component="https://duplicated_where.com",
            entry_point="phone",
            group_name="unittesting",
            state=ToeInputState(
                attacked_at=None,
                attacked_by="",
                be_present=True,
                be_present_until=None,
                first_attack_at=None,
                has_vulnerabilities=False,
                modified_by="hacker@fluidattacks.com",
                modified_date=datetime.fromisoformat(
                    "2022-02-02T06:00:00+00:00"
                ),
                seen_at=datetime.fromisoformat("2020-03-14T05:00:00+00:00"),
                seen_first_time_by="test@test.com",
                unreliable_root_id="4039d098-ffc5-4984-8ed3-eb17bca98e19",
            ),
        )
    )

    finding_id = "463558592"
    loaders: Dataloaders = get_new_context()
    finding_vulns_before = await loaders.finding_vulnerabilities.load(
        finding_id
    )
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(
        filename, "./mock/evidences/test-vulns-deduplication.yaml"
    )
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name,
            file=test_file,
            content_type="text/x-yaml",  # NOSONAR
        )
        query = """
            mutation UploadFileMutation(
                $file: Upload!, $findingId: String!
            ) {
                uploadFile (
                    file: $file,
                    findingId: $findingId
                ) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": finding_id,
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" not in result
    assert "success" in result["data"]["uploadFile"]

    loaders.finding_vulnerabilities.clear(finding_id)
    finding_vulns = await loaders.finding_vulnerabilities.load(finding_id)
    assert len(finding_vulns) == len(finding_vulns_before) + 2

    inputs_vuln: Vulnerability = next(
        vuln
        for vuln in finding_vulns
        if vuln.state.where == "https://duplicated_where.com"
        and vuln.state.specific == "phone"
        and vuln.type == VulnerabilityType.INPUTS
    )
    assert inputs_vuln.state.status == VulnerabilityStateStatus.VULNERABLE
    assert inputs_vuln.stream == ["home", "info", "contact_us"]

    lines_vuln: Vulnerability = next(
        vuln
        for vuln in finding_vulns
        if vuln.state.where == "test/test#.config"
        and vuln.state.specific == "78"
        and vuln.type == VulnerabilityType.LINES
    )
    assert lines_vuln.state.status == VulnerabilityStateStatus.VULNERABLE
    assert (
        lines_vuln.state.commit == "5b5c92105b5c92105b5c92105b5c92105b5c9210"
    )


async def test_upload_file_error() -> None:
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "./mock/evidences/test-vuln-error.yaml")

    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name, file=test_file, content_type="text/x-yaml"
        )
        query = """
            mutation UploadFileMutation($file: Upload!, $findingId: String!) {
                uploadFile (file: $file, findingId: $findingId) {
                    success
                }
            }
        """  # NOSONAR
        variables = {
            "file": uploaded_file,
            "findingId": "463558592",
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" in result
    field_pattern = [
        r"^(\b[\w-]{1,30}\b)+(,\b[\w-]{1,30}\b){0,9}$",
        "/inputs/0/stream",
    ]
    error_value = f'"values": [{json.dumps(field_pattern)}], "keys": []'
    assert result["errors"][0]["message"] == str(InvalidSchema(error_value))


async def test_upload_file_error_commit_hash() -> None:
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(
        filename, "./mock/evidences/test-vuln-commit-hash-error.yaml"
    )

    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name, file=test_file, content_type="text/x-yaml"
        )
        query = """
            mutation UploadFileMutation($file: Upload!, $findingId: String!) {
                uploadFile (file: $file, findingId: $findingId) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": "463558592",
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" in result
    field_pattern = [r"^([a-f0-9]{40})$", "/lines/0/commit_hash"]
    error_value = f'"values": [{json.dumps(field_pattern)}], "keys": []'
    assert result["errors"][0]["message"] == str(InvalidSchema(error_value))


async def test_upload_file_error_stream() -> None:
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(
        filename, "./mock/evidences/test-vuln-error-stream.yaml"
    )
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name, file=test_file, content_type="text/x-yaml"
        )
        query = """
            mutation UploadFileMutation($file: Upload!, $findingId: String!) {
                uploadFile (file: $file, findingId: $findingId) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": "463558592",
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" in result
    assert result["errors"][0]["message"] == str(InvalidStream("inputs", "0"))


async def test_upload_file_error_root() -> None:
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(
        filename, "./mock/evidences/test-vuln-error-root.yaml"
    )
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name, file=test_file, content_type="text/x-yaml"
        )
        query = """
            mutation UploadFileMutation($file: Upload!, $findingId: String!) {
                uploadFile (file: $file, findingId: $findingId) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": "463558592",
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" in result
    assert result["errors"][0]["message"] == str(RootNotFound())


async def test_download_vuln_file() -> None:
    """Check for downloadVulnerabilityFile mutation."""
    query = """
        mutation DownloadVulnerabilityFile($findingId: String!) {
            downloadVulnerabilityFile (findingId: $findingId) {
                url
                success
            }
        }
    """
    finding_id = "463461507"
    group_name = "unittesting"
    variables = {
        "findingId": finding_id,
    }
    data = {"query": query, "variables": variables}
    result = await _get_result_async(data)
    assert "errors" not in result
    assert "success" in result["data"]["downloadVulnerabilityFile"]
    assert "url" in result["data"]["downloadVulnerabilityFile"]
    assert (
        f"reports/{group_name}-{finding_id}"
        in result["data"]["downloadVulnerabilityFile"]["url"]
    )


async def test_handle_acceptance_not_requested() -> None:
    query = """
        mutation {
            handleVulnerabilitiesAcceptance(
                findingId: "436992569"
                justification: "handle acceptance"
                acceptedVulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275"]
                rejectedVulnerabilities:
                    ["5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    assert "errors" in result
    assert result["errors"][0]["message"] == str(AcceptanceNotRequested())


async def test_update_vulns_treatment_invalid_assigned() -> None:
    query = """
        mutation UpdateVulnerabilitiesTreatment(
            $assigned: String,
            $findingId: String!,
            $justification: String!,
            $treatment: UpdateClientDescriptionTreatment!,
            $vulnerabilityId: ID!
        ) {
            updateVulnerabilitiesTreatment (
                assigned: $assigned
                findingId: $findingId
                justification: $justification
                treatment: $treatment
                vulnerabilityId: $vulnerabilityId
            ) {
                success
            }
        }
    """
    variables = {
        "assigned": "integratesreviewer@fluidattacks.com",
        "findingId": "436992569",
        "treatment": "IN_PROGRESS",
        "justification": "Test in progress treatment",
        "vulnerabilityId": "b16ed89e-668d-42d6-add1-73535bb0e083",
    }
    data = {"query": query, "variables": variables}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    assert "errors" in result
    assert result["errors"][0]["message"] == str(InvalidAssigned())


async def test_vulnerability_verification() -> None:
    vuln1_id = "587c40de-09a0-4d85-a9f9-eaa46aa895d7"
    vuln2_id = "15375781-31f2-4953-ac77-f31134225747"
    expected_vuln1 = {
        "finding_id": "436992569",
        "UUID": vuln1_id,
        "vulnerability_type": "ports",
        "specific": "1111",
        # FP: local testing
        "where": "192.168.100.112",  # NOSONAR
        "cycles": 1,
        "last_requested_reattack_date": "2020-02-19 10:41:04",
        "efficacy": 0,
        "report_date": "2019-09-13 17:00:56",
        "last_reattack_date": None,
        "last_reattack_requester": "integratesuser@gmail.com",
    }
    expected_vuln2 = {
        "finding_id": "436992569",
        "UUID": vuln2_id,
        "vulnerability_type": "ports",
        "specific": "333",
        # FP: local testing
        "where": "192.168.100.101",  # NOSONAR
        "cycles": 1,
        "last_requested_reattack_date": "2020-02-18 10:41:04",
        "efficacy": 0,
        "report_date": "2019-09-13 08:17:41",
        "last_reattack_date": "2020-02-19 10:41:04",
        "last_reattack_requester": "integratesuser@gmail.com",
    }
    query = """
        query GetVulnInfo($vuln1Id: String!, $vuln2Id: String!) {
            vuln1: vulnerability(uuid: $vuln1Id) {
                ...VulnInfo
            }
            vuln2: vulnerability(uuid: $vuln2Id) {
                ...VulnInfo
            }
        }
        fragment VulnInfo on Vulnerability {
            findingId
            id
            vulnerabilityType
            specific
            where
            cycles
            lastRequestedReattackDate
            efficacy
            reportDate
            lastReattackDate
            lastReattackRequester
        }
    """
    variables = {"vuln1Id": vuln1_id, "vuln2Id": vuln2_id}
    data = {"query": query, "variables": variables}
    result = await _get_result_async(data)
    assert "errors" not in result

    assert result["data"]["vuln1"]["findingId"] == expected_vuln1["finding_id"]
    assert result["data"]["vuln1"]["where"] == expected_vuln1["where"]
    assert result["data"]["vuln1"]["id"] == expected_vuln1["UUID"]
    assert result["data"]["vuln1"]["specific"] == expected_vuln1["specific"]
    assert (
        result["data"]["vuln1"]["vulnerabilityType"]
        == expected_vuln1["vulnerability_type"]
    )
    assert result["data"]["vuln1"][
        "lastRequestedReattackDate"
    ] == expected_vuln1.get("last_requested_reattack_date")
    assert result["data"]["vuln1"][
        "lastReattackRequester"
    ] == expected_vuln1.get("last_reattack_requester")
    assert result["data"]["vuln1"]["cycles"] == expected_vuln1["cycles"]
    assert result["data"]["vuln1"]["efficacy"] == expected_vuln1["efficacy"]
    assert (
        result["data"]["vuln1"]["reportDate"] == expected_vuln1["report_date"]
    )
    assert (
        result["data"]["vuln1"]["lastReattackDate"]
        == expected_vuln1["last_reattack_date"]
    )

    assert result["data"]["vuln2"]["findingId"] == expected_vuln2["finding_id"]
    assert result["data"]["vuln2"]["where"] == expected_vuln2["where"]
    assert result["data"]["vuln2"]["id"] == expected_vuln2["UUID"]
    assert result["data"]["vuln2"]["specific"] == expected_vuln2["specific"]
    assert (
        result["data"]["vuln2"]["vulnerabilityType"]
        == expected_vuln2["vulnerability_type"]
    )
    assert result["data"]["vuln2"][
        "lastRequestedReattackDate"
    ] == expected_vuln2.get("last_requested_reattack_date")
    assert result["data"]["vuln2"][
        "lastReattackRequester"
    ] == expected_vuln2.get("last_reattack_requester")
    assert result["data"]["vuln2"]["cycles"] == expected_vuln2["cycles"]
    assert result["data"]["vuln2"]["efficacy"] == expected_vuln2["efficacy"]
    assert (
        result["data"]["vuln2"]["reportDate"] == expected_vuln2["report_date"]
    )
    assert (
        result["data"]["vuln2"]["lastReattackDate"]
        == expected_vuln2["last_reattack_date"]
    )
