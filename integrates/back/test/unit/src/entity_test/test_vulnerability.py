# pylint: disable=too-many-lines, import-error
from api.schema import (
    SCHEMA,
)
from ariadne import (
    graphql,
)
from back.test.unit.src.utils import (
    create_dummy_session,
)
from comments import (
    domain as comments_domain,
)
from custom_exceptions import (
    AcceptanceNotRequested,
    InvalidAssigned,
    InvalidSchema,
    InvalidStream,
    RootNotFound,
    SameValues,
    VulnNotFound,
    VulnNotInFinding,
)
from dataloaders import (
    apply_context_attrs,
    Dataloaders,
    get_new_context,
)
from datetime import (
    datetime,
)
from db_model import (
    toe_inputs as toe_inputs_model,
    users as users_model,
)
from db_model.enums import (
    Source,
)
from db_model.findings.types import (
    Finding,
)
from db_model.roots.types import (
    Root,
)
from db_model.toe_inputs.types import (
    ToeInput,
)
from db_model.vulnerabilities.enums import (
    VulnerabilityAcceptanceStatus,
    VulnerabilityStateStatus,
    VulnerabilityTreatmentStatus,
    VulnerabilityType,
    VulnerabilityVerificationStatus,
    VulnerabilityZeroRiskStatus,
)
from db_model.vulnerabilities.types import (
    Vulnerability,
    VulnerabilityTreatment,
    VulnerabilityZeroRisk,
)
from findings import (
    domain as findings_domain,
)
from freezegun import (  # type: ignore
    freeze_time,
)
import json
from newutils import (
    datetime as datetime_utils,
)
from organizations_finding_policies import (
    domain as policies_domain,
)
import os
import pytest
from starlette.datastructures import (
    UploadFile,
)
from typing import (
    Any,
    Dict,
    Tuple,
)
from vulnerabilities import (
    domain as vulns_domain,
)

pytestmark = pytest.mark.asyncio


async def _get_result_async(
    data: Dict[str, Any], user: str = "integratesmanager@gmail.com"
) -> Dict[str, Any]:
    """Get result."""
    request = await create_dummy_session(user)
    request = apply_context_attrs(request)
    _, result = await graphql(SCHEMA, data, context_value=request)

    return result


async def test_vulnerability() -> None:
    vuln_uuid = "09afd608-aa53-4ccb-9094-0076181fa0ea"
    expected_output = {
        "finding_id": "475041513",
        "UUID": vuln_uuid,
        "vulnerability_type": "ports",
        "specific": "3636",
        # FP: local testing
        "where": "192.168.100.105",  # NOSONAR
        "historic_state": [
            {
                "date": "2019-09-13 09:58:38",
                "hacker": "unittest@fluidattacks.com",
                "source": "asm",
                "state": "open",
            }
        ],
        "historic_zero_risk": [
            {"date": "2018-09-28 10:32:58", "status": "REQUESTED"},
            {"date": "2020-09-09 16:01:26", "status": "CONFIRMED"},
        ],
        "zero_risk": "Confirmed",
    }
    query = """
        query {
            vulnerability(uuid: "$vuln_uuid") {
                findingId
                id
                vulnerabilityType
                specific
                where
                historicState {
                    date
                    hacker
                    source
                    state
                }
                historicZeroRisk {
                    date
                    status
                }
                zeroRisk
            }
        }
    """.replace(
        "$vuln_uuid", vuln_uuid
    )
    data = {"query": query}
    result = await _get_result_async(data)
    assert "errors" not in result
    assert result["data"]["vulnerability"]["findingId"] == expected_output.get(
        "finding_id"
    )
    assert result["data"]["vulnerability"]["where"] == expected_output.get(
        "where"
    )
    assert result["data"]["vulnerability"][
        "historicState"
    ] == expected_output.get("historic_state")
    assert result["data"]["vulnerability"][
        "historicZeroRisk"
    ] == expected_output.get("historic_zero_risk")
    assert result["data"]["vulnerability"]["id"] == expected_output.get("UUID")
    assert result["data"]["vulnerability"]["specific"] == expected_output.get(
        "specific"
    )
    assert result["data"]["vulnerability"][
        "vulnerabilityType"
    ] == expected_output.get("vulnerability_type")
    assert result["data"]["vulnerability"]["zeroRisk"] == expected_output.get(
        "zero_risk"
    )


@pytest.mark.changes_db
async def test_remove_tags() -> None:
    """Check for removeTags mutation."""
    query = """
        mutation {
            removeTags(
                findingId: "463558592",
                vulnerabilities: [
                    "0a848781-b6a4-422e-95fa-692151e6a98e",
                    "3bcdb384-5547-4170-a0b6-3b397a245465"
                ]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratesuser@gmail.com"
    )  # NOSONAR
    assert "errors" not in result
    assert "success" in result["data"]["removeTags"]
    assert result["data"]["removeTags"]["success"]


@pytest.mark.changes_db
async def test_update_vulnerability_treatment() -> None:
    """Check for updateVulnerabilityTreatment mutation."""
    query = """
        mutation {
            updateVulnerabilityTreatment (
                findingId: "475041513",
                vulnerabilityId: "09afd608-aa53-4ccb-9094-0076181fa0ea"
                externalBugTrackingSystem: "http://test"
            ){
            success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data, user="continuoushacking@gmail.com")
    assert "errors" not in result
    assert "success" in result["data"]["updateVulnerabilityTreatment"]
    assert result["data"]["updateVulnerabilityTreatment"]["success"]


@pytest.mark.changes_db
async def test_request_verification() -> None:
    """Check for requestVulnerabilitiesVerification mutation."""
    justification: str = "this is a comenting test of a request "
    "verification in vulns"  # pylint: disable=pointless-string-statement
    query = f"""
        mutation {{
            requestVulnerabilitiesVerification(
                findingId: "436992569",
                justification: "{justification}",
                vulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275",
                        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"]
            ) {{
                success
            }}
        }}
    """
    data = {"query": query}
    result = await _get_result_async(data)
    assert "errors" not in result
    assert "success" in result["data"]["requestVulnerabilitiesVerification"]
    loaders = get_new_context()
    vulnerability: Vulnerability = await loaders.vulnerability.load(
        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"
    )
    assert (
        vulnerability.verification.status
        == VulnerabilityVerificationStatus.REQUESTED
    )
    vulnerability = await loaders.vulnerability.load(
        "5afb9a49-a359-48ce-80ee-79c145919275"
    )
    assert (
        vulnerability.verification.status
        == VulnerabilityVerificationStatus.REQUESTED
    )


@pytest.mark.changes_db
async def test_verify_requested_vulns() -> None:
    """Check for verifyVulnerabilitiesRequest successful mutation."""
    query = """
        mutation {
            verifyVulnerabilitiesRequest(
                findingId: "436992569",
                justification: "Vuln verified",
                openVulnerabilities: ["5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"],
                closedVulnerabilities: ["5afb9a49-a359-48ce-80ee-79c145919275"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data)
    assert "errors" not in result
    assert "success" in result["data"]["verifyVulnerabilitiesRequest"]

    loaders: Dataloaders = get_new_context()
    open_vuln: Vulnerability = await loaders.vulnerability.load(
        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"
    )
    assert open_vuln.state.status == VulnerabilityStateStatus.OPEN
    assert (
        open_vuln.verification.status
        == VulnerabilityVerificationStatus.VERIFIED
    )

    closed_vuln: Vulnerability = await loaders.vulnerability.load(
        "5afb9a49-a359-48ce-80ee-79c145919275"
    )
    assert closed_vuln.state.status == VulnerabilityStateStatus.CLOSED
    assert (
        closed_vuln.verification.status
        == VulnerabilityVerificationStatus.VERIFIED
    )


@pytest.mark.changes_db
async def test_verify_requested_vulns_error() -> None:
    """Check for verifyVulnerabilitiesRequest failed mutation."""
    group_query = """
        mutation {
            updateGroup(
                comments: "",
                groupName: "oneshottest",
                subscription: CONTINUOUS,
                hasSquad: false,
                hasAsm: true,
                hasMachine: true,
                reason: NONE,
                tier: ONESHOT,
            ) {
                success
            }
        }
    """

    result = await _get_result_async({"query": group_query})
    assert "errors" not in result
    assert result["data"]["updateGroup"]["success"]

    query = """
        mutation {
            verifyVulnerabilitiesRequest(
                findingId: "475041513",
                justification: "Vuln verified",
                openVulnerabilities: ["09afd608-aa53-4ccb-9094-0076181fa0ea"],
                closedVulnerabilities: []
            ) {
                success
            }
        }
    """

    data = {"query": query}
    result = await _get_result_async(data)
    expected_error = "Exception - Error verification not requested"
    assert "errors" in result
    assert result["errors"][0]["message"] == expected_error


@pytest.mark.changes_db
async def test_request_zero_risk_vuln() -> None:
    """Check for requestVulnerabilitiesZeroRisk mutation."""
    query = """
        mutation {
            requestVulnerabilitiesZeroRisk(
                findingId: "436992569",
                justification: "request zero risk vuln",
                vulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275",
                        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratesuser2@gmail.com"
    )  # NOSONAR
    assert "errors" not in result
    assert "success" in result["data"]["requestVulnerabilitiesZeroRisk"]
    assert result["data"]["requestVulnerabilitiesZeroRisk"]["success"]

    comments = await comments_domain.get("zero_risk", "436992569")
    assert len(comments) == 1
    assert comments[0]["content"] == "request zero risk vuln"
    assert comments[0]["email"] == "integratesuser2@gmail.com"
    assert comments[0]["finding_id"] == "436992569"
    assert comments[0]["fullname"] == "unit test"  # NOSONAR
    comment_id = comments[0]["comment_id"]

    loaders = get_new_context()
    vulnerability: Vulnerability = await loaders.vulnerability.load(
        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"
    )
    assert vulnerability.zero_risk is not None
    assert vulnerability.zero_risk.comment_id == comment_id
    assert vulnerability.zero_risk.modified_by == "integratesuser2@gmail.com"
    assert (
        vulnerability.zero_risk.status == VulnerabilityZeroRiskStatus.REQUESTED
    )
    vulnerability = await loaders.vulnerability.load(
        "5afb9a49-a359-48ce-80ee-79c145919275"
    )
    assert vulnerability.zero_risk is not None
    assert vulnerability.zero_risk.comment_id == comment_id
    assert vulnerability.zero_risk.modified_by == "integratesuser2@gmail.com"
    assert (
        vulnerability.zero_risk.status == VulnerabilityZeroRiskStatus.REQUESTED
    )


@pytest.mark.changes_db
async def test_request_zero_risk_vuln_error_already_requested() -> None:
    """Check for already requested vuln with requestVulnerabilitiesZeroRisk
    mutation."""
    query = """
        mutation {
            requestVulnerabilitiesZeroRisk(
                findingId: "436992569",
                justification: "request zero risk vuln",
                vulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275",
                        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data)
    assert "errors" in result
    assert (
        result["errors"][0]["message"]
        == "Exception - Zero risk vulnerability is already requested"
    )

    loaders = get_new_context()
    vulnerability: Vulnerability = await loaders.vulnerability.load(
        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"
    )
    assert vulnerability.zero_risk is not None
    vulnerability = await loaders.vulnerability.load(
        "5afb9a49-a359-48ce-80ee-79c145919275"
    )
    assert vulnerability.zero_risk is not None

    comments = await comments_domain.get("zero_risk", "436992569")
    assert len(comments) == 1


@pytest.mark.changes_db
async def test_request_zero_risk_vuln_error_vuln_not_in_finding() -> None:
    """Check for vuln not in finding with requestVulnerabilitiesZeroRisk
    mutation."""
    query = """
        mutation {
            requestVulnerabilitiesZeroRisk(
                findingId: "436992569",
                justification: "request zero risk vuln",
                vulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275",
                        "09afd608-aa53-4ccb-9094-0076181fa0ea"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    assert "errors" in result
    assert result["errors"][0]["message"] == str(VulnNotInFinding())

    loaders = get_new_context()
    vulnerability: Vulnerability = await loaders.vulnerability.load(
        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"
    )
    assert vulnerability.zero_risk is not None
    vulnerability = await loaders.vulnerability.load(
        "5afb9a49-a359-48ce-80ee-79c145919275"
    )
    assert vulnerability.zero_risk is not None

    comments = await comments_domain.get("zero_risk", "436992569")
    assert len(comments) == 1


async def test_request_error_invalid_justification_lentgh() -> None:
    """Check for invalid justification length
    with requestVulnerabilitiesZeroRisk mutation."""
    justification = "x" * 10001
    query = f"""
        mutation {{
            requestVulnerabilitiesZeroRisk(
                findingId: "436992569",
                justification: "{justification}",
                vulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275",
                        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62952"]
            ) {{
                success
            }}
        }}
    """
    data = {"query": query}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    assert "errors" in result
    assert (
        result["errors"][0]["message"]
        == "Exception - Justification must have a maximum of 10000 characters"
    )  # NOSONAR


@pytest.mark.changes_db
@freeze_time("2019-11-30")
async def test_request_zero_risk_vuln_finding_state() -> None:
    query = """
        query GetFindingVulnInfo($findingId: String!) {
            finding(identifier: $findingId) {
                openVulnerabilities
                state
            }
        }
    """
    query_data = {"query": query, "variables": {"findingId": "463558592"}}
    query_result = await _get_result_async(query_data)
    assert "errors" not in query_result
    assert query_result["data"]["finding"]["openVulnerabilities"] == 1
    assert query_result["data"]["finding"]["state"] == "open"

    mutation = """
        mutation {
            requestVulnerabilitiesZeroRisk(
                findingId: "463558592",
                justification: "request zero risk vuln",
                vulnerabilities: ["0a848781-b6a4-422e-95fa-692151e6a98e"]
            ) {
                success
            }
        }
    """
    mutation_data = {"query": mutation}
    mutation_result = await _get_result_async(mutation_data)
    assert "errors" not in mutation_result
    assert (
        "success" in mutation_result["data"]["requestVulnerabilitiesZeroRisk"]
    )
    assert mutation_result["data"]["requestVulnerabilitiesZeroRisk"]["success"]

    query_data = {"query": query, "variables": {"findingId": "463558592"}}
    query_result = await _get_result_async(query_data)
    assert "errors" not in query_result
    assert query_result["data"]["finding"]["openVulnerabilities"] == 0
    assert query_result["data"]["finding"]["state"] == "closed"


@pytest.mark.changes_db
@freeze_time("2019-12-01")
async def test_confirm_zero_risk_vuln() -> None:
    """Check for confirmVulnerabilitiesZeroRisk mutation."""
    query = """
        mutation {
            confirmVulnerabilitiesZeroRisk(
                findingId: "463558592",
                justification: "confirm zero risk vuln",
                vulnerabilities:
                    ["54b94fa0-8f4f-4b10-a38a-6e848a9eb0c6",
                        "6f023c26-5b10-4ded-aa27-bb563c2206ab"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratesreviewer@fluidattacks.com"
    )  # NOSONAR
    assert "errors" not in result
    assert "success" in result["data"]["confirmVulnerabilitiesZeroRisk"]
    assert result["data"]["confirmVulnerabilitiesZeroRisk"]["success"]

    unsorted_comments = await comments_domain.get("zero_risk", "463558592")
    comments = sorted(
        unsorted_comments,
        key=lambda x: x.get("created"),
        reverse=True,
    )
    assert len(comments) == 2
    assert comments[0]["content"] == "confirm zero risk vuln"
    assert comments[0]["created"] == "2019-11-30 19:00:00"
    assert comments[0]["email"] == "integratesreviewer@fluidattacks.com"
    assert comments[0]["finding_id"] == "463558592"
    assert comments[0]["fullname"] == "unit test"
    assert comments[0]["modified"] == "2019-11-30 19:00:00"
    comment_id = comments[0]["comment_id"]

    loaders = get_new_context()
    historic_zero_risk: Tuple[
        VulnerabilityZeroRisk, ...
    ] = await loaders.vulnerability_historic_zero_risk.load(
        "6f023c26-5b10-4ded-aa27-bb563c2206ab"
    )
    assert len(historic_zero_risk) == 2
    assert historic_zero_risk[-1].comment_id == comment_id
    assert historic_zero_risk[-1].modified_date == "2019-12-01T00:00:00+00:00"
    assert (
        historic_zero_risk[-1].modified_by
        == "integratesreviewer@fluidattacks.com"
    )
    assert (
        historic_zero_risk[-1].status == VulnerabilityZeroRiskStatus.CONFIRMED
    )
    historic_zero_risk = await loaders.vulnerability_historic_zero_risk.load(
        "54b94fa0-8f4f-4b10-a38a-6e848a9eb0c6"
    )
    assert len(historic_zero_risk) == 2
    assert historic_zero_risk[-1].comment_id == comment_id
    assert historic_zero_risk[-1].modified_date == "2019-12-01T00:00:00+00:00"
    assert (
        historic_zero_risk[-1].modified_by
        == "integratesreviewer@fluidattacks.com"
    )
    assert (
        historic_zero_risk[-1].status == VulnerabilityZeroRiskStatus.CONFIRMED
    )


@pytest.mark.changes_db
async def test_confirm_zero_risk_vuln_error_not_requested() -> None:
    """Check for not requested zero risk vuln
    with confirmVulnerabilitiesZeroRisk mutation."""
    query = """
        mutation {
            confirmVulnerabilitiesZeroRisk(
                findingId: "463558592",
                justification: "confirm zero risk vuln",
                vulnerabilities:
                    ["54b94fa0-8f4f-4b10-a38a-6e848a9eb0c6",
                        "6f023c26-5b10-4ded-aa27-bb563c2206ab"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data)
    assert "errors" in result
    assert (
        result["errors"][0]["message"]
        == "Exception - Zero risk vulnerability is not requested"
    )

    loaders = get_new_context()
    historic_zero_risk: Tuple[
        VulnerabilityZeroRisk, ...
    ] = await loaders.vulnerability_historic_zero_risk.load(
        "6f023c26-5b10-4ded-aa27-bb563c2206ab"
    )
    assert len(historic_zero_risk) == 2
    historic_zero_risk = await loaders.vulnerability_historic_zero_risk.load(
        "54b94fa0-8f4f-4b10-a38a-6e848a9eb0c6"
    )
    assert len(historic_zero_risk) == 2

    comments = await comments_domain.get("zero_risk", "463558592")
    assert len(comments) == 2


@pytest.mark.changes_db
async def test_confirm_zero_risk_vuln_error_vuln_not_in_finding() -> None:
    """Check for vuln not in finding with confirmVulnerabilitiesZeroRisk
    mutation."""
    query = """
        mutation {
            confirmVulnerabilitiesZeroRisk(
                findingId: "463558592",
                justification: "confirm zero risk vuln",
                vulnerabilities:
                    ["54b94fa0-8f4f-4b10-a38a-6e848a9eb0c6",
                        "72bb8607-c259-4781-9599-185aac02b3cc"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratesreviewer@fluidattacks.com"
    )
    assert "errors" in result
    assert result["errors"][0]["message"] == str(VulnNotInFinding())

    loaders = get_new_context()
    historic_zero_risk: Tuple[
        VulnerabilityZeroRisk, ...
    ] = await loaders.vulnerability_historic_zero_risk.load(
        "6f023c26-5b10-4ded-aa27-bb563c2206ab"
    )
    assert len(historic_zero_risk) == 2
    historic_zero_risk = await loaders.vulnerability_historic_zero_risk.load(
        "54b94fa0-8f4f-4b10-a38a-6e848a9eb0c6"
    )
    assert len(historic_zero_risk) == 2

    comments = await comments_domain.get("zero_risk", "463558592")
    assert len(comments) == 2


async def test_confirm_error_invalid_justification_lentgh() -> None:  # noqa
    """Check for invalid justification lentgh
    with confirmVulnerabilitiesZeroRisk mutation."""
    justification = "x" * 10001
    query = f"""
        mutation {{
            confirmVulnerabilitiesZeroRisk(
                findingId: "436992569",
                justification: "{justification}",
                vulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275",
                        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62952"]
            ) {{
                success
            }}
        }}
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratesreviewer@fluidattacks.com"
    )
    assert "errors" in result
    assert (
        result["errors"][0]["message"]
        == "Exception - Justification must have a maximum of 10000 characters"
    )


@pytest.mark.changes_db
@freeze_time("2019-12-01")
async def test_reject_zero_risk_vuln() -> None:
    """Check for rejectVulnerabilitiesZeroRisk mutation."""
    query = """
        mutation {
            rejectVulnerabilitiesZeroRisk(
                findingId: "463558592",
                justification: "reject zero risk vuln",
                vulnerabilities:
                    ["3bcdb384-5547-4170-a0b6-3b397a245465",
                        "74632c0c-db08-47c2-b013-c70e5b67c49f"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratesreviewer@fluidattacks.com"
    )
    assert "errors" not in result
    assert "success" in result["data"]["rejectVulnerabilitiesZeroRisk"]
    assert result["data"]["rejectVulnerabilitiesZeroRisk"]["success"]

    unsorted_comments = await comments_domain.get("zero_risk", "463558592")
    comments = sorted(
        unsorted_comments,
        key=lambda x: x.get("created"),
        reverse=True,
    )
    assert len(comments) == 2
    assert comments[0]["content"] == "reject zero risk vuln"
    assert comments[0]["created"] == "2019-11-30 19:00:00"
    assert comments[0]["email"] == "integratesreviewer@fluidattacks.com"
    assert comments[0]["finding_id"] == "463558592"
    assert comments[0]["fullname"] == "unit test"
    assert comments[0]["modified"] == "2019-11-30 19:00:00"
    comment_id = comments[0]["comment_id"]

    loaders = get_new_context()
    historic_zero_risk: Tuple[
        VulnerabilityZeroRisk, ...
    ] = await loaders.vulnerability_historic_zero_risk.load(
        "3bcdb384-5547-4170-a0b6-3b397a245465"
    )
    assert len(historic_zero_risk) == 2
    assert historic_zero_risk[-1].comment_id == comment_id
    assert historic_zero_risk[-1].modified_date == "2019-12-01T00:00:00+00:00"
    assert (
        historic_zero_risk[-1].modified_by
        == "integratesreviewer@fluidattacks.com"
    )
    assert (
        historic_zero_risk[-1].status == VulnerabilityZeroRiskStatus.REJECTED
    )
    historic_zero_risk = await loaders.vulnerability_historic_zero_risk.load(
        "74632c0c-db08-47c2-b013-c70e5b67c49f"
    )
    assert len(historic_zero_risk) == 2
    assert historic_zero_risk[-1].comment_id == comment_id
    assert historic_zero_risk[-1].modified_date == "2019-12-01T00:00:00+00:00"
    assert (
        historic_zero_risk[-1].modified_by
        == "integratesreviewer@fluidattacks.com"
    )
    assert (
        historic_zero_risk[-1].status == VulnerabilityZeroRiskStatus.REJECTED
    )


@pytest.mark.changes_db
async def test_reject_zero_risk_vuln_error_not_requested() -> None:
    """Check for not requested zero risk vuln
    with rejectVulnerabilitiesZeroRisk mutation."""
    query = """
        mutation {
            rejectVulnerabilitiesZeroRisk(
                findingId: "463558592",
                justification: "reject zero risk vuln",
                vulnerabilities:
                    ["3bcdb384-5547-4170-a0b6-3b397a245465",
                        "74632c0c-db08-47c2-b013-c70e5b67c49f"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data)
    assert "errors" in result
    assert (
        result["errors"][0]["message"]
        == "Exception - Zero risk vulnerability is not requested"
    )

    loaders = get_new_context()
    historic_zero_risk: Tuple[
        VulnerabilityZeroRisk, ...
    ] = await loaders.vulnerability_historic_zero_risk.load(
        "3bcdb384-5547-4170-a0b6-3b397a245465"
    )
    assert len(historic_zero_risk) == 2
    historic_zero_risk = await loaders.vulnerability_historic_zero_risk.load(
        "74632c0c-db08-47c2-b013-c70e5b67c49f"
    )
    assert len(historic_zero_risk) == 2

    comments = await comments_domain.get("zero_risk", "463558592")
    assert len(comments) == 2


@pytest.mark.changes_db
async def test_reject_zero_risk_vuln_error_vuln_not_in_finding() -> None:
    """Check for vuln not in finding with rejectVulnerabilitiesZeroRisk
    mutation."""
    query = """
        mutation {
            rejectVulnerabilitiesZeroRisk(
                findingId: "463558592",
                justification: "reject zero risk vuln",
                vulnerabilities:
                    ["3bcdb384-5547-4170-a0b6-3b397a245465",
                        "81db1fad-c329-4356-a5eb-9ad9b0d75a7e"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratesreviewer@fluidattacks.com"
    )
    assert "errors" in result
    assert result["errors"][0]["message"] == str(VulnNotInFinding())

    loaders = get_new_context()
    historic_zero_risk: Tuple[
        VulnerabilityZeroRisk, ...
    ] = await loaders.vulnerability_historic_zero_risk.load(
        "3bcdb384-5547-4170-a0b6-3b397a245465"
    )
    assert len(historic_zero_risk) == 2
    historic_zero_risk = await loaders.vulnerability_historic_zero_risk.load(
        "74632c0c-db08-47c2-b013-c70e5b67c49f"
    )
    assert len(historic_zero_risk) == 2

    comments = await comments_domain.get("zero_risk", "463558592")
    assert len(comments) == 2


async def test_reject_error_invalid_justification_lentgh() -> None:
    """Check for invalid justification lentgh
    with rejectVulnerabilitiesZeroRisk mutation."""
    justification = "x" * 10001
    query = f"""
        mutation {{
            rejectVulnerabilitiesZeroRisk(
                findingId: "436992569",
                justification: "{justification}",
                vulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275",
                        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62952"]
            ) {{
                success
            }}
        }}
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratesreviewer@fluidattacks.com"
    )
    assert "errors" in result
    assert (
        result["errors"][0]["message"]
        == "Exception - Justification must have a maximum of 10000 characters"
    )


@pytest.mark.changes_db
async def test_remove_vulnerability() -> None:
    """Check for removeVulnerability mutation."""
    query = """
        mutation{
            removeVulnerability (
            id: "a8c0ff07-bb21-4cd5-bb9f-4d716fc69320"
            findingId: "475041513"
            justification: REPORTING_ERROR
            ) {
            success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data)
    assert "errors" not in result
    assert "success" in result["data"]["removeVulnerability"]
    with pytest.raises(VulnNotFound):
        loaders = get_new_context()
        assert await loaders.vulnerability.load(
            "a8c0ff07-bb21-4cd5-bb9f-4d716fc69320"
        )


@pytest.mark.changes_db
async def test_upload_file() -> None:
    """Check for uploadFile mutation."""
    # pylint: disable=too-many-locals
    finding_id = "463558592"
    vuln_uuid = "74632c0c-db08-47c2-b013-c70e5b67c49f"
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "../mock/test-vulns.yaml")
    loaders: Dataloaders = get_new_context()
    vuln: Vulnerability = await loaders.vulnerability.load(vuln_uuid)
    assert (
        vuln.verification.status == VulnerabilityVerificationStatus.REQUESTED
    )

    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name,
            file=test_file,
            content_type="text/x-yaml",  # NOSONAR
        )
        query = """
            mutation UploadFileMutation(
                $file: Upload!, $findingId: String!
            ) {
                uploadFile (
                    file: $file,
                    findingId: $findingId
                ) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": finding_id,
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" not in result
    assert "success" in result["data"]["uploadFile"]
    loaders.vulnerability.clear(vuln_uuid)
    vuln = await loaders.vulnerability.load(vuln_uuid)
    assert vuln.verification.status == VulnerabilityVerificationStatus.VERIFIED
    finding: Finding = await loaders.finding.load(finding_id)
    assert len(finding.verification.vulnerability_ids) == 2

    query = """
        query GetFindingVulnInfo($findingId: String!) {
            finding(identifier: $findingId) {
                title
                vulnerabilities {
                    commitHash
                    stream
                    specific
                    where
                    historicTreatment {
                        user
                        treatment
                    }
                }
            }
        }
    """
    data = {"query": query, "variables": {"findingId": finding_id}}
    result = await _get_result_async(data)
    assert "errors" not in result
    finding_name = result["data"]["finding"]["title"]
    finding_policy = await policies_domain.get_finding_policy_by_name(
        org_name="okada",
        finding_name=finding_name.lower(),
    )
    user_policy = finding_policy.state.modified_by
    vulnerabilities = result["data"]["finding"]["vulnerabilities"]
    for vuln in vulnerabilities:
        if (
            vuln["where"] == "https://example.com"
            and vuln["specific"] == "phone"
        ):
            assert vuln["stream"] == "home > blog > articulo"
            assert (
                vuln["historicTreatment"][-1]["treatment"]
                == "ACCEPTED_UNDEFINED"
            )
            assert vuln["historicTreatment"][-1]["user"] == user_policy
        if (
            vuln["where"] == "product/path/to/file3.ext"
            and vuln["specific"] == "345"
        ):
            assert (
                vuln["commitHash"]
                == "e17059d1e17059d1e17059d1e17059d1e17059d1"
            )


@pytest.mark.changes_db
async def test_upload_file_reopen() -> None:
    """Check if a new vuln is created when a closed vuln is reopen"""
    closed_vuln_uuid = "74632c0c-db08-47c2-b013-c70e5b67c49f"
    loaders: Dataloaders = get_new_context()
    vuln: Vulnerability = await loaders.vulnerability.load(closed_vuln_uuid)
    assert vuln.verification.status == VulnerabilityVerificationStatus.VERIFIED
    assert vuln.state.status == VulnerabilityStateStatus.CLOSED

    finding_id = "463558592"
    finding: Finding = await loaders.finding.load(finding_id)
    finding_vulns_before = await loaders.finding_vulnerabilities.load(
        finding_id
    )

    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "../mock/test-vulns-reopen.yaml")
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name,
            file=test_file,
            content_type="text/x-yaml",  # NOSONAR
        )
        query = """
            mutation UploadFileMutation(
                $file: Upload!, $findingId: String!
            ) {
                uploadFile (
                    file: $file,
                    findingId: $findingId
                ) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": finding_id,
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" not in result
    assert "success" in result["data"]["uploadFile"]
    loaders.finding_vulnerabilities.clear(finding_id)
    finding_vulns = await loaders.finding_vulnerabilities.load(finding_id)
    assert len(finding_vulns) == len(finding_vulns_before) + 1

    vuln = await loaders.vulnerability.load(closed_vuln_uuid)
    assert vuln.verification.status == VulnerabilityVerificationStatus.VERIFIED
    assert vuln.state.status == VulnerabilityStateStatus.CLOSED

    for vuln in finding_vulns:
        if (
            vuln.where == "product/test/test#.config"
            and vuln.specific == "123"
            and vuln.id != closed_vuln_uuid
        ):
            root: Root = await loaders.root.load(
                (finding.group_name, vuln.root_id)
            )
            assert vuln.type == VulnerabilityType.LINES
            assert vuln.commit == "5b5c92105b5c92105b5c92105b5c92105b5c9210"
            assert root.state.nickname == "product"
            assert vuln.state.status == VulnerabilityStateStatus.OPEN


@pytest.mark.changes_db
async def test_upload_file_with_escaper() -> None:
    """Test fields source and escaper"""
    finding_id = "463558592"
    loaders: Dataloaders = get_new_context()
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "../mock/test-vulns-escaper.yaml")
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name,
            file=test_file,
            content_type="text/x-yaml",  # NOSONAR
        )
        query = """
            mutation UploadFileMutation(
                $file: Upload!, $findingId: String!
            ) {
                uploadFile (
                    file: $file,
                    findingId: $findingId
                ) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": finding_id,
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" not in result
    assert "success" in result["data"]["uploadFile"]

    finding_vulns: Tuple[
        Vulnerability, ...
    ] = await loaders.finding_vulnerabilities.load(finding_id)
    vuln_escaped = next(
        vuln
        for vuln in finding_vulns
        if vuln.where == "product/test/test#.config"
        and vuln.specific == "890"
        and vuln.type == VulnerabilityType.LINES
    )
    assert vuln_escaped.state.status == VulnerabilityStateStatus.OPEN
    assert vuln_escaped.state.source == Source.ESCAPE
    assert vuln_escaped.state.modified_by == "escaper@fluidattacks.com"


@pytest.mark.changes_db
async def test_upload_file_reattack_requested() -> None:
    """Existing vulns with reattacks requested are verified."""
    finding_id = "463558592"
    loaders: Dataloaders = get_new_context()
    finding_vulns: Tuple[
        Vulnerability, ...
    ] = await loaders.finding_vulnerabilities.load(finding_id)
    vuln_to_verify_open: Vulnerability = next(
        vuln
        for vuln in finding_vulns
        if vuln.where == "product/test/test#.config"
        and vuln.specific == "123"
        and vuln.type == VulnerabilityType.LINES
        and vuln.state.status == VulnerabilityStateStatus.OPEN
    )
    vuln_to_verify_closed: Vulnerability = next(
        vuln
        for vuln in finding_vulns
        if vuln.where == "product/test/test#.config"
        and vuln.specific == "890"
        and vuln.type == VulnerabilityType.LINES
        and vuln.state.status == VulnerabilityStateStatus.OPEN
    )
    await users_model.update_user(
        user_email="verifier@test.com",
        notifications_preferences={
            "email": [
                "CHARTS_REPORT",
                "DAILY_DIGEST",
                "NEW_COMMENT",
                "NEW_DRAFT",
                "REMEDIATE_FINDING",
                "UPDATED_TREATMENT",
                "VULNERABILITY_ASSIGNED",
            ]
        },
    )
    await findings_domain.request_vulnerabilities_verification(
        loaders=loaders,
        finding_id=finding_id,
        user_info={
            "user_email": "verifier@test.com",
            "first_name": "Akira",
            "last_name": "Toriyama",
        },
        justification=(
            "We are requesting reattacks, before verification "
            "through the uploaded vuln yaml file"
        ),
        vulnerability_ids={vuln_to_verify_open.id, vuln_to_verify_closed.id},
    )

    loaders.vulnerability.clear(vuln_to_verify_open.id)
    vuln_to_verify_open = await loaders.vulnerability.load(
        vuln_to_verify_open.id
    )
    assert (
        vuln_to_verify_open.verification.status
        == VulnerabilityVerificationStatus.REQUESTED
    )

    loaders.vulnerability.clear(vuln_to_verify_closed.id)
    vuln_to_verify_closed = await loaders.vulnerability.load(
        vuln_to_verify_closed.id
    )
    assert (
        vuln_to_verify_closed.verification.status
        == VulnerabilityVerificationStatus.REQUESTED
    )

    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(
        filename, "../mock/test-vulns-reattack-requested.yaml"
    )
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name,
            file=test_file,
            content_type="text/x-yaml",  # NOSONAR
        )
        query = """
            mutation UploadFileMutation(
                $file: Upload!, $findingId: String!
            ) {
                uploadFile (
                    file: $file,
                    findingId: $findingId
                ) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": finding_id,
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" not in result
    assert "success" in result["data"]["uploadFile"]

    loaders.vulnerability.clear(vuln_to_verify_open.id)
    vuln_to_verify_open = await loaders.vulnerability.load(
        vuln_to_verify_open.id
    )
    assert vuln_to_verify_open.state.status == VulnerabilityStateStatus.OPEN
    assert (
        vuln_to_verify_open.verification.status
        == VulnerabilityVerificationStatus.VERIFIED
    )

    loaders.vulnerability.clear(vuln_to_verify_closed.id)
    vuln_to_verify_closed = await loaders.vulnerability.load(
        vuln_to_verify_closed.id
    )
    assert (
        vuln_to_verify_closed.state.status == VulnerabilityStateStatus.CLOSED
    )
    assert (
        vuln_to_verify_closed.verification.status
        == VulnerabilityVerificationStatus.VERIFIED
    )


@pytest.mark.changes_db
async def test_upload_file_deduplicate_vulns() -> None:
    """With repeated vulns, only the latest will be taken into account."""
    await toe_inputs_model.add(
        toe_input=ToeInput(
            attacked_at=None,
            attacked_by="",
            be_present=True,
            be_present_until=None,
            component="https://duplicated_where.com",
            entry_point="phone",
            first_attack_at=None,
            group_name="unittesting",
            has_vulnerabilities=False,
            seen_at=datetime.fromisoformat("2020-03-14T05:00:00+00:00"),
            seen_first_time_by="test@test.com",
            unreliable_root_id="4039d098-ffc5-4984-8ed3-eb17bca98e19",
        )
    )

    finding_id = "463558592"
    loaders: Dataloaders = get_new_context()
    finding_vulns_before = await loaders.finding_vulnerabilities.load(
        finding_id
    )
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "../mock/test-vulns-deduplication.yaml")
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name,
            file=test_file,
            content_type="text/x-yaml",  # NOSONAR
        )
        query = """
            mutation UploadFileMutation(
                $file: Upload!, $findingId: String!
            ) {
                uploadFile (
                    file: $file,
                    findingId: $findingId
                ) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": finding_id,
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" not in result
    assert "success" in result["data"]["uploadFile"]

    loaders.finding_vulnerabilities.clear(finding_id)
    finding_vulns = await loaders.finding_vulnerabilities.load(finding_id)
    assert len(finding_vulns) == len(finding_vulns_before) + 2

    inputs_vuln: Vulnerability = next(
        vuln
        for vuln in finding_vulns
        if vuln.where == "https://duplicated_where.com"
        and vuln.specific == "phone"
        and vuln.type == VulnerabilityType.INPUTS
    )
    assert inputs_vuln.state.status == VulnerabilityStateStatus.OPEN
    assert inputs_vuln.stream == ["home", "info", "contact_us"]

    lines_vuln: Vulnerability = next(
        vuln
        for vuln in finding_vulns
        if vuln.where == "product/test/test#.config"
        and vuln.specific == "678"
        and vuln.type == VulnerabilityType.LINES
    )
    assert lines_vuln.state.status == VulnerabilityStateStatus.OPEN
    assert lines_vuln.commit == "5b5c92105b5c92105b5c92105b5c92105b5c9210"


async def test_upload_file_error() -> None:
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "../mock/test-vuln-error.yaml")

    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name, file=test_file, content_type="text/x-yaml"
        )
        query = """
            mutation UploadFileMutation($file: Upload!, $findingId: String!) {
                uploadFile (file: $file, findingId: $findingId) {
                    success
                }
            }
        """  # NOSONAR
        variables = {
            "file": uploaded_file,
            "findingId": "463558592",
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" in result
    field_pattern = r"^(\b[\w-]{1,30}\b)+(,\b[\w-]{1,30}\b){0,9}$"
    error_value = f'"values": [{json.dumps(field_pattern)}], "keys": []'
    assert result["errors"][0]["message"] == str(InvalidSchema(error_value))


async def test_upload_file_error_commit_hash() -> None:
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(
        filename, "../mock/test-vuln-commit-hash-error.yaml"
    )

    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name, file=test_file, content_type="text/x-yaml"
        )
        query = """
            mutation UploadFileMutation($file: Upload!, $findingId: String!) {
                uploadFile (file: $file, findingId: $findingId) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": "463558592",
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" in result
    field_pattern = r"^([a-f0-9]{40})$"
    error_value = f'"values": [{json.dumps(field_pattern)}], "keys": []'
    assert result["errors"][0]["message"] == str(InvalidSchema(error_value))


async def test_upload_file_error_stream() -> None:
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "../mock/test-vuln-error-stream.yaml")
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name, file=test_file, content_type="text/x-yaml"
        )
        query = """
            mutation UploadFileMutation($file: Upload!, $findingId: String!) {
                uploadFile (file: $file, findingId: $findingId) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": "463558592",
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" in result
    assert result["errors"][0]["message"] == str(InvalidStream())


async def test_upload_file_error_root() -> None:
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "../mock/test-vuln-error-root.yaml")
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name, file=test_file, content_type="text/x-yaml"
        )
        query = """
            mutation UploadFileMutation($file: Upload!, $findingId: String!) {
                uploadFile (file: $file, findingId: $findingId) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": "463558592",
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" in result
    assert result["errors"][0]["message"] == str(RootNotFound())


async def test_download_vuln_file() -> None:
    """Check for downloadVulnerabilityFile mutation."""
    query = """
        mutation DownloadVulnerabilityFile($findingId: String!) {
            downloadVulnerabilityFile (findingId: $findingId) {
                url
                success
            }
        }
    """
    finding_id = "463461507"
    group_name = "unittesting"
    variables = {
        "findingId": finding_id,
    }
    data = {"query": query, "variables": variables}
    result = await _get_result_async(data)
    assert "errors" not in result
    assert "success" in result["data"]["downloadVulnerabilityFile"]
    assert "url" in result["data"]["downloadVulnerabilityFile"]
    assert (
        f"localhost:9000/fluidintegrates.reports/{group_name}-{finding_id}"
        in result["data"]["downloadVulnerabilityFile"]["url"]
    )


async def test_handle_acceptance_not_requested() -> None:
    query = """
        mutation {
            handleVulnerabilitiesAcceptance(
                findingId: "436992569"
                justification: "handle acceptance"
                acceptedVulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275"]
                rejectedVulnerabilities:
                    ["5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    assert "errors" in result
    assert result["errors"][0]["message"] == str(AcceptanceNotRequested())


async def test_handle_acceptance_vuln_not_found() -> None:
    query = """
        mutation {
            handleVulnerabilitiesAcceptance(
                findingId: "560175507"
                justification: "handle acceptance"
                acceptedVulnerabilities:
                    ["6f023c26-5x10-4ded-aa27-xx563c2206ax"]
                rejectedVulnerabilities: []
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    assert "errors" in result
    assert result["errors"][0]["message"] == str(VulnNotFound())


async def test_update_vulns_treatment_invalid_assigned() -> None:
    query = """
        mutation UpdateVulnerabilitiesTreatment(
            $findingId: String!,
            $justification: String!,
            $treatmentManager: String,
            $treatment: UpdateClientDescriptionTreatment!,
            $vulnerabilityId: ID!
        ) {
            updateVulnerabilitiesTreatment (
                findingId: $findingId
                justification: $justification
                treatment: $treatment
                treatmentManager: $treatmentManager
                vulnerabilityId: $vulnerabilityId
            ) {
                success
            }
        }
    """
    variables = {
        "findingId": "436992569",
        "treatment": "IN_PROGRESS",
        "justification": "Test in progress treatment",
        "treatmentManager": "integratesreviewer@fluidattacks.com",
        "vulnerabilityId": "b16ed89e-668d-42d6-add1-73535bb0e083",
    }
    data = {"query": query, "variables": variables}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    assert "errors" in result
    assert result["errors"][0]["message"] == str(InvalidAssigned())


@pytest.mark.changes_db
async def test_handle_acceptance() -> None:
    loaders: Dataloaders = get_new_context()
    finding_id = "436992569"
    query = """
        mutation UpdateVulnerabilitiesTreatment(
            $findingId: String!, $justification: String!
            $treatment: UpdateClientDescriptionTreatment!
            $assigned: String
            $acceptedVulnId: ID!
            $rejectedVulnId: ID!
        ) {
            accepted: updateVulnerabilitiesTreatment (
                findingId: $findingId
                justification: $justification
                treatment: $treatment
                assigned: $assigned
                vulnerabilityId: $acceptedVulnId
            ) {
                success
            }
            rejected: updateVulnerabilitiesTreatment (
                findingId: $findingId
                justification: $justification
                treatment: $treatment
                assigned: $assigned
                vulnerabilityId: $rejectedVulnId
            ) {
                success
            }
        }
    """
    vuln_ids = [
        "b16ed89e-668d-42d6-add1-73535bb0e083",
        "d212a841-7d48-4cb6-b776-cccc2845c383",
    ]
    assigned = "integratesuser@gmail.com"
    justification = "Test to consider permanently accepted treatment"
    variables: Dict[str, Any] = {
        "findingId": finding_id,
        "treatment": "ACCEPTED_UNDEFINED",
        "justification": justification,
        "assigned": assigned,
        "acceptedVulnId": vuln_ids[0],
        "rejectedVulnId": vuln_ids[1],
    }
    data = {"query": query, "variables": variables}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    vulns = await vulns_domain.get_by_finding_and_vuln_ids(
        loaders=loaders,
        finding_id=finding_id,
        vuln_ids=set(vuln_ids),
    )
    assert "errors" not in result
    assert result["data"]["accepted"]["success"]
    assert result["data"]["rejected"]["success"]
    assert vulns[0].treatment.assigned == assigned
    assert (
        vulns[0].treatment.status
        == VulnerabilityTreatmentStatus.ACCEPTED_UNDEFINED
    )
    assert (
        vulns[0].treatment.acceptance_status
        == VulnerabilityAcceptanceStatus.SUBMITTED
    )

    result = await _get_result_async(data, user="integratesuser@gmail.com")
    assert "errors" in result
    assert result["errors"][0]["message"] == str(SameValues())

    query = """
        mutation handleVulnerabilitiesAcceptanceMutation(
            $findingId: String!
            $justification: String!
            $acceptedVulns: [String]!
            $rejectedVulns: [String]!
        ) {
            handleVulnerabilitiesAcceptance(
                findingId: $findingId
                justification: $justification
                acceptedVulnerabilities: $acceptedVulns
                rejectedVulnerabilities: $rejectedVulns
            ) {
                success
            }
        }
    """
    variables = {
        "findingId": finding_id,
        "justification": "Test justification handle acceptance vulns",
        "acceptedVulns": [vuln_ids[0]],
        "rejectedVulns": [vuln_ids[1]],
    }
    data = {"query": query, "variables": variables}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    loaders.finding_vulnerabilities.clear(finding_id)
    vulns = await vulns_domain.get_by_finding_and_vuln_ids(
        loaders=loaders,
        finding_id=finding_id,
        vuln_ids=set(vuln_ids),
    )
    assert "errors" not in result
    assert "success" in result["data"]["handleVulnerabilitiesAcceptance"]
    assert result["data"]["handleVulnerabilitiesAcceptance"]["success"]
    assert vulns[0].treatment.assigned == assigned
    assert (
        vulns[0].treatment.status
        == VulnerabilityTreatmentStatus.ACCEPTED_UNDEFINED
    )
    assert (
        vulns[0].treatment.acceptance_status
        == VulnerabilityAcceptanceStatus.APPROVED
    )
    assert (
        vulns[-1].treatment.status
        != VulnerabilityTreatmentStatus.ACCEPTED_UNDEFINED
    )
    loaders.vulnerability_historic_treatment.clear(vulns[-1].id)
    historic_treatment: Tuple[
        VulnerabilityTreatment, ...
    ] = await loaders.vulnerability_historic_treatment.load(vulns[-1].id)
    assert (
        historic_treatment[-2].acceptance_status
        == VulnerabilityAcceptanceStatus.REJECTED
    )
    assert await vulns_domain.send_treatment_change_mail(
        loaders=loaders,
        assigned=assigned,
        finding_id=finding_id,
        finding_title="dummy_title",
        group_name="unittesting",
        justification=justification,
        min_date=datetime_utils.get_now_minus_delta(days=1),
        modified_by="unittest@fluidattacks.com",
    )


async def test_vulnerability_verification() -> None:
    vuln1_id = "587c40de-09a0-4d85-a9f9-eaa46aa895d7"
    vuln2_id = "15375781-31f2-4953-ac77-f31134225747"
    expected_vuln1 = {
        "finding_id": "436992569",
        "UUID": vuln1_id,
        "vulnerability_type": "ports",
        "specific": "1111",
        # FP: local testing
        "where": "192.168.100.112",  # NOSONAR
        "cycles": 1,
        "last_requested_reattack_date": "2020-02-19 10:41:04",
        "efficacy": 0,
        "report_date": "2019-09-13 17:00:56",
        "last_reattack_date": None,
        "last_reattack_requester": "integratesuser@gmail.com",
    }
    expected_vuln2 = {
        "finding_id": "436992569",
        "UUID": vuln2_id,
        "vulnerability_type": "ports",
        "specific": "333",
        # FP: local testing
        "where": "192.168.100.101",  # NOSONAR
        "cycles": 1,
        "last_requested_reattack_date": "2020-02-18 10:41:04",
        "efficacy": 0,
        "report_date": "2019-09-13 08:17:41",
        "last_reattack_date": "2020-02-19 10:41:04",
        "last_reattack_requester": "integratesuser@gmail.com",
    }
    query = """
        query GetVulnInfo($vuln1Id: String!, $vuln2Id: String!) {
            vuln1: vulnerability(uuid: $vuln1Id) {
                ...VulnInfo
            }
            vuln2: vulnerability(uuid: $vuln2Id) {
                ...VulnInfo
            }
        }
        fragment VulnInfo on Vulnerability {
            findingId
            id
            vulnerabilityType
            specific
            where
            cycles
            lastRequestedReattackDate
            efficacy
            reportDate
            lastReattackDate
            lastReattackRequester
        }
    """
    variables = {"vuln1Id": vuln1_id, "vuln2Id": vuln2_id}
    data = {"query": query, "variables": variables}
    result = await _get_result_async(data)
    assert "errors" not in result

    assert result["data"]["vuln1"]["findingId"] == expected_vuln1["finding_id"]
    assert result["data"]["vuln1"]["where"] == expected_vuln1["where"]
    assert result["data"]["vuln1"]["id"] == expected_vuln1["UUID"]
    assert result["data"]["vuln1"]["specific"] == expected_vuln1["specific"]
    assert (
        result["data"]["vuln1"]["vulnerabilityType"]
        == expected_vuln1["vulnerability_type"]
    )
    assert result["data"]["vuln1"][
        "lastRequestedReattackDate"
    ] == expected_vuln1.get("last_requested_reattack_date")
    assert result["data"]["vuln1"][
        "lastReattackRequester"
    ] == expected_vuln1.get("last_reattack_requester")
    assert result["data"]["vuln1"]["cycles"] == expected_vuln1["cycles"]
    assert result["data"]["vuln1"]["efficacy"] == expected_vuln1["efficacy"]
    assert (
        result["data"]["vuln1"]["reportDate"] == expected_vuln1["report_date"]
    )
    assert (
        result["data"]["vuln1"]["lastReattackDate"]
        == expected_vuln1["last_reattack_date"]
    )

    assert result["data"]["vuln2"]["findingId"] == expected_vuln2["finding_id"]
    assert result["data"]["vuln2"]["where"] == expected_vuln2["where"]
    assert result["data"]["vuln2"]["id"] == expected_vuln2["UUID"]
    assert result["data"]["vuln2"]["specific"] == expected_vuln2["specific"]
    assert (
        result["data"]["vuln2"]["vulnerabilityType"]
        == expected_vuln2["vulnerability_type"]
    )
    assert result["data"]["vuln2"][
        "lastRequestedReattackDate"
    ] == expected_vuln2.get("last_requested_reattack_date")
    assert result["data"]["vuln2"][
        "lastReattackRequester"
    ] == expected_vuln2.get("last_reattack_requester")
    assert result["data"]["vuln2"]["cycles"] == expected_vuln2["cycles"]
    assert result["data"]["vuln2"]["efficacy"] == expected_vuln2["efficacy"]
    assert (
        result["data"]["vuln2"]["reportDate"] == expected_vuln2["report_date"]
    )
    assert (
        result["data"]["vuln2"]["lastReattackDate"]
        == expected_vuln2["last_reattack_date"]
    )
