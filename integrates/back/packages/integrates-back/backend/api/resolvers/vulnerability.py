import logging
import sys
from typing import List, Union, Any

# Third party libraries
from aioextensions import (
    in_thread,
)
from ariadne import convert_kwargs_to_snake_case
from mixpanel import Mixpanel
from graphql.type.definition import GraphQLResolveInfo

from backend.decorators import (
    concurrent_decorators,
    require_integrates,
    enforce_group_level_auth_async,
    require_login,
    require_finding_access,
)
from backend.domain.vulnerability import (
    get_vulnerabilities_file,
    request_verification,
    verify_vulnerabilities
)
from backend.exceptions import (
    ErrorUploadingFileS3
)
from backend.typing import (
    DownloadFilePayload as DownloadFilePayloadType,
    SimplePayload as SimplePayloadType,
)
from backend import util

from back import settings

from back.settings import LOGGING

logging.config.dictConfig(LOGGING)

# Constants
LOGGER = logging.getLogger(__name__)


@convert_kwargs_to_snake_case  # type: ignore
async def resolve_vulnerability_mutation(
        obj: Any,
        info: GraphQLResolveInfo,
        **parameters: Any
) -> Union[SimplePayloadType, DownloadFilePayloadType]:
    """Wrap vulnerability mutations."""
    field = util.camelcase_to_snakecase(info.field_name)
    resolver_func = getattr(sys.modules[__name__], f'_do_{field}')
    return await resolver_func(obj, info, **parameters)


@concurrent_decorators(
    require_login,
    enforce_group_level_auth_async,
    require_integrates,
    require_finding_access,
)
async def _do_request_verification_vuln(
        _: Any,
        info: GraphQLResolveInfo,
        finding_id: str,
        justification: str,
        vulnerabilities: List[str]) -> SimplePayloadType:
    """Resolve request_verification_vuln mutation."""
    user_info = await util.get_jwt_content(info.context)
    success = await request_verification(
        finding_id,
        user_info['user_email'],
        ' '.join(
            [user_info.get('first_name', ''), user_info.get('last_name', '')]
        ),
        justification,
        vulnerabilities
    )

    if success:
        finding_loader = info.context.loaders['finding']
        finding_data = await finding_loader.load(finding_id)
        project_name = finding_data['project_name']
        attrs_to_clean = {
            'historic': finding_id,
            'severity': finding_id,
            'tracking': finding_id,
            'state': finding_id,
            'remediated': finding_id,
            'verified': finding_id,
            'vuln': finding_id,
            'consult': finding_id,
            'comment': finding_id,
            'vul': project_name,
            'findings': project_name,
            'max*severity': project_name,
            'remediate': project_name,
            'total_treatment': project_name
        }
        to_clean = util.format_cache_keys_pattern(attrs_to_clean)
        util.queue_cache_invalidation(*to_clean)
        util.cloudwatch_log(
            info.context,
            ('Security: Verified a request '
             f'in finding_id: {finding_id}')  # pragma: no cover
        )
    return SimplePayloadType(success=success)


@concurrent_decorators(
    require_login,
    enforce_group_level_auth_async,
    require_integrates,
    require_finding_access,
)
async def _do_verify_request_vuln(
        _: Any,
        info: GraphQLResolveInfo,
        **parameters: Any) -> SimplePayloadType:
    """Resolve verify_request_vuln mutation."""
    finding_id = parameters.get('finding_id', '')
    user_info = await util.get_jwt_content(info.context)
    success = await verify_vulnerabilities(
        finding_id,
        user_info['user_email'],
        ' '.join(
            [user_info.get('first_name', ''), user_info.get('last_name', '')]
        ),
        info,
        parameters
    )
    if success:
        finding_loader = info.context.loaders['finding']
        finding_data = await finding_loader.load(finding_id)
        project_name = finding_data['project_name']
        attrs_to_clean = {
            'historic': finding_id,
            'severity': finding_id,
            'tracking': finding_id,
            'state': finding_id,
            'remediated': finding_id,
            'verified': finding_id,
            'vuln': finding_id,
            'consult': finding_id,
            'comment': finding_id,
            'vul': project_name,
            'findings': project_name,
            'max*severity': project_name,
            'remediate': project_name,
            'total_treatment': project_name
        }
        to_clean = util.format_cache_keys_pattern(attrs_to_clean)
        util.queue_cache_invalidation(*to_clean)
        util.cloudwatch_log(
            info.context,
            ('Security: Verified a request '
             f'in finding_id: {finding_id}')  # pragma: no cover
        )
    return SimplePayloadType(success=success)


@concurrent_decorators(
    require_login,
    enforce_group_level_auth_async,
    require_integrates,
    require_finding_access,
)
async def _do_download_vuln_file(
        _: Any,
        info: GraphQLResolveInfo,
        **kwargs: Any) -> DownloadFilePayloadType:
    """Resolve download_vuln file mutation."""
    success = False
    finding_id = kwargs.get('finding_id', '')
    user_info = await util.get_jwt_content(info.context)
    user_email = user_info['user_email']
    finding_loader = info.context.loaders['finding']
    finding_data = await finding_loader.load(finding_id)
    project_name = finding_data['project_name']
    payload_data = {
        'finding_id': finding_id,
        'project_name': project_name,
        'user_email': user_email
    }

    try:
        file_path = await get_vulnerabilities_file(finding_id, project_name)
        if file_path:
            msg = (
                'Security: Downloaded vulnerabilities'
                f'file in finding {finding_id} successfully'
            )
            util.cloudwatch_log(info.context, msg)
            mp_obj = Mixpanel(settings.MIXPANEL_API_TOKEN)
            await in_thread(
                mp_obj.track,
                user_email,
                'DownloadVulnFile',
                {
                    'Project': project_name.upper(),
                    'Email': user_email,
                    'FileName': file_path,
                }
            )
            success = True
        else:
            msg = (
                'A CloudFront error occurred while getting '
                'the vuln file assotiated to finding in project'
            )
            LOGGER.error(msg, extra={'extra': payload_data})
    except ErrorUploadingFileS3:
        msg_cw = (
            f'Security: Attempted to download vulnerabilities file '
            f'assotiated to finding {finding_id} in project {project_name}'
        )
        util.cloudwatch_log(info.context, msg_cw)
        msg_log = (
            'An error occurred uploading a vuln file to S3 '
            'assotiated to finding in project'
        )
        LOGGER.error(msg_log, extra={'extra': payload_data})

    return DownloadFilePayloadType(success=success, url=str(file_path))
