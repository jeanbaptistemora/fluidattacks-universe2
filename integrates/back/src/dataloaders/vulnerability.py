# pylint: disable=method-hidden
from aiodataloader import (
    DataLoader,
)
from aioextensions import (
    collect,
)
from custom_types import (
    Historic as HistoricType,
)
from db_model.enums import (
    Source,
)
from db_model.vulnerabilities.enums import (
    VulnerabilityAcceptanceStatus,
    VulnerabilityDeletionJustification,
    VulnerabilityStateStatus,
    VulnerabilityTreatmentStatus,
    VulnerabilityType,
    VulnerabilityVerificationStatus,
    VulnerabilityZeroRiskStatus,
)
from db_model.vulnerabilities.types import (
    Vulnerability,
    VulnerabilityState,
    VulnerabilityTreatment,
    VulnerabilityVerification,
    VulnerabilityZeroRisk,
)
from newutils.requests import (
    map_source,
)
from typing import (
    Any,
    cast,
    Dict,
    List,
    Optional,
    Tuple,
)
from vulnerabilities import (
    domain as vulns_domain,
)


async def _batch_load_fn(vuln_uuids: List[str]) -> List[Dict[str, Any]]:
    loaded_vulns: List[Dict[str, Any]] = []

    vulnerabilities = await collect(tuple(map(vulns_domain.get, vuln_uuids)))
    for vuln in vulnerabilities:
        # Compatibility with old API
        history: HistoricType = cast(HistoricType, vuln["historic_state"])
        source: str = map_source(history[0]["source"])
        loaded_vulns.append(
            dict(
                analyst=cast(
                    str,
                    cast(HistoricType, vuln.get("historic_state", [{}]))[
                        -1
                    ].get("analyst", ""),
                ),
                commit_hash=str(vuln.get("commit_hash", "")),
                current_state=cast(
                    str,
                    cast(HistoricType, vuln.get("historic_state", [{}]))[
                        -1
                    ].get("state", ""),
                ),
                cycles=str(vulns_domain.get_reattack_cycles(vuln)),
                efficacy=str(vulns_domain.get_efficacy(vuln)),
                external_bts=cast(str, vuln.get("external_bts", "")),
                finding_id=cast(str, vuln.get("finding_id", "")),
                historic_state=cast(
                    HistoricType, vuln.get("historic_state", [{}])
                ),
                historic_treatment=cast(
                    HistoricType, vuln.get("historic_treatment", [])
                ),
                historic_verification=cast(
                    HistoricType, vuln.get("historic_verification", [])
                ),
                historic_zero_risk=cast(
                    HistoricType, vuln.get("historic_zero_risk", [{}])
                ),
                id=cast(str, vuln.get("UUID", "")),
                last_reattack_date=vulns_domain.get_last_reattack_date(vuln),
                last_requested_reattack_date=(
                    vulns_domain.get_last_requested_reattack_date(vuln)
                ),
                remediated=cast(
                    HistoricType, vuln.get("historic_verification", [{}])
                )[-1].get("status")
                == "REQUESTED",
                report_date=cast(HistoricType, vuln["historic_state"])[0][
                    "date"
                ],
                severity=cast(str, vuln.get("severity", "")),
                source=source,
                specific=cast(str, vuln.get("specific", "")),
                stream=str(vuln.get("stream", "")).replace(",", " > "),
                tag=", ".join(sorted(cast(List[str], vuln.get("tag", "")))),
                tags=sorted(cast(List[str], vuln.get("tag", []))),
                verification=cast(
                    HistoricType, vuln.get("historic_verification", [{}])
                )[-1]
                .get("status", "")
                .capitalize(),
                vuln_type=cast(str, vuln.get("vuln_type", "")),
                vulnerability_type=cast(str, vuln.get("vuln_type", "")),
                where=cast(str, vuln.get("where", "")),
                zero_risk=cast(
                    HistoricType, vuln.get("historic_zero_risk", [{}])
                )[-1]
                .get("status", "")
                .capitalize(),
            )
        )
    return loaded_vulns


class VulnerabilityLoader(DataLoader):
    # pylint: disable=no-self-use
    async def batch_load_fn(
        self, vuln_uuids: List[str]
    ) -> List[Dict[str, Any]]:
        return await _batch_load_fn(vuln_uuids)


async def _get_vulnerability(vulnerability_id: str) -> Vulnerability:
    item: Dict[str, Any] = await vulns_domain.get(vulnerability_id)
    first_state: Dict[str, str] = item["historic_state"][0]
    current_state: Dict[str, str] = item["historic_state"][-1]
    current_treatment: Dict[str, str] = item["historic_treatment"][-1]
    current_verification: Optional[Dict[str, str]] = (
        item["historic_verification"][-1]
        if "historic_verification" in item
        else None
    )
    current_zero_risk: Optional[Dict[str, str]] = (
        item["historic_zero_risk"][-1]
        if "historic_zero_risk" in item
        else None
    )

    return Vulnerability(
        finding_id=item["finding_id"],
        id=item["UUID"],
        specific=item["specific"],
        state=VulnerabilityState(
            modified_by=current_state["analyst"],
            modified_date=current_state["date"],
            source=Source[map_source(first_state["source"]).upper()],
            status=VulnerabilityStateStatus[current_state["state"].upper()],
            justification=(
                VulnerabilityDeletionJustification[
                    current_state["justification"]
                ]
                if "justification" in current_state
                else None
            ),
        ),
        treatment=(
            None
            if current_treatment["treatment"].upper() == "NEW"
            else VulnerabilityTreatment(
                modified_by=current_treatment["user"],
                modified_date=current_treatment["date"],
                status=VulnerabilityTreatmentStatus(
                    current_treatment["treatment"].upper()
                ),
                accepted_until=current_treatment.get("acceptance_date"),
                acceptance_status=(
                    VulnerabilityAcceptanceStatus[
                        current_treatment["acceptance_status"]
                    ]
                    if "acceptance_status" in current_treatment
                    else None
                ),
                justification=current_treatment.get("justification"),
                manager=current_treatment.get("treatment_manager"),
            )
        ),
        type=VulnerabilityType(item["vuln_type"].upper()),
        where=item["where"],
        bug_tracking_system_url=item.get("external_bts"),
        commit=item.get("commit_hash"),
        custom_severity=int(item["severity"]) if "severity" in item else None,
        hash=None,
        repo=None,
        stream=item["stream"].split(",") if "stream" in item else None,
        tags=item.get("tag"),
        verification=(
            VulnerabilityVerification(
                comment_id="",
                modified_by="",
                modified_date=current_verification["date"],
                status=VulnerabilityVerificationStatus(
                    current_verification["status"]
                ),
            )
            if current_verification
            else None
        ),
        zero_risk=(
            VulnerabilityZeroRisk(
                comment_id=current_zero_risk["comment_id"],
                modified_by=current_zero_risk["email"],
                modified_date=current_zero_risk["date"],
                status=VulnerabilityZeroRiskStatus(
                    current_zero_risk["status"]
                ),
            )
            if current_zero_risk
            else None
        ),
    )


class VulnerabilityNewLoader(DataLoader):
    # pylint: disable=no-self-use,method-hidden
    async def batch_load_fn(
        self, vulnerability_ids: List[str]
    ) -> Tuple[Vulnerability, ...]:
        return await collect(tuple(map(_get_vulnerability, vulnerability_ids)))
