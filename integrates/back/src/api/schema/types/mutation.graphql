"Main mutation object"
type Mutation {
  "Whether to keep showing the legal notice modal or not"
  acceptLegal(
    "If set to true, ASM will stop showing the legal notice upon a new login"
    remember: Boolean
  ): SimplePayload!

  "Acknowledges termination of concurrent session"
  acknowledgeConcurrentSession: SimplePayload!

  "Activate a root and make its content available for security analyses"
  activateRoot(
    "Name of the group the root is associated with"
    groupName: String!
    "ID of the root"
    id: ID!
  ): SimplePayload!

  "Adds a new draft Finding to the specified Group"
  addDraft(
    """Measure of the effort and resources needed for an attacker to put
    in to successfully breach the system"""
    attackComplexity: String
    "Level of access needed for an attack to succeed"
    attackVector: String
    "Project or application that contains the vulnerability"
    affectedSystems: String
    "Deprecated. Use `attackVectorDescription` instead"
    attackVectorDesc: String
    "Malicious actions that can be performed by exploiting the vulnerability"
    attackVectorDescription: String
    """Hypothetical impact on resource (webpages, content etc...) availability
    and possibility of service denial"""
    availabilityImpact: String
    """Measure of the sensible/restricted information (e.g. password,
    encryption keys) the attacker could gather from the breached component"""
    confidentialityImpact: String
    "Brief explanation of the vulnerability and how it works"
    description: String
    """Measure of the availability of resources and details, both theoretical
    and practical, available for a malicious actor to build and/or automate an
    attack"""
    exploitability: String
    "Name of the Group where the new draft will be in"
    groupName: String!
    """How vulnerable for malicious modification are the files in the impacted
    components"""
    integrityImpact: String
    "Privileges required by the attacker to exploit the vulnerabilities"
    privilegesRequired: String
    "Recommended course of action to close the vulnerabilities"
    recommendation: String
    "Availability of a fix"
    remediationLevel: String
    "Report Confidence"
    reportConfidence: String
    "Rules that are broken and lead to the existence of the vulnerability"
    requirements: String
    "Security scope of the affected resources by the exploited vulnerabilities"
    severityScope: String
    "Actor and scenery where the vulnerability can be exploited"
    threat: String
    "Finding number and name"
    title: String!
    "User involvement needed for a successful attack"
    userInteraction: String
  ): SimplePayload!

  "Reports a blocking event"
  addEvent(
    "What the hacker did after the event happened"
    actionAfterBlocking: ActionsAfterBlocking!
    "What the hacker was doing just before the event happened"
    actionBeforeBlocking: ActionsBeforeBlocking!
    "Where the event was present"
    accessibility: [EventAccessibility]!
    "Components involved or affected by the event, if applicable"
    affectedComponents: [AffectedComponents]
    "Amount of time the hacker was blocked by the event, if applicable"
    blockingHours: String
    "Where the hacker physically was when the event happened"
    context: EventContext!
    "Comment laying out or explaining the event"
    detail: String!
    "DateTime of the event in the format `yyyy-MM-ddThh:mm:ssZ`"
    eventDate: DateTime!
    "The kind of event that happened"
    eventType: EventType!
    "Evidence file of the event"
    file: Upload
    "Name of the group linked to the event"
    groupName: String!
    "Evidence image of the event"
    image: Upload
  ): SimplePayload!

  "Adds a consult/comment to an Event"
  addEventConsult(
    "Content of the comment itself"
    content: String!
    "Identifier of the Event to comment about"
    eventId: String!
    "Identifier of the comment it is replying to. 0 otherwise"
    parent: GenericScalar!
  ): AddConsultPayload!

  "Adds files to a Group's scope view"
  addFilesToDb(
    "A JSON with description and fileName keys"
    filesData: JSONString!
    "Name of the Group to add the File to"
    groupName: String
  ): SimplePayload!

  "Adds a consult/comment in a Finding"
  addFindingConsult(
    "Content of the comment/consult"
    content: String!
    "Identifier of the Finding to be commented"
    findingId: String!
    "Identifier of the comment it is replying to. 0 otherwise"
    parent: GenericScalar!
    "Type of the comment to be added"
    type: FindingConsultType!
  ): AddConsultPayload!

  "Adds a new Forces execution results and log to a Group"
  addForcesExecution(
    "Deprecated. Use `groupName` instead"
    projectName: String
    "Identifier of the Forces execution"
    executionId: String
    "Deprecated. Use `executionId` instead"
    execution_id: String
    "DateTime in the format yyyy-MM-ddThh:mm:ssZ"
    date: DateTime!
    "Exit code of the execution"
    exitCode: String!
    "Tested repo branch"
    gitBranch: String
    "Full SHA-1 hash of the tested commit"
    gitCommit: String
    "Repo URL"
    gitOrigin: String
    "Root nickname"
    gitRepo: String
    "Name of the Group where the Forces log will be in"
    groupName: String
    "Applied kind of application security testing technique"
    kind: String
    "Forces execution log"
    log: Upload
    "Strict mode, if enabled, forces the fix of security issues"
    strictness: String!
    "Object containing arrays of accepted, open and closed vulnerabilities"
    vulnerabilities: ExecutionVulnerabilitiesInput!
  ): SimplePayload!

  """Adds a new root to be analyzed and tested"""
  addGitRoot(
    "Repository branch to be tested"
    branch: String!
    "Kind of environment to test. E.g. production, QA, etc."
    environment: String!
    "Repository paths to be ignored"
    gitignore: [String!]!
    "Name of the group the root is associated with"
    groupName: String!
    "Analyze already existing code"
    includesHealthCheck: Boolean!
    "Nickname of the repository"
    nickname: String
    "Repository URL"
    url: String!
  ): SimplePayload!

  "Adds a new group to the specified organization"
  addGroup(
    "Brief description to identify the group"
    description: String!
    "Name of the new group"
    groupName: String!
    "Enables the Machine plan within the new group"
    hasMachine: Boolean
    "Enables the Squad plan within the new group"
    hasSquad: Boolean
    "Language in which findings should be reported"
    language: Language
    "Organization to which the group will belong"
    organization: String
    "Enables either Black or White box type of hacking service"
    service: ServiceType
    "Enables either continuous or one-shot hacking within the group"
    subscription: SubscriptionType
  ): SimplePayload!

  "Adds a consult/comment to the Consulting tab of the group"
  addGroupConsult(
    "The content of the comment"
    content: String!
    "Name of the group where the comment will be made"
    groupName: String!
    "Identifier of the parent comment it is replying to"
    parent: GenericScalar!
  ): AddConsultPayload!

  "Adds the specified tags to the group"
  addGroupTags(
    "Name of the group where the tags will be added"
    groupName: String!
    "Tags to add in list format with the tags enclosed in quotes"
    tags: JSONString
  ): SimpleGroupPayload!

  "Adds an IP to the Group roots"
  addIpRoot(
    "IP address of the environment to test"
    address: String!
    "Name of the group the root is associated with"
    groupName: String!
    "Nickname of the root"
    nickname: String!
    "Indicates the port to test. Zero means all ports"
    port: Int!
  ): SimplePayload!

  "Adds a new Organization"
  addOrganization(
    "Name of the new Organization. Must come from an Internal Names whitelist"
    name: String!
  ): AddOrganizationPayload!

  """Adds a Finding policy to the Organization. Approval is still needed for
  enactment"""
  addOrganizationFindingPolicy(
    "Name of the Finding to be associated with the policy"
    findingName: String!
    "Name of the Organization relevant to the finding policy"
    organizationName: String!
    "Tags that will be related to this finding policy"
    tags: [String]
  ): SimplePayload!

  "Authenticates an user from the mobile ASM app"
  addPushToken(
    "Expo login token to be added"
    token: String!
  ): SimplePayload

  "Adds a new Stakeholder to the default ASM organization"
  addStakeholder(
    "Email address of the new stakeholder"
    email: String!
    "Role of the stakeholder"
    role: StakeholderRole!
    "Phone number of the stakeholder preceded by its call sign"
    phoneNumber: String
  ): AddStakeholderPayload!

  "Adds the URL of the environment to be tested"
  addUrlRoot(
    "URL of the environment to test"
    url: String!
    "Name of the group the root is associated with"
    groupName: String!
    "Nickname of the root"
    nickname: String!
  ): SimplePayload!

  "Approves the specified draft finding"
  approveDraft(
    "Identifier of the draft to approve"
    draftId: String!
  ): ApproveDraftPayload!

  "Confirms the provided vulnerabilities as zero risk"
  confirmVulnerabilitiesZeroRisk(
    "Identifier of the Finding to be commented"
    findingId: String!
    "Justification of the confirmed zero risks"
    justification: String!
    "Vulnerabilities to confirm"
    vulnerabilities: [String]!
  ): SimplePayload!

  "Disables the specified Finding policy"
  deactivateOrganizationFindingPolicy(
    "ID of the policy"
    findingPolicyId: ID!
    "Name of the organization the finding policy is associated with"
    organizationName: String!
  ): SimplePayload!

  "Deactivates a Group root, which stops further testing of it"
  deactivateRoot(
    "Name of the group the root is associated with"
    groupName: String!
    "ID of the root"
    id: ID!
    "Custom reason provided"
    other: String
    "Reason for this change"
    reason: RootDeactivationReason!
  ): SimplePayload!

  "Downloads an evidence file associated with an Event"
  downloadEventFile(
    "Identifier of the Event containing the evidence"
    eventId: String!
    "Filename of the evidence to download"
    fileName: String!
  ): DownloadFilePayload!

  "Downloads a file hosted on a Group"
  downloadFile(
    "Name of the file to download in String form"
    filesData: JSONString!
    "Deprecated. Use `groupName` instead"
    projectName: String
    "Name of the Group containing the file in its Scope view"
    groupName: String
  ): DownloadFilePayload!

  "Downloads a yaml file with all the vulnerabilities of this finding"
  downloadVulnerabilityFile(
    "Identifier of the finding associated with the vulnerabilities"
    findingId: String!
  ): DownloadFilePayload!

  "Grants a stakeholder access to a Group"
  grantStakeholderAccess(
    "Deprecated. Use `groupName` instead"
    projectName: String
    "Name of the Group"
    groupName: String
    "Email address of the stakeholder that will be granted access"
    email: String!
    "Responsibility of the stakeholder e.g. Product Owner, Group Manager etc.."
    responsibility: String
    "Role of the stakeholder"
    role: StakeholderRole!
    "Phone number of the stakeholder preceded by its call sign"
    phoneNumber: String
  ): GrantStakeholderAccessPayload!

  "Grants a stakeholder access to an Organization"
  grantStakeholderOrganizationAccess(
    "Identifier of the Organization"
    organizationId: String!
    "Phone number of the stakeholder preceded by its call sign"
    phoneNumber: String
    "Role of the stakeholder"
    role: OrganizationRole!
    "Email address of the stakeholder that will be granted access"
    userEmail: String!
  ): GrantStakeholderAccessPayload!

  "Handles submission, acceptation or rejection of a Finding policy"
  handleOrganizationFindingPolicyAcceptation(
    "ID of the policy"
    findingPolicyId: ID!
    "Name of the organization the finding policy is associated with"
    organizationName: String!
    "Whether the finding policy is approved or rejected"
    status: OrganizationFindingPolicy!
  ): SimplePayload!

  "Handles acceptation and rejection of Vulnerabilities"
   handleVulnerabilitiesAcceptation(
    "List of identifiers of the vulnerabilities to be accepted"
    acceptedVulnerabilities: [String]!
    "Identifier of the Finding that contains the vulnerabilities"
    findingId: String!
    "Justification of the acceptances and rejections"
    justification: String!
    "List of identifiers of the vulnerabilities to be rejected"
    rejectedVulnerabilities: [String]!
  ): SimplePayload!

  "Revokes the current user's API access token"
  invalidateAccessToken: SimplePayload!

  "Ditches a section of the cache and forces a refresh"
  invalidateCache(
    "Cache pattern to ditch"
    pattern: String!
  ): SimplePayload!

  "Moves a root and its associations to another group"
  moveRoot(
    "Name of the source group"
    groupName: String!
    "ID of the source root"
    id: ID!
    "Name of the target group"
    targetGroup: String!
  ): SimplePayload!

  "Rejects a drafted Finding"
  rejectDraft(
    "Identifier of the draft Finding to be rejected"
    findingId: String!
  ): SimplePayload!

  "Rejects the provided vulnerabilities from being considered as zero risk"
  rejectVulnerabilitiesZeroRisk(
    "Identifier of Finding containing the vulnerabilities"
    findingId: String!
    "Justification for the rejection"
    justification: String!
    "List of rejected Vulnerabilities"
    vulnerabilities: [String]!
  ): SimplePayload!

  "Removes evidence from an Event"
  removeEventEvidence(
    "Identifier of the event to which the Evidence belongs"
    eventId: String!
    "Type of the Evidence to remove"
    evidenceType: EventEvidenceType!
  ): SimplePayload!

  "Removes evidence from a Finding"
  removeEvidence(
    "Identifier of the finding to which the Evidence belongs"
    findingId: String!
    "Type identifier of the Evidence to remove"
    evidenceId: EvidenceType!
  ): SimpleFindingPayload!

  "Removes Files from a Group"
  removeFiles(
    "Data of the file to remove in the format {`fileName`:`file.ext`}"
    filesData: JSONString!
    "Deprecated. Use `groupName` instead"
    projectName: String
    "Name of the group where the File to remove is"
    groupName: String
  ): SimplePayload!

  "Removes/deletes a Finding from a Group"
  removeFinding(
    "Identifier of the Finding to remove"
    findingId: String!
    "Justification of the removal"
    justification: RemoveFindingJustification!
  ): SimplePayload!

  """Removes/deletes a group from ASM. Once successful this action cannot be
  undone"""
  removeGroup(
    "Name of the group to be deleted"
    groupName: String!
    "Reason for the removal of the group"
    reason: String
  ): SimplePayload!

  "Removes/deletes the specified tag from the group"
  removeGroupTag(
    "Name of the group where the tag should be removed from"
    groupName: String!
    "Tag to remove"
    tag: String!
  ): SimpleGroupPayload!

  "Removes a stakeholder's access from a Group"
  removeStakeholderAccess(
    "Deprecated. Use `groupName` instead"
    projectName: String
    "Name of the group where the stakeholder should be removed from"
    groupName: String
    "Email address of the stakeholder to remove"
    userEmail: String!
  ): RemoveStakeholderAccessPayload!

  "Removes a stakeholder's access from an Organization"
  removeStakeholderOrganizationAccess(
    """Identifier of the organization where the stakeholder should be removed
    from"""
    organizationId: String!
    "Email address of the stakeholder to remove"
    userEmail: String!
  ): SimplePayload!

  "Removes tags from vulnerabilities"
  removeTags(
    "Identifier of the finding containing the vulnerabilities"
    findingId: String!
    """List of identifiers of the vulnerabilities where the tag should be
    removed from"""
    vulnerabilities: [String]!
    "Tag to remove"
    tag: String
  ): SimplePayload!

  "Removes/deletes a vulnerability within a finding"
  removeVulnerability(
    "Identifier of the vulnerability to remove"
    id: String!
    "Finding where the vulnerability is located"
    findingId: String!
    "Justification for the removal"
    justification: RemoveVulnerabilityJustification!
  ): SimplePayload!

  "Requests a reattack on the provided Vulnerabilities"
  requestVulnerabilitiesVerification(
    "Identifier of Finding containing the vulnerabilities"
    findingId: String!
    "Justification for the request"
    justification: String!
    "List of Vulnerabilities to be reattacked"
    vulnerabilities: [String]!
  ): SimplePayload!

  "Requests a zero risk on the provided Vulnerabilities"
  requestVulnerabilitiesZeroRisk(
    "Identifier of Finding containing the vulnerabilities"
    findingId: String!
    "Justification for the zero risk request"
    justification: String!
    "List of Vulnerabilities to be requested for a zero risk"
    vulnerabilities: [String]!
  ): SimplePayload!

  "Signs an user in"
  signIn(
    "OAuth token"
    authToken: String!,
    "OAuth provider"
    provider: AuthProvider!
  ): SignInPayload!

  "Signs a POST URL to upload files to a Group's resources bucket"
  signPostUrl(
    "A JSON with description and fileName keys"
    filesData: JSONString!
    "Name of the Group to add the File to"
    groupName: String
  ): SignPostUrlsPayload!

  "Marks an ongoing Event within the group as solved"
  solveEvent(
    "Identifier of the Event to solve"
    eventId: String!
    "Time spent solving the Event, in hours"
    affectation: String!
    "Datetime of solving of the Event, in the format yyyy-MM-ddThh:mm:ssZ"
    date: DateTime!
  ): SimplePayload!

  "Submits a draft Finding submission for approval"
  submitDraft(
    "Identifier of the draft Finding to be submitted"
    findingId: String!
  ): SimplePayload!

  "Queues a job to execute Machine (Skims) on the provided root"
  submitMachineJob(
    """Identifier of the Finding where the results should be reported. Also
    sets the Vulnerability type to check for"""
    findingId: String!
    "Nickname of the root to run Machine on"
    rootNickname: String!
  ): SimplePayload!

  """Submits a Finding policy for the Organization, pending approval of a
  Stakeholder"""
  submitOrganizationFindingPolicy(
    "ID of the policy"
    findingPolicyId: ID!
    "Name of the organization the finding policy will be associated with"
    organizationName: String!
  ): SimplePayload!

  "Subscribes the user to periodic mails about an Entity"
  subscribeToEntityReport(
    "Desired frequency of the report"
    frequency: Frequency!
    "Type of Entity to report about"
    reportEntity: SubscriptionReportEntity!
    "Identifier of the Entity to report about"
    reportSubject: String!
  ): SimplePayload!

  "Revoke your access permissions to a group"
  unsubscribeFromGroup(
    "Name of the group to be removed from"
    groupName: String!
  ): SimplePayload!

  "Generates an access token for the API"
  updateAccessToken(
    "An unix timestamp within the near future (< 6 months from now)"
    expirationTime: Int!
  ): UpdateAccessTokenPayload!

  "Updates a Finding's description"
  updateDescription(
    "Project or application that contains the vulnerability"
    affectedSystems: String!
    "Deprecated. Use `attackVectorDescription` instead"
    attackVectorDesc: String
    "Malicious actions that can be performed by exploiting the vulnerability"
    attackVectorDescription: String
    "Brief explanation of the vulnerability and how it works"
    description: String!
    "Identifier of Finding whose description will be updated"
    findingId: String!
    "Recommended course of action to close the vulnerabilities"
    recommendation: String!
    """Information that will be compromised or disclosed by exploiting the
    vulnerability"""
    records: String
    "Number of compromised records"
    recordsNumber: Int!
    "Did Sorts guide you to the file where the vulnerability was found?"
    sorts: Sorts
    "Actor and scenery where the vulnerability can be exploited"
    threat: String!
    "Finding number and name"
    title: String!
  ): SimpleFindingPayload!

  "Updates an Event's evidence"
  updateEventEvidence(
    "Identifier of the Event whose evidence will be modified"
    eventId: String!
    "Evidence type to update"
    evidenceType: EventEvidenceType!
    "Evidence file to upload"
    file: Upload!
  ): SimplePayload!

  "Updates a Finding's evidence"
  updateEvidence(
    "Evidence file to upload"
    file: Upload!
    "Identifier of the Finding whose evidence will be modified"
    findingId: String!
    "Type identifier of the evidence to replace or upload"
    evidenceId: EvidenceType!
  ): SimplePayload!

  "Updates the description of an Evidence in a Finding"
  updateEvidenceDescription(
    "New description of the Evidence"
    description: String!
    "Identifier of the Evidence to be updated"
    evidenceId: EvidenceDescriptionType!
    "Identifier of the Finding associated with the Evidence"
    findingId: String!
  ): SimplePayload!

  "Updates the Forces token in use for a Group"
  updateForcesAccessToken(
    "Deprecated. Use `groupName` instead"
    projectName: String
    "Name of the Group whose token is to be updated"
    groupName: String
  ): UpdateAccessTokenPayload!

  "Updates a Group's Git environment URLs"
  updateGitEnvironments(
    "Name of the group the root is associated with"
    groupName: String!
    "ID of the root"
    id: ID!
    "URLs to access the environment"
    environmentUrls: [String!]!
  ): SimplePayload!

  "Updates a Group's Git root and its attributes"
  updateGitRoot(
    "Repository branch to be tested"
    branch: String!
    "Kind of environment to test. E.g. Production, QA, Dev, etc..."
    environment: String!
    "Repository paths to be ignored"
    gitignore: [String!]!
    "Name of the group the root is associated with"
    groupName: String!
    "ID of the root"
    id: ID!
    "Analyze already existing code"
    includesHealthCheck: Boolean!
    "Nickname of the repository"
    nickname: String
    "Repository URL"
    url: String!
  ): SimplePayload!

  "Updates a group's services and parameters"
  updateGroup(
    "Observations about the group update"
    comments: String!
    "Description of the group"
    description: String
    "Name of the group to be updated"
    groupName: String!
    """Whether to keep using ASM services. Caution: Setting this to False
    **will** remove the group from it!"""
    hasAsm: Boolean!
    "Whether to keep the Machine plan enabled within the group"
    hasMachine: Boolean!
    "Whether to keep the Squad plan enabled within the group"
    hasSquad: Boolean!
    "Language of the group"
    language: String
    "Reason for the downgrade in services if applicable"
    reason: UpdateGroupReason!
    "Enables either Black or White box type of hacking service"
    service: ServiceType
    "Enables either continuous or one-shot hacking within the group"
    subscription: SubscriptionType!
  ): SimplePayload!

  "Updates/edits an user belonging to a group"
  updateGroupStakeholder(
    "Name of the group to which the user to be updated belongs"
    groupName: String!
    "Email of the user to update"
    email: String!
    "Responsibility of the stakeholder e.g. Product Owner, Group Manager etc.."
    responsibility: String!
    "Role of the user within the group"
    role: StakeholderRole!
    "Phone number of the user preceded by its call sign"
    phoneNumber: String!
  ): UpdateStakeholderPayload!

  "Updates the Organization's common policies"
  updateOrganizationPolicies(
    "Maximum number of calendar days a finding can be temporally accepted"
    maxAcceptanceDays: Int
    "Maximum CVSS 3.1 score in which a finding can be temporally accepted"
    maxAcceptanceSeverity: Float
    "Maximum number of times a finding can be temporally accepted"
    maxNumberAcceptations: Int
    "Minimum CVSS 3.1 score in which a finding can be temporally accepted"
    minAcceptanceSeverity: Float
    "Identifier of the Organization whose policies are to be updated"
    organizationId: String!
    "Name of the Organization whose policies are to be updated"
    organizationName: String!
  ): SimplePayload!

  "Updates an stakeholder's data from an Organization"
  updateOrganizationStakeholder(
    "Identifier of the Organization to which the stakeholder belongs"
    organizationId: String!
    "Stakeholder's phone number preceded by its call sign"
    phoneNumber: String
    "Stakeholder role"
    role: OrganizationRole!
    "Email address of the stakeholder to be updated"
    userEmail: String!
  ): UpdateStakeholderPayload!

  "Updates the Root cloning status"
  updateRootCloningStatus(
    "Name of the group the root is associated with"
    groupName: String!
    "ID of the root"
    id: ID!
    "Whether the root is cloning or not"
    status: CloningStatus!
    "Message when cloning is finished"
    message: String!
  ): SimplePayload!

  "Updates the severity of a Finding"
  updateSeverity(
    "Identifier of the finding in which the new severity will be calculated"
    findingId: String!
    """Measure of the effort and resources needed for an attacker to put
    in to successfully breach the system"""
    attackComplexity: String!
    "Level of access needed for an attack to succeed"
    attackVector: String!
    """Hypothetical impact on resource (webpages, content etc...) availability
    and possibility of service denial"""
    availabilityImpact: String!
    "Availability requirement for the impacted systems"
    availabilityRequirement: String!
    """Measure of the sensible/restricted information (e.g. password,
    encryption keys) the attacker could gather from the breached component"""
    confidentialityImpact: String!
    "Confidentiality requirement for the impacted systems"
    confidentialityRequirement: String!
    "Common Vulnerability Scoring System version"
    cvssVersion: String!
    """Measure of the availability of resources and details, both theoretical
    and practical, available for a malicious actor to build and/or automate an
    attack"""
    exploitability: String!
    """How vulnerable for malicious modification are the files in the impacted
    components"""
    integrityImpact: String!
    "Integrity requirement for the impacted systems"
    integrityRequirement: String!
    "Modified Attack Complexity"
    modifiedAttackComplexity: String!
    "Modified Attack Vector"
    modifiedAttackVector: String!
    "Modified Availability Impact"
    modifiedAvailabilityImpact: String!
    "Modified Confidentiality Impact"
    modifiedConfidentialityImpact: String!
    "Modified Integrity Impact"
    modifiedIntegrityImpact: String!
    "Modified Privileges Required"
    modifiedPrivilegesRequired: String!
    "Modified Scope"
    modifiedSeverityScope: String!
    "Modified User Interaction"
    modifiedUserInteraction: String!
    "Privileges required by the attacker to exploit the vulnerabilities"
    privilegesRequired: String!
    "Availability of a fix"
    remediationLevel: String!
    "Report Confidence"
    reportConfidence: String!
    "CVSS 3.1 score"
    severity: String
    "Security scope of the affected resources by the exploited vulnerabilities"
    severityScope: String!
    "User involvement needed for a successful attack"
    userInteraction: String!
  ): SimpleFindingPayload!

  """Updates the sorts_risk_level attribute in one or more ToEs of a concrete
  group"""
  updateToeLinesSorts(
    "Where source code has been reviewed by Sorts"
    filename: String,
    "Name of the Group containing the ToE lines to be updated"
    groupName: String,
    "Risk level of the reviewed lines assigned by Sorts"
    sortsRiskLevel: Int
  ): SimplePayload!

  "Updates the treatment of a single Vulnerability"
  updateVulnerabilitiesTreatment(
    "Temporarily accepted until"
    acceptanceDate: String
    "Identifier of the Finding that contains the Vulnerability to update"
    findingId: String!
    "Justification for the updated treatment"
    justification: String!
    "New designated treatment for the Vulnerability"
    treatment: UpdateClientDescriptionTreatment!
    "Email address of the user who is updating the treatment"
    treatmentManager: String
    "Identifier of the Vulnerability to update"
    vulnerabilityId: ID!
  ): SimplePayload!

  "Updates Vulnerability commit data"
  updateVulnerabilityCommit(
    "Full SHA-1 hash of the commit where the Vulnerability was found"
    vulnerabilityCommit: String!
    "Identifier of the Vulnerability to update"
    vulnerabilityId: String!
    "General location of the Vulnerability, can be a file, an URL or an IP"
    vulnerabilityWhere: String!
    """Specific location of the Vulnerability, can be a line of code,
    a field or a port"""
    vulnerabilitySpecific: String!
  ): SimplePayload!

  "Updates data related to the treatment of a Vulnerability"
  updateVulnerabilityTreatment(
    "Deprecated. Use `externalBugTrackingSystem` instead."
    externalBts: String
    "External Bug Tracking System URL"
    externalBugTrackingSystem: String
    "Identifier of the Finding that contains the vulnerability to update"
    findingId: String!
    "CVSS 3.1 score"
    severity: Int
    "Tags associated with the update, each separated by commas"
    tag: String
    "Identifier of the Vulnerability to update"
    vulnerabilityId: ID!
  ): SimplePayload!

  "Uploads a file describing a Vulnerability to a Finding"
  uploadFile(
    "YAML file describing a Vulnerability"
    file: Upload!
    "Identifier of the Finding to be associated with the new Vulnerability"
    findingId: String!
  ): SimplePayload!

  "To verify if the vulnerabilities still remain open or were closed"
  verifyVulnerabilitiesRequest(
    "Identifier of the Finding that contains the vulnerabilities to verify"
    findingId: String!
    "Justification for the open and closed vulnerabilities"
    justification: String!
    "List of vulnerabilities that still remain open"
    openVulnerabilities: [String]!
    "List of vulnerabilities that were confirmed closed"
    closedVulnerabilities: [String]!
  ): SimplePayload!
}
