# pylint: disable=too-many-lines
from api.schema import (
    SCHEMA,
)
from ariadne import (
    graphql,
)
from back.tests.unit import (
    MIGRATION,
)
from back.tests.unit.utils import (
    create_dummy_session,
)
from comments import (
    domain as comments_domain,
)
from custom_exceptions import (
    AcceptationNotRequested,
    InvalidNewVulnState,
    InvalidSchema,
    InvalidStream,
    InvalidTreatmentManager,
    RootNotFound,
    SameValues,
    VulnNotFound,
    VulnNotInFinding,
)
from dataloaders import (
    apply_context_attrs,
    Dataloaders,
    get_new_context,
)
from db_model.findings.types import (
    Finding,
)
from findings import (
    dal as findings_dal,
)
from freezegun import (  # type: ignore
    freeze_time,
)
import json
from newutils import (
    datetime as datetime_utils,
    vulnerabilities as vulns_utils,
)
from organizations_finding_policies import (
    domain as policies_domain,
)
import os
import pytest
from starlette.datastructures import (
    UploadFile,
)
from typing import (
    Any,
    Dict,
)
from vulnerabilities import (
    dal as vulns_dal,
    domain as vulns_domain,
)

pytestmark = pytest.mark.asyncio


async def _get_result_async(
    data: Dict[str, Any], user: str = "integratesmanager@gmail.com"
) -> Dict[str, Any]:
    """Get result."""
    request = await create_dummy_session(user)
    request = apply_context_attrs(request)
    _, result = await graphql(SCHEMA, data, context_value=request)

    return result


async def test_vulnerability() -> None:
    vuln_uuid = "09afd608-aa53-4ccb-9094-0076181fa0ea"
    expected_output = {
        "finding_id": "475041513",
        "UUID": vuln_uuid,
        "vulnerability_type": "ports",
        "specific": "3636",
        # FP: local testing
        "where": "192.168.100.105",  # NOSONAR
        "historic_state": [
            {
                "date": "2019-09-13 09:58:38",
                "analyst": "unittest@fluidattacks.com",
                "source": "integrates",
                "state": "open",
            }
        ],
        "historic_zero_risk": [
            {"date": "2018-09-28 10:32:58", "status": "REQUESTED"},
            {"date": "2020-09-09 16:01:26", "status": "CONFIRMED"},
        ],
        "zero_risk": "Confirmed",
    }
    query = """
        query {
            vulnerability(uuid: "$vuln_uuid") {
                findingId
                id
                vulnerabilityType
                specific
                where
                historicState
                historicZeroRisk {
                    date
                    status
                }
                zeroRisk
            }
        }
    """.replace(
        "$vuln_uuid", vuln_uuid
    )
    data = {"query": query}
    result = await _get_result_async(data)
    assert "errors" not in result
    assert result["data"]["vulnerability"]["findingId"] == expected_output.get(
        "finding_id"
    )
    assert result["data"]["vulnerability"]["where"] == expected_output.get(
        "where"
    )
    assert result["data"]["vulnerability"][
        "historicState"
    ] == expected_output.get("historic_state")
    assert result["data"]["vulnerability"][
        "historicZeroRisk"
    ] == expected_output.get("historic_zero_risk")
    assert result["data"]["vulnerability"]["id"] == expected_output.get("UUID")
    assert result["data"]["vulnerability"]["specific"] == expected_output.get(
        "specific"
    )
    assert result["data"]["vulnerability"][
        "vulnerabilityType"
    ] == expected_output.get("vulnerability_type")
    assert result["data"]["vulnerability"]["zeroRisk"] == expected_output.get(
        "zero_risk"
    )


@pytest.mark.changes_db
async def test_remove_tags() -> None:
    """Check for removeTags mutation."""
    query = """
        mutation {
            removeTags(
                findingId: "463558592",
                vulnerabilities: [
                    "0a848781-b6a4-422e-95fa-692151e6a98e",
                    "3bcdb384-5547-4170-a0b6-3b397a245465"
                ]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratesuser@gmail.com"
    )  # NOSONAR
    assert "errors" not in result
    assert "success" in result["data"]["removeTags"]
    assert result["data"]["removeTags"]["success"]


@pytest.mark.changes_db
async def test_update_vulnerability_treatment() -> None:
    """Check for updateVulnerabilityTreatment mutation."""
    query = """
        mutation {
            updateVulnerabilityTreatment (
                findingId: "422286126",
                vulnerabilityId: "80d6a69f-a376-46be-98cd-2fdedcffdcc0"
                externalBugTrackingSystem: "http://test"
            ){
            success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data, user="continuoushacking@gmail.com")
    assert "errors" not in result
    assert "success" in result["data"]["updateVulnerabilityTreatment"]
    assert result["data"]["updateVulnerabilityTreatment"]["success"]


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.changes_db
async def test_request_verification() -> None:
    """Check for requestVulnerabilitiesVerification mutation."""
    justification: str = "this is a comenting test of a request "
    "verification in vulns"  # pylint: disable=pointless-string-statement
    query = f"""
        mutation {{
            requestVulnerabilitiesVerification(
                findingId: "436992569",
                justification: "{justification}",
                vulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275",
                        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"]
            ) {{
                success
            }}
        }}
    """
    data = {"query": query}
    result = await _get_result_async(data)
    assert "errors" not in result
    assert "success" in result["data"]["requestVulnerabilitiesVerification"]
    vulnerability = await vulns_domain.get_by_finding(
        "436992569", "5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"
    )
    assert (
        vulnerability["historic_verification"][-1].get("status") == "REQUESTED"
    )
    vulnerability = await vulns_domain.get_by_finding(
        "436992569", "5afb9a49-a359-48ce-80ee-79c145919275"
    )
    assert (
        vulnerability["historic_verification"][-1].get("status") == "REQUESTED"
    )


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.changes_db
async def test_verify_requested_vulns() -> None:
    """Check for verifyVulnerabilitiesRequest mutation."""
    query = """
        mutation {
            verifyVulnerabilitiesRequest(
                findingId: "422286126",
                justification: "Vuln verified",
                openVulnerabilities: ["80d6a69f-a376-46be-98cd-2fdedcffdcc0"],
                closedVulnerabilities: []
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data)
    expected_error = "Exception - Error verification not requested"
    assert "errors" in result
    assert result["errors"][0]["message"] == expected_error


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.changes_db
@freeze_time("2019-12-01")
async def test_request_zero_risk_vuln() -> None:
    """Check for requestVulnerabilitiesZeroRisk mutation."""
    query = """
        mutation {
            requestVulnerabilitiesZeroRisk(
                findingId: "436992569",
                justification: "request zero risk vuln",
                vulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275",
                        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratescustomer@gmail.com"
    )  # NOSONAR
    assert "errors" not in result
    assert "success" in result["data"]["requestVulnerabilitiesZeroRisk"]
    assert result["data"]["requestVulnerabilitiesZeroRisk"]["success"]

    comments = await comments_domain.get("zero_risk", "436992569")
    assert len(comments) == 1
    assert comments[0]["content"] == "request zero risk vuln"
    assert comments[0]["created"] == "2019-11-30 19:00:00"  # NOSONAR
    assert comments[0]["email"] == "integratescustomer@gmail.com"
    assert comments[0]["finding_id"] == "436992569"
    assert comments[0]["fullname"] == "unit test"  # NOSONAR
    assert comments[0]["modified"] == "2019-11-30 19:00:00"
    comment_id = comments[0]["comment_id"]

    vulnerability = await vulns_domain.get_by_finding(
        "436992569", "5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"
    )
    assert len(vulnerability["historic_zero_risk"]) == 1
    assert (
        vulnerability["historic_zero_risk"][-1].get("comment_id") == comment_id
    )
    assert (
        vulnerability["historic_zero_risk"][-1].get("date")
        == "2019-11-30 19:00:00"
    )
    assert (
        vulnerability["historic_zero_risk"][-1].get("email")
        == "integratescustomer@gmail.com"
    )
    assert vulnerability["historic_zero_risk"][-1].get("status") == "REQUESTED"
    vulnerability = await vulns_domain.get_by_finding(
        "436992569", "5afb9a49-a359-48ce-80ee-79c145919275"
    )
    assert len(vulnerability["historic_zero_risk"]) == 1
    assert (
        vulnerability["historic_zero_risk"][-1].get("comment_id") == comment_id
    )
    assert (
        vulnerability["historic_zero_risk"][-1].get("date")
        == "2019-11-30 19:00:00"
    )
    assert (
        vulnerability["historic_zero_risk"][-1].get("email")
        == "integratescustomer@gmail.com"
    )
    assert vulnerability["historic_zero_risk"][-1].get("status") == "REQUESTED"


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.changes_db
async def test_request_zero_risk_vuln_error_already_requested() -> None:
    """Check for already requested vuln with requestVulnerabilitiesZeroRisk
    mutation."""
    query = """
        mutation {
            requestVulnerabilitiesZeroRisk(
                findingId: "436992569",
                justification: "request zero risk vuln",
                vulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275",
                        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data)
    assert "errors" in result
    assert (
        result["errors"][0]["message"]
        == "Exception - Zero risk vulnerability is already requested"
    )

    vulnerability = await vulns_domain.get_by_finding(
        "436992569", "5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"
    )
    assert len(vulnerability["historic_zero_risk"]) == 1
    vulnerability = await vulns_domain.get_by_finding(
        "436992569", "5afb9a49-a359-48ce-80ee-79c145919275"
    )
    assert len(vulnerability["historic_zero_risk"]) == 1

    comments = await comments_domain.get("zero_risk", "436992569")
    assert len(comments) == 1


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.changes_db
async def test_request_zero_risk_vuln_error_vuln_not_in_finding() -> None:
    """Check for vuln not in finding with requestVulnerabilitiesZeroRisk
    mutation."""
    query = """
        mutation {
            requestVulnerabilitiesZeroRisk(
                findingId: "436992569",
                justification: "request zero risk vuln",
                vulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275",
                        "80d6a69f-a376-46be-98cd-2fdedcffdcc0"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    assert "errors" in result
    assert result["errors"][0]["message"] == str(VulnNotInFinding())

    vulnerability = await vulns_domain.get_by_finding(
        "436992569", "5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"
    )
    assert len(vulnerability["historic_zero_risk"]) == 1
    vulnerability = await vulns_domain.get_by_finding(
        "436992569", "5afb9a49-a359-48ce-80ee-79c145919275"
    )
    assert len(vulnerability["historic_zero_risk"]) == 1

    comments = await comments_domain.get("zero_risk", "436992569")
    assert len(comments) == 1


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
async def test_request_error_invalid_justification_lentgh() -> None:
    """Check for invalid justification length
    with requestVulnerabilitiesZeroRisk mutation."""
    justification = "x" * 5001
    query = f"""
        mutation {{
            requestVulnerabilitiesZeroRisk(
                findingId: "436992569",
                justification: "{justification}",
                vulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275",
                        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62952"]
            ) {{
                success
            }}
        }}
    """
    data = {"query": query}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    assert "errors" in result
    assert (
        result["errors"][0]["message"]
        == "Exception - Justification must have a maximum of 5000 characters"
    )  # NOSONAR


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.changes_db
@freeze_time("2019-11-30")
async def test_request_zero_risk_vuln_finding_state() -> None:
    query = """
        query GetFindingVulnInfo($findingId: String!) {
            finding(identifier: $findingId) {
                openVulnerabilities
                state
            }
        }
    """
    query_data = {"query": query, "variables": {"findingId": "463558592"}}
    query_result = await _get_result_async(query_data)
    assert "errors" not in query_result
    assert query_result["data"]["finding"]["openVulnerabilities"] == 1
    assert query_result["data"]["finding"]["state"] == "open"

    mutation = """
        mutation {
            requestVulnerabilitiesZeroRisk(
                findingId: "463558592",
                justification: "request zero risk vuln",
                vulnerabilities: ["0a848781-b6a4-422e-95fa-692151e6a98e"]
            ) {
                success
            }
        }
    """
    mutation_data = {"query": mutation}
    mutation_result = await _get_result_async(mutation_data)
    assert "errors" not in mutation_result
    assert (
        "success" in mutation_result["data"]["requestVulnerabilitiesZeroRisk"]
    )
    assert mutation_result["data"]["requestVulnerabilitiesZeroRisk"]["success"]

    query_data = {"query": query, "variables": {"findingId": "463558592"}}
    query_result = await _get_result_async(query_data)
    assert "errors" not in query_result
    assert query_result["data"]["finding"]["openVulnerabilities"] == 0
    assert query_result["data"]["finding"]["state"] == "closed"


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.changes_db
@freeze_time("2019-12-01")
async def test_confirm_zero_risk_vuln() -> None:
    """Check for confirmVulnerabilitiesZeroRisk mutation."""
    query = """
        mutation {
            confirmVulnerabilitiesZeroRisk(
                findingId: "463558592",
                justification: "confirm zero risk vuln",
                vulnerabilities:
                    ["54b94fa0-8f4f-4b10-a38a-6e848a9eb0c6",
                        "6f023c26-5b10-4ded-aa27-bb563c2206ab"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratesreviewer@fluidattacks.com"
    )  # NOSONAR
    assert "errors" not in result
    assert "success" in result["data"]["confirmVulnerabilitiesZeroRisk"]
    assert result["data"]["confirmVulnerabilitiesZeroRisk"]["success"]

    unsorted_comments = await comments_domain.get("zero_risk", "463558592")
    comments = sorted(
        unsorted_comments,
        key=lambda x: x.get("created"),
        reverse=True,
    )
    assert len(comments) == 2
    assert comments[0]["content"] == "confirm zero risk vuln"
    assert comments[0]["created"] == "2019-11-30 19:00:00"
    assert comments[0]["email"] == "integratesreviewer@fluidattacks.com"
    assert comments[0]["finding_id"] == "463558592"
    assert comments[0]["fullname"] == "unit test"
    assert comments[0]["modified"] == "2019-11-30 19:00:00"
    comment_id = comments[0]["comment_id"]

    vulnerability = await vulns_domain.get_by_finding(
        "463558592", "6f023c26-5b10-4ded-aa27-bb563c2206ab"
    )
    assert len(vulnerability["historic_zero_risk"]) == 2
    assert (
        vulnerability["historic_zero_risk"][-1].get("comment_id") == comment_id
    )
    assert (
        vulnerability["historic_zero_risk"][-1].get("date")
        == "2019-11-30 19:00:00"
    )
    assert (
        vulnerability["historic_zero_risk"][-1].get("email")
        == "integratesreviewer@fluidattacks.com"
    )
    assert vulnerability["historic_zero_risk"][-1].get("status") == "CONFIRMED"
    vulnerability = await vulns_domain.get_by_finding(
        "463558592", "54b94fa0-8f4f-4b10-a38a-6e848a9eb0c6"
    )
    assert len(vulnerability["historic_zero_risk"]) == 2
    assert (
        vulnerability["historic_zero_risk"][-1].get("comment_id") == comment_id
    )
    assert (
        vulnerability["historic_zero_risk"][-1].get("date")
        == "2019-11-30 19:00:00"
    )
    assert (
        vulnerability["historic_zero_risk"][-1].get("email")
        == "integratesreviewer@fluidattacks.com"
    )
    assert vulnerability["historic_zero_risk"][-1].get("status") == "CONFIRMED"


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.changes_db
async def test_confirm_zero_risk_vuln_error_not_requested() -> None:
    """Check for not requested zero risk vuln
    with confirmVulnerabilitiesZeroRisk mutation."""
    query = """
        mutation {
            confirmVulnerabilitiesZeroRisk(
                findingId: "463558592",
                justification: "confirm zero risk vuln",
                vulnerabilities:
                    ["54b94fa0-8f4f-4b10-a38a-6e848a9eb0c6",
                        "6f023c26-5b10-4ded-aa27-bb563c2206ab"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data)
    assert "errors" in result
    assert (
        result["errors"][0]["message"]
        == "Exception - Zero risk vulnerability is not requested"
    )

    vulnerability = await vulns_domain.get_by_finding(
        "463558592", "6f023c26-5b10-4ded-aa27-bb563c2206ab"
    )
    assert len(vulnerability["historic_zero_risk"]) == 2
    vulnerability = await vulns_domain.get_by_finding(
        "463558592", "54b94fa0-8f4f-4b10-a38a-6e848a9eb0c6"
    )
    assert len(vulnerability["historic_zero_risk"]) == 2

    comments = await comments_domain.get("zero_risk", "463558592")
    assert len(comments) == 2


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.changes_db
async def test_confirm_zero_risk_vuln_error_vuln_not_in_finding() -> None:
    """Check for vuln not in finding with confirmVulnerabilitiesZeroRisk
    mutation."""
    query = """
        mutation {
            confirmVulnerabilitiesZeroRisk(
                findingId: "463558592",
                justification: "confirm zero risk vuln",
                vulnerabilities:
                    ["54b94fa0-8f4f-4b10-a38a-6e848a9eb0c6",
                        "72bb8607-c259-4781-9599-185aac02b3cc"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratesreviewer@fluidattacks.com"
    )
    assert "errors" in result
    assert result["errors"][0]["message"] == str(VulnNotInFinding())

    vulnerability = await vulns_domain.get_by_finding(
        "463558592", "6f023c26-5b10-4ded-aa27-bb563c2206ab"
    )
    assert len(vulnerability["historic_zero_risk"]) == 2
    vulnerability = await vulns_domain.get_by_finding(
        "463558592", "54b94fa0-8f4f-4b10-a38a-6e848a9eb0c6"
    )
    assert len(vulnerability["historic_zero_risk"]) == 2

    comments = await comments_domain.get("zero_risk", "463558592")
    assert len(comments) == 2


async def test_confirm_error_invalid_justification_lentgh() -> None:  # noqa
    """Check for invalid justification lentgh
    with confirmVulnerabilitiesZeroRisk mutation."""
    justification = "x" * 5001
    query = f"""
        mutation {{
            confirmVulnerabilitiesZeroRisk(
                findingId: "436992569",
                justification: "{justification}",
                vulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275",
                        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62952"]
            ) {{
                success
            }}
        }}
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratesreviewer@fluidattacks.com"
    )
    assert "errors" in result
    assert (
        result["errors"][0]["message"]
        == "Exception - Justification must have a maximum of 5000 characters"
    )


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.changes_db
@freeze_time("2019-12-01")
async def test_reject_zero_risk_vuln() -> None:
    """Check for rejectVulnerabilitiesZeroRisk mutation."""
    query = """
        mutation {
            rejectVulnerabilitiesZeroRisk(
                findingId: "463558592",
                justification: "reject zero risk vuln",
                vulnerabilities:
                    ["3bcdb384-5547-4170-a0b6-3b397a245465",
                        "74632c0c-db08-47c2-b013-c70e5b67c49f"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratesreviewer@fluidattacks.com"
    )
    assert "errors" not in result
    assert "success" in result["data"]["rejectVulnerabilitiesZeroRisk"]
    assert result["data"]["rejectVulnerabilitiesZeroRisk"]["success"]

    unsorted_comments = await comments_domain.get("zero_risk", "463558592")
    comments = sorted(
        unsorted_comments,
        key=lambda x: x.get("created"),
        reverse=True,
    )
    assert len(comments) == 2
    assert comments[0]["content"] == "reject zero risk vuln"
    assert comments[0]["created"] == "2019-11-30 19:00:00"
    assert comments[0]["email"] == "integratesreviewer@fluidattacks.com"
    assert comments[0]["finding_id"] == "463558592"
    assert comments[0]["fullname"] == "unit test"
    assert comments[0]["modified"] == "2019-11-30 19:00:00"
    comment_id = comments[0]["comment_id"]

    vulnerability = await vulns_domain.get_by_finding(
        "463558592", "3bcdb384-5547-4170-a0b6-3b397a245465"
    )
    assert len(vulnerability["historic_zero_risk"]) == 2
    assert (
        vulnerability["historic_zero_risk"][-1].get("comment_id") == comment_id
    )
    assert (
        vulnerability["historic_zero_risk"][-1].get("date")
        == "2019-11-30 19:00:00"
    )
    assert (
        vulnerability["historic_zero_risk"][-1].get("email")
        == "integratesreviewer@fluidattacks.com"
    )
    assert vulnerability["historic_zero_risk"][-1].get("status") == "REJECTED"
    vulnerability = await vulns_domain.get_by_finding(
        "463558592", "74632c0c-db08-47c2-b013-c70e5b67c49f"
    )
    assert len(vulnerability["historic_zero_risk"]) == 2
    assert (
        vulnerability["historic_zero_risk"][-1].get("comment_id") == comment_id
    )
    assert (
        vulnerability["historic_zero_risk"][-1].get("date")
        == "2019-11-30 19:00:00"
    )
    assert (
        vulnerability["historic_zero_risk"][-1].get("email")
        == "integratesreviewer@fluidattacks.com"
    )
    assert vulnerability["historic_zero_risk"][-1].get("status") == "REJECTED"


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.changes_db
async def test_reject_zero_risk_vuln_error_not_requested() -> None:
    """Check for not requested zero risk vuln
    with rejectVulnerabilitiesZeroRisk mutation."""
    query = """
        mutation {
            rejectVulnerabilitiesZeroRisk(
                findingId: "463558592",
                justification: "reject zero risk vuln",
                vulnerabilities:
                    ["3bcdb384-5547-4170-a0b6-3b397a245465",
                        "74632c0c-db08-47c2-b013-c70e5b67c49f"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data)
    assert "errors" in result
    assert (
        result["errors"][0]["message"]
        == "Exception - Zero risk vulnerability is not requested"
    )

    vulnerability = await vulns_domain.get_by_finding(
        "463558592", "3bcdb384-5547-4170-a0b6-3b397a245465"
    )
    assert len(vulnerability["historic_zero_risk"]) == 2
    vulnerability = await vulns_domain.get_by_finding(
        "463558592", "74632c0c-db08-47c2-b013-c70e5b67c49f"
    )
    assert len(vulnerability["historic_zero_risk"]) == 2

    comments = await comments_domain.get("zero_risk", "463558592")
    assert len(comments) == 2


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.changes_db
async def test_reject_zero_risk_vuln_error_vuln_not_in_finding() -> None:
    """Check for vuln not in finding with rejectVulnerabilitiesZeroRisk
    mutation."""
    query = """
        mutation {
            rejectVulnerabilitiesZeroRisk(
                findingId: "463558592",
                justification: "reject zero risk vuln",
                vulnerabilities:
                    ["3bcdb384-5547-4170-a0b6-3b397a245465",
                        "81db1fad-c329-4356-a5eb-9ad9b0d75a7e"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratesreviewer@fluidattacks.com"
    )
    assert "errors" in result
    assert result["errors"][0]["message"] == str(VulnNotInFinding())

    vulnerability = await vulns_domain.get_by_finding(
        "463558592", "3bcdb384-5547-4170-a0b6-3b397a245465"
    )
    assert len(vulnerability["historic_zero_risk"]) == 2
    vulnerability = await vulns_domain.get_by_finding(
        "463558592", "74632c0c-db08-47c2-b013-c70e5b67c49f"
    )
    assert len(vulnerability["historic_zero_risk"]) == 2

    comments = await comments_domain.get("zero_risk", "463558592")
    assert len(comments) == 2


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
async def test_reject_error_invalid_justification_lentgh() -> None:
    """Check for invalid justification lentgh
    with rejectVulnerabilitiesZeroRisk mutation."""
    justification = "x" * 5001
    query = f"""
        mutation {{
            rejectVulnerabilitiesZeroRisk(
                findingId: "436992569",
                justification: "{justification}",
                vulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275",
                        "5ed5c3c0-9064-41f5-8ef2-5e1eeee62952"]
            ) {{
                success
            }}
        }}
    """
    data = {"query": query}
    result = await _get_result_async(
        data, user="integratesreviewer@fluidattacks.com"
    )
    assert "errors" in result
    assert (
        result["errors"][0]["message"]
        == "Exception - Justification must have a maximum of 5000 characters"
    )


@pytest.mark.changes_db
async def test_remove_vulnerability() -> None:
    """Check for removeVulnerability mutation."""
    query = """
        mutation{
            removeVulnerability (
            id: "a8c0ff07-bb21-4cd5-bb9f-4d716fc69320"
            findingId: "475041513"
            justification: REPORTING_ERROR
            ) {
            success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data)
    assert "errors" not in result
    assert "success" in result["data"]["removeVulnerability"]
    with pytest.raises(VulnNotFound):
        assert await vulns_domain.get_by_finding(
            "475041513", "a8c0ff07-bb21-4cd5-bb9f-4d716fc69320"
        )


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.skipif(MIGRATION, reason="Finding migration")
@pytest.mark.changes_db
async def test_upload_file() -> None:
    """Check for uploadFile mutation."""
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "../mock/test-vulns.yaml")
    vuln = await vulns_domain.get("74632c0c-db08-47c2-b013-c70e5b67c49f")
    assert vuln["historic_verification"][-1].get("status") == "REQUESTED"

    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name,
            file=test_file,
            content_type="text/x-yaml",  # NOSONAR
        )
        query = """
            mutation UploadFileMutation(
                $file: Upload!, $findingId: String!
            ) {
                uploadFile (
                    file: $file,
                    findingId: $findingId
                ) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": "463558592",
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" not in result
    assert "success" in result["data"]["uploadFile"]
    vuln = await vulns_domain.get("74632c0c-db08-47c2-b013-c70e5b67c49f")
    finding = await findings_dal.get_attributes(
        "463558592", ["historic_verification"]
    )
    assert vuln["historic_verification"][-1].get("status") == "VERIFIED"
    assert len(finding["historic_verification"][-1].get("vulns")) == 2

    query = """
        query GetFindingVulnInfo($findingId: String!) {
            finding(identifier: $findingId) {
                title
                vulnerabilities {
                    commitHash
                    stream
                    specific
                    where
                    historicTreatment {
                        user
                        treatment
                    }
                }
            }
        }
    """
    data = {"query": query, "variables": {"findingId": "463558592"}}
    result = await _get_result_async(data)
    assert "errors" not in result
    finding_name = result["data"]["finding"]["title"]
    finding_policy = await policies_domain.get_finding_policy_by_name(
        org_name="okada",
        finding_name=finding_name.split(".")[0].lower(),
    )
    user_policy = finding_policy.state.modified_by
    vulnerabilities = result["data"]["finding"]["vulnerabilities"]
    for vuln in vulnerabilities:
        if (
            vuln["where"] == "https://example.com"
            and vuln["specific"] == "phone"
        ):
            assert vuln["stream"] == "home > blog > articulo"
            assert (
                vuln["historicTreatment"][-1]["treatment"]
                == "ACCEPTED_UNDEFINED"
            )
            assert vuln["historicTreatment"][-1]["user"] == user_policy
        if (
            vuln["where"] == "product/path/to/file3.ext"
            and vuln["specific"] == "345"
        ):
            assert vuln["commitHash"] == (
                "e17059d1e17059d1e17059d1e17059d1e17059d1"
            )


@pytest.mark.skipif(not MIGRATION, reason="Finding migration")
@pytest.mark.changes_db
async def test_upload_file_new() -> None:
    """Check for uploadFile mutation."""
    # pylint: disable=too-many-locals
    finding_id = "463558592"
    vuln_uuid = "74632c0c-db08-47c2-b013-c70e5b67c49f"
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "../mock/test-vulns.yaml")
    vuln = await vulns_domain.get(vuln_uuid)
    assert vuln["historic_verification"][-1].get("status") == "REQUESTED"

    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name,
            file=test_file,
            content_type="text/x-yaml",  # NOSONAR
        )
        query = """
            mutation UploadFileMutation(
                $file: Upload!, $findingId: String!
            ) {
                uploadFile (
                    file: $file,
                    findingId: $findingId
                ) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": finding_id,
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" not in result
    assert "success" in result["data"]["uploadFile"]
    vuln = await vulns_domain.get(vuln_uuid)
    assert vuln["historic_verification"][-1].get("status") == "VERIFIED"
    loaders: Dataloaders = get_new_context()
    finding: Finding = await loaders.finding_new.load(finding_id)
    assert len(finding.verification.vulnerability_ids) == 2

    query = """
        query GetFindingVulnInfo($findingId: String!) {
            finding(identifier: $findingId) {
                title
                vulnerabilities {
                    commitHash
                    stream
                    specific
                    where
                    historicTreatment {
                        user
                        treatment
                    }
                }
            }
        }
    """
    data = {"query": query, "variables": {"findingId": finding_id}}
    result = await _get_result_async(data)
    assert "errors" not in result
    finding_name = result["data"]["finding"]["title"]
    finding_policy = await policies_domain.get_finding_policy_by_name(
        org_name="okada",
        finding_name=finding_name.split(".")[0].lower(),
    )
    user_policy = finding_policy.state.modified_by
    vulnerabilities = result["data"]["finding"]["vulnerabilities"]
    for vuln in vulnerabilities:
        if (
            vuln["where"] == "https://example.com"
            and vuln["specific"] == "phone"
        ):
            assert vuln["stream"] == "home > blog > articulo"
            assert (
                vuln["historicTreatment"][-1]["treatment"]
                == "ACCEPTED_UNDEFINED"
            )
            assert vuln["historicTreatment"][-1]["user"] == user_policy
        if (
            vuln["where"] == "product/path/to/file3.ext"
            and vuln["specific"] == "345"
        ):
            assert vuln["commitHash"] == (
                "e17059d1e17059d1e17059d1e17059d1e17059d1"
            )


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.changes_db
async def test_upload_file_reopen() -> None:
    """Check if a new vuln is created when a closed vuln is reopen"""
    closed_vuln_uuid = "74632c0c-db08-47c2-b013-c70e5b67c49f"
    vuln = await vulns_domain.get(closed_vuln_uuid)
    assert vuln["historic_verification"][-1]["status"] == "VERIFIED"
    assert vulns_utils.get_last_status(vuln) == "closed"

    finding_id = "463558592"
    finding_vulns_before = await vulns_dal.get_by_finding(finding_id)

    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "../mock/test-vulns-reopen.yaml")
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name,
            file=test_file,
            content_type="text/x-yaml",  # NOSONAR
        )
        query = """
            mutation UploadFileMutation(
                $file: Upload!, $findingId: String!
            ) {
                uploadFile (
                    file: $file,
                    findingId: $findingId
                ) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": finding_id,
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" not in result
    assert "success" in result["data"]["uploadFile"]
    assert vulns_utils.get_last_status(vuln) == "closed"
    finding_vulns = await vulns_dal.get_by_finding(finding_id)
    assert len(finding_vulns) == len(finding_vulns_before) + 1

    vuln = await vulns_domain.get(closed_vuln_uuid)
    assert vuln["historic_verification"][-1]["status"] == "VERIFIED"
    assert vulns_utils.get_last_status(vuln) == "closed"

    for vuln in finding_vulns:
        if (
            vuln["where"] == "product/path/to/file1.ext"
            and vuln["specific"] == "123"
            and vuln["UUID"] != closed_vuln_uuid
        ):
            assert vuln["vuln_type"] == "lines"
            assert (
                vuln["commit_hash"]
                == "5b5c92105b5c92105b5c92105b5c92105b5c9210"
            )
            assert vuln["repo_nickname"] == "product"
            assert vuln["historic_state"][-1]["state"] == "open"


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.changes_db
async def test_upload_file_with_escaper() -> None:
    """Test fields source and escaper"""
    finding_id = "463558592"
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "../mock/test-vulns-escaper.yaml")
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name,
            file=test_file,
            content_type="text/x-yaml",  # NOSONAR
        )
        query = """
            mutation UploadFileMutation(
                $file: Upload!, $findingId: String!
            ) {
                uploadFile (
                    file: $file,
                    findingId: $findingId
                ) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": finding_id,
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" not in result
    assert "success" in result["data"]["uploadFile"]

    finding_vulns = await vulns_dal.get_by_finding(finding_id)
    vulns_escape = [
        vuln
        for vuln in finding_vulns
        if (
            vuln["where"] == "product/path/to/escape.txt"
            and vuln["specific"] == "890"
            and vuln["vuln_type"] == "lines"
        )
    ]
    assert len(vulns_escape) == 1
    escaped = vulns_escape[0]
    assert escaped["historic_state"][-1]["state"] == "open"
    assert escaped["historic_state"][-1]["source"] == "escape"
    assert (
        escaped["historic_state"][-1]["analyst"] == "escaper@fluidattacks.com"
    )


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
async def test_upload_file_error() -> None:
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "../mock/test-vuln-error.yaml")

    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name, file=test_file, content_type="text/x-yaml"
        )
        query = """
            mutation UploadFileMutation($file: Upload!, $findingId: String!) {
                uploadFile (file: $file, findingId: $findingId) {
                    success
                }
            }
        """  # NOSONAR
        variables = {
            "file": uploaded_file,
            "findingId": "463558592",
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" in result
    field_pattern = r"^(\b[\w-]{1,30}\b)+(,\b[\w-]{1,30}\b){0,9}$"
    error_value = f'"values": [{json.dumps(field_pattern)}], "keys": []'
    assert result["errors"][0]["message"] == str(InvalidSchema(error_value))


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
async def test_upload_file_error_commit_hash() -> None:
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(
        filename, "../mock/test-vuln-commit-hash-error.yaml"
    )

    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name, file=test_file, content_type="text/x-yaml"
        )
        query = """
            mutation UploadFileMutation($file: Upload!, $findingId: String!) {
                uploadFile (file: $file, findingId: $findingId) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": "463558592",
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" in result
    field_pattern = r"^([a-f0-9]{40})$"
    error_value = f'"values": [{json.dumps(field_pattern)}], "keys": []'
    assert result["errors"][0]["message"] == str(InvalidSchema(error_value))


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
async def test_upload_file_error_stream() -> None:
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "../mock/test-vuln-error-stream.yaml")
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name, file=test_file, content_type="text/x-yaml"
        )
        query = """
            mutation UploadFileMutation($file: Upload!, $findingId: String!) {
                uploadFile (file: $file, findingId: $findingId) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": "463558592",
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" in result
    assert result["errors"][0]["message"] == str(InvalidStream())


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
async def test_upload_file_error_root() -> None:
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(filename, "../mock/test-vuln-error-root.yaml")
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name, file=test_file, content_type="text/x-yaml"
        )
        query = """
            mutation UploadFileMutation($file: Upload!, $findingId: String!) {
                uploadFile (file: $file, findingId: $findingId) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": "463558592",
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" in result
    assert result["errors"][0]["message"] == str(RootNotFound())


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
async def test_upload_file_error_new_closed_vuln() -> None:
    filename = os.path.dirname(os.path.abspath(__file__))
    filename = os.path.join(
        filename, "../mock/test-vuln-error-new-closed.yaml"
    )
    with open(filename, "rb") as test_file:
        uploaded_file = UploadFile(
            filename=test_file.name, file=test_file, content_type="text/x-yaml"
        )
        query = """
            mutation UploadFileMutation($file: Upload!, $findingId: String!) {
                uploadFile (file: $file, findingId: $findingId) {
                    success
                }
            }
        """
        variables = {
            "file": uploaded_file,
            "findingId": "463558592",
        }
        data = {"query": query, "variables": variables}
        result = await _get_result_async(data)

    assert "errors" in result
    assert result["errors"][0]["message"] == InvalidNewVulnState.msg


async def test_download_vuln_file() -> None:
    """Check for downloadVulnerabilityFile mutation."""
    query = """
        mutation DownloadVulnerabilityFile($findingId: String!) {
            downloadVulnerabilityFile (findingId: $findingId) {
                url
                success
            }
        }
    """
    finding_id = "463461507"
    group_name = "unittesting"
    variables = {
        "findingId": finding_id,
    }
    data = {"query": query, "variables": variables}
    result = await _get_result_async(data)
    assert "errors" not in result
    assert "success" in result["data"]["downloadVulnerabilityFile"]
    assert "url" in result["data"]["downloadVulnerabilityFile"]
    assert (
        f"localhost:9000/fluidintegrates.reports/{group_name}-{finding_id}"
        in result["data"]["downloadVulnerabilityFile"]["url"]
    )


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
async def test_handle_acceptation_not_requested() -> None:
    query = """
        mutation {
            handleVulnerabilitiesAcceptation(
                findingId: "436992569"
                justification: "handle acceptation"
                acceptedVulnerabilities:
                    ["5afb9a49-a359-48ce-80ee-79c145919275"]
                rejectedVulnerabilities:
                    ["5ed5c3c0-9064-41f5-8ef2-5e1eeee62955"]
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    assert "errors" in result
    assert result["errors"][0]["message"] == str(AcceptationNotRequested())


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
async def test_handle_acceptation_vuln_not_found() -> None:
    query = """
        mutation {
            handleVulnerabilitiesAcceptation(
                findingId: "560175507"
                justification: "handle acceptation"
                acceptedVulnerabilities:
                    ["6f023c26-5x10-4ded-aa27-xx563c2206ax"]
                rejectedVulnerabilities: []
            ) {
                success
            }
        }
    """
    data = {"query": query}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    assert "errors" in result
    assert result["errors"][0]["message"] == str(VulnNotFound())


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
async def test_update_vulns_treatment_invalid_treatment_manager() -> None:
    query = """
        mutation UpdateVulnerabilitiesTreatment(
            $findingId: String!,
            $justification: String!, $treatmentManager: String,
            $treatment: UpdateClientDescriptionTreatment!,
            $vulnerabilityId: ID!
        ) {
            updateVulnerabilitiesTreatment (
                findingId: $findingId
                justification: $justification
                treatment: $treatment
                treatmentManager: $treatmentManager
                vulnerabilityId: $vulnerabilityId
            ) {
                success
            }
        }
    """
    variables = {
        "findingId": "436992569",
        "treatment": "IN_PROGRESS",
        "justification": "Test in progress treatment",
        "treatmentManager": "integratesexecutive@gmail.com",
        "vulnerabilityId": "b16ed89e-668d-42d6-add1-73535bb0e083",
    }
    data = {"query": query, "variables": variables}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    assert "errors" in result
    assert result["errors"][0]["message"] == str(InvalidTreatmentManager())


@pytest.mark.skip(reason="Temporarily disabled due to db migration")
@pytest.mark.changes_db
async def test_handle_acceptation() -> None:
    query = """
        mutation UpdateVulnerabilitiesTreatment(
            $findingId: String!, $justification: String!,
            $treatment: UpdateClientDescriptionTreatment!
            $treatmentManager: String,
            $acceptedVulnId: ID!
            $rejectedVulnId: ID!
        ) {
            accepted: updateVulnerabilitiesTreatment (
                findingId: $findingId
                justification: $justification
                treatment: $treatment
                treatmentManager: $treatmentManager
                vulnerabilityId: $acceptedVulnId
            ) {
                success
            }
            rejected: updateVulnerabilitiesTreatment (
                findingId: $findingId
                justification: $justification
                treatment: $treatment
                treatmentManager: $treatmentManager
                vulnerabilityId: $rejectedVulnId
            ) {
                success
            }
        }
    """
    vuln_ids = [
        "b16ed89e-668d-42d6-add1-73535bb0e083",
        "d212a841-7d48-4cb6-b776-cccc2845c383",
    ]
    treatment_manager = "integratesuser@gmail.com"
    variables: Dict[str, Any] = {
        "findingId": "436992569",
        "treatment": "ACCEPTED_UNDEFINED",
        "justification": "Test to consider permanently accepted treatment",
        "treatmentManager": treatment_manager,
        "acceptedVulnId": vuln_ids[0],
        "rejectedVulnId": vuln_ids[1],
    }
    data = {"query": query, "variables": variables}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    vulns = await vulns_domain.get_by_finding_and_uuids(
        "436992569", set(vuln_ids)
    )
    assert "errors" not in result
    assert result["data"]["accepted"]["success"]
    assert result["data"]["rejected"]["success"]
    assert (
        vulns[0]["historic_treatment"][-1]["treatment_manager"]
        == treatment_manager
    )
    assert (
        vulns[0]["historic_treatment"][-1]["treatment"] == "ACCEPTED_UNDEFINED"
    )
    assert (
        vulns[0]["historic_treatment"][-1]["acceptance_status"] == "SUBMITTED"
    )

    result = await _get_result_async(data, user="integratesuser@gmail.com")
    assert "errors" in result
    assert result["errors"][0]["message"] == str(SameValues())

    query = """
        mutation HandleVulnerabilitiesAcceptationMutation(
            $findingId: String!
            $justification: String!
            $acceptedVulns: [String]!
            $rejectedVulns: [String]!
        ) {
            handleVulnerabilitiesAcceptation(
                findingId: $findingId
                justification: $justification
                acceptedVulnerabilities: $acceptedVulns
                rejectedVulnerabilities: $rejectedVulns
            ) {
                success
            }
        }
    """
    variables = {
        "findingId": "436992569",
        "justification": "Test justification handle acceptation vulns",
        "acceptedVulns": [vuln_ids[0]],
        "rejectedVulns": [vuln_ids[1]],
    }
    data = {"query": query, "variables": variables}
    result = await _get_result_async(data, user="integratesuser@gmail.com")
    vulns = await vulns_domain.get_by_finding_and_uuids(
        "436992569", set(vuln_ids)
    )
    assert "errors" not in result
    assert "success" in result["data"]["handleVulnerabilitiesAcceptation"]
    assert result["data"]["handleVulnerabilitiesAcceptation"]["success"]
    assert (
        vulns[0]["historic_treatment"][-1]["treatment_manager"]
        == treatment_manager
    )
    assert (
        vulns[0]["historic_treatment"][-1]["treatment"] == "ACCEPTED_UNDEFINED"
    )
    assert (
        vulns[0]["historic_treatment"][-1]["acceptance_status"] == "APPROVED"
    )
    assert (
        vulns[-1]["historic_treatment"][-1]["treatment"]
        != "ACCEPTED_UNDEFINED"
    )
    assert (
        vulns[-1]["historic_treatment"][-2]["acceptance_status"] == "REJECTED"
    )
    assert await vulns_domain.send_treatment_change_mail(
        get_new_context(),
        "436992569",
        "dummy_title",
        "unittesting",
        datetime_utils.get_now_minus_delta(days=1),
    )


async def test_vulnerability_verification() -> None:
    vuln1_id = "587c40de-09a0-4d85-a9f9-eaa46aa895d7"
    vuln2_id = "15375781-31f2-4953-ac77-f31134225747"
    expected_vuln1 = {
        "finding_id": "436992569",
        "UUID": vuln1_id,
        "vulnerability_type": "ports",
        "specific": "1111",
        # FP: local testing
        "where": "192.168.100.112",  # NOSONAR
        "cycles": 1,
        "last_requested_reattack_date": "2020-02-19 10:41:04",
        "efficacy": 0,
        "report_date": "2019-09-13 17:00:56",
        "last_reattack_date": "",
        "last_reattack_requester": "integratesuser@gmail.com",
    }
    expected_vuln2 = {
        "finding_id": "436992569",
        "UUID": vuln2_id,
        "vulnerability_type": "ports",
        "specific": "333",
        # FP: local testing
        "where": "192.168.100.101",  # NOSONAR
        "cycles": 1,
        "last_requested_reattack_date": "2020-02-18 10:41:04",
        "efficacy": 0,
        "report_date": "2019-09-13 08:17:41",
        "last_reattack_date": "2020-02-19 10:41:04",
        "last_reattack_requester": "integratesuser@gmail.com",
    }
    query = """
        query GetVulnInfo($vuln1Id: String!, $vuln2Id: String!) {
            vuln1: vulnerability(uuid: $vuln1Id) {
                ...VulnInfo
            }
            vuln2: vulnerability(uuid: $vuln2Id) {
                ...VulnInfo
            }
        }
        fragment VulnInfo on Vulnerability {
            findingId
            id
            vulnerabilityType
            specific
            where
            cycles
            lastRequestedReattackDate
            efficacy
            reportDate
            lastReattackDate
            lastReattackRequester
        }
    """
    variables = {"vuln1Id": vuln1_id, "vuln2Id": vuln2_id}
    data = {"query": query, "variables": variables}
    result = await _get_result_async(data)
    assert "errors" not in result

    assert result["data"]["vuln1"]["findingId"] == expected_vuln1["finding_id"]
    assert result["data"]["vuln1"]["where"] == expected_vuln1["where"]
    assert result["data"]["vuln1"]["id"] == expected_vuln1["UUID"]
    assert result["data"]["vuln1"]["specific"] == expected_vuln1["specific"]
    assert (
        result["data"]["vuln1"]["vulnerabilityType"]
        == expected_vuln1["vulnerability_type"]
    )
    assert result["data"]["vuln1"][
        "lastRequestedReattackDate"
    ] == expected_vuln1.get("last_requested_reattack_date")
    assert result["data"]["vuln1"][
        "lastReattackRequester"
    ] == expected_vuln1.get("last_reattack_requester")
    assert result["data"]["vuln1"]["cycles"] == expected_vuln1["cycles"]
    assert result["data"]["vuln1"]["efficacy"] == expected_vuln1["efficacy"]
    assert (
        result["data"]["vuln1"]["reportDate"] == expected_vuln1["report_date"]
    )
    assert (
        result["data"]["vuln1"]["lastReattackDate"]
        == expected_vuln1["last_reattack_date"]
    )

    assert result["data"]["vuln2"]["findingId"] == expected_vuln2["finding_id"]
    assert result["data"]["vuln2"]["where"] == expected_vuln2["where"]
    assert result["data"]["vuln2"]["id"] == expected_vuln2["UUID"]
    assert result["data"]["vuln2"]["specific"] == expected_vuln2["specific"]
    assert (
        result["data"]["vuln2"]["vulnerabilityType"]
        == expected_vuln2["vulnerability_type"]
    )
    assert result["data"]["vuln2"][
        "lastRequestedReattackDate"
    ] == expected_vuln2.get("last_requested_reattack_date")
    assert result["data"]["vuln2"][
        "lastReattackRequester"
    ] == expected_vuln2.get("last_reattack_requester")
    assert result["data"]["vuln2"]["cycles"] == expected_vuln2["cycles"]
    assert result["data"]["vuln2"]["efficacy"] == expected_vuln2["efficacy"]
    assert (
        result["data"]["vuln2"]["reportDate"] == expected_vuln2["report_date"]
    )
    assert (
        result["data"]["vuln2"]["lastReattackDate"]
        == expected_vuln2["last_reattack_date"]
    )
