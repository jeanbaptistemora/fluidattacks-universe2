from back.tests.unit.utils import (
    create_dummy_session,
)
from custom_exceptions import (
    InvalidRange,
    InvalidSchema,
)
from dataloaders import (
    Dataloaders,
    get_new_context,
)
from db_model.enums import (
    Source,
)
from db_model.findings.types import (
    Finding,
)
from db_model.vulnerabilities.enums import (
    VulnerabilityAcceptanceStatus,
    VulnerabilityStateStatus,
    VulnerabilityType,
)
from db_model.vulnerabilities.types import (
    Vulnerability,
    VulnerabilityState,
    VulnerabilityTreatment,
    VulnerabilityTreatmentStatus,
    VulnerabilityVerification,
)
from findings.domain import (
    verify_vulnerabilities,
)
from freezegun import (  # type: ignore
    freeze_time,
)
from graphql.type import (
    GraphQLResolveInfo,
)
from itertools import (
    chain,
)
from newutils import (
    datetime as datetime_utils,
)
from newutils.datetime import (
    get_now_minus_delta,
)
from newutils.vulnerabilities import (
    adjust_historic_dates,
    as_range,
    format_vulnerabilities,
    get_ranges,
    get_specific,
    get_total_reattacks_stats,
    get_total_treatment_date,
    group_specific,
    is_range,
    is_sequence,
    range_to_list,
    sort_vulnerabilities,
    ungroup_specific,
)
import pytest
import pytz  # type: ignore
from settings import (
    TIME_ZONE,
)
from typing import (
    Dict,
    List,
    Tuple,
)
import uuid
from vulnerabilities.dal import (
    update_state,
)
from vulnerabilities.domain import (
    get_open_vulnerabilities_specific_by_type,
    get_treatments_count,
    get_updated_manager_mail_content,
    get_vulnerabilities_by_type,
    get_vulnerabilities_file,
    group_vulnerabilities,
    mask_vulnerability,
    send_treatment_change_mail,
)
from vulnerability_files.domain import (
    ungroup_vulnerability_specific,
    validate_file_schema,
)
import yaml  # type: ignore

pytestmark = [
    pytest.mark.asyncio,
]

TZN = pytz.timezone(TIME_ZONE)


def test_ungroup_specific() -> None:
    specific = "13,14,18-20,24-30,40"
    test_data = ungroup_specific(specific)
    expected_output = [
        "13",
        "14",
        "18",
        "19",
        "20",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "30",
        "40",
    ]
    assert isinstance(test_data, list)
    assert test_data == expected_output


def test_is_range() -> None:
    range_value = "100-200"
    no_range_value = "20"
    assert is_range(range_value)
    assert not is_range(no_range_value)


def test_is_sequence() -> None:
    secuence_value = "20,21,22"
    no_secuence_values = ["20-30", "20"]
    assert is_sequence(secuence_value)
    for no_secuence_value in no_secuence_values:
        assert not is_sequence(no_secuence_value)


def test_range_to_list() -> None:
    range_value = "10-15"
    bad_range_value = "13-12"
    test_data = range_to_list(range_value)
    expected_output = ["10", "11", "12", "13", "14", "15"]
    assert isinstance(test_data, list)
    assert test_data == expected_output
    with pytest.raises(InvalidRange):
        assert range_to_list(bad_range_value)


def test_sort_vulnerabilities() -> None:
    vulns = tuple(
        Vulnerability(
            finding_id="",
            id="",
            specific="",
            state=VulnerabilityState(
                modified_by="",
                modified_date="",
                source=Source.ASM,
                status=VulnerabilityStateStatus.OPEN,
            ),
            type=VulnerabilityType.INPUTS,
            where=where,
        )
        for where in ("abaa", "1abc", "aaaa")
    )
    expected_output_new = tuple(
        Vulnerability(
            finding_id="",
            id="",
            specific="",
            state=VulnerabilityState(
                modified_by="",
                modified_date="",
                source=Source.ASM,
                status=VulnerabilityStateStatus.OPEN,
            ),
            type=VulnerabilityType.INPUTS,
            where=where,
        )
        for where in ("1abc", "aaaa", "abaa")
    )
    test_data_new = sort_vulnerabilities(vulns)
    assert test_data_new == expected_output_new


async def test_group_specific() -> None:
    loaders = get_new_context()
    vulns = await loaders.finding_vulns_all_typed.load("422286126")
    test_data = group_specific(vulns, VulnerabilityType.INPUTS)
    assert isinstance(test_data, tuple)
    assert len(test_data) == 2
    assert isinstance(test_data[0], Vulnerability)
    assert test_data[0] is not None


def test_get_specific() -> None:
    no_input_vuln_with_specific = {"specific": "10"}
    test_data = get_specific(no_input_vuln_with_specific)
    expected_output = 10
    assert test_data == expected_output


def test_as_range() -> None:
    range_to_stringify = [1, 2, 3, 4, 5]
    test_data = as_range(range_to_stringify)
    expected_output = "1-5"
    assert test_data == expected_output


def test_get_ranges() -> None:
    working_list = [1, 2, 3, 7, 9, 10, 11, 12, 13, 19]
    test_data = get_ranges(working_list)
    expected_output = "1-3,7,9-13,19"
    assert test_data == expected_output


@pytest.mark.parametrize(
    ["finding_id", "expected"],
    [
        [
            "988493279",
            {
                "ports_vulnerabilities": (
                    Vulnerability(
                        finding_id="988493279",
                        id="47ce0fb0-4108-49b0-93cc-160dce8168a6",
                        specific="8888",
                        state=VulnerabilityState(
                            modified_by="unittest@fluidattacks.com",
                            modified_date="2019-04-08T00:45:15+00:00",
                            source=Source.ASM,
                            status=VulnerabilityStateStatus.OPEN,
                            justification=None,
                        ),
                        type=VulnerabilityType.PORTS,
                        where="192.168.1.19",
                        bug_tracking_system_url=None,
                        commit=None,
                        custom_severity=None,
                        hash=None,
                        repo=None,
                        stream=None,
                        tags=None,
                        treatment=VulnerabilityTreatment(
                            modified_date="2020-10-08T00:59:06+00:00",
                            status=(
                                VulnerabilityTreatmentStatus.ACCEPTED_UNDEFINED
                            ),
                            acceptance_status=VulnerabilityAcceptanceStatus.APPROVED,
                            accepted_until=None,
                            justification="Observations about permanently accepted",
                            assigned="integratesuser@gmail.com",
                            modified_by="integratesuser@gmail.com",
                        ),
                        verification=None,
                        zero_risk=None,
                    ),
                ),
                "lines_vulnerabilities": (),
                "inputs_vulnerabilities": (),
            },
        ],
        [
            "422286126",
            {
                "ports_vulnerabilities": (),
                "lines_vulnerabilities": (
                    Vulnerability(
                        finding_id="422286126",
                        id="0a848781-b6a4-422e-95fa-692151e6a98z",
                        specific="12",
                        state=VulnerabilityState(
                            modified_by="unittest@fluidattacks.com",
                            modified_date="2020-01-03T17:46:10+00:00",
                            source=Source.ASM,
                            status=VulnerabilityStateStatus.OPEN,
                            justification=None,
                        ),
                        type=VulnerabilityType.LINES,
                        where="test/data/lib_path/f060/csharp.cs",
                        bug_tracking_system_url=None,
                        commit="ea871eee64cfd5ce293411efaf4d3b446d04eb4a",
                        custom_severity=None,
                        hash=None,
                        repo=None,
                        stream=None,
                        tags=None,
                        treatment=VulnerabilityTreatment(
                            modified_date="2020-01-03T17:46:10+00:00",
                            status=VulnerabilityTreatmentStatus.IN_PROGRESS,
                            acceptance_status=None,
                            accepted_until=None,
                            justification="test justification",
                            assigned="integratescustomer@gmail.com",
                            modified_by="integratesuser@gmail.com",
                        ),
                        verification=None,
                        zero_risk=None,
                    ),
                ),
                "inputs_vulnerabilities": (),
            },
        ],
    ],
)
async def test_get_open_vulnerabilities_specific_by_type(
    finding_id: str, expected: Dict[str, Tuple[Dict[str, str], ...]]
) -> None:
    loaders: Dataloaders = get_new_context()
    results = await get_open_vulnerabilities_specific_by_type(
        loaders, finding_id
    )
    assert results == expected


async def test_get_vulnerabilities_by_type() -> None:
    context = get_new_context()
    finding_id = "422286126"
    test_data = await get_vulnerabilities_by_type(context, finding_id)
    expected_output = {
        "inputs": [],
        "lines": [
            {
                "commit_hash": "ea871eee64cfd5ce293411efaf4d3b446d04eb4a",
                "line": "12",
                "path": "test/data/lib_path/f060/csharp.cs",
                "state": "open",
            }
        ],
        "ports": [],
    }
    assert test_data == expected_output


async def test_group_vulnerabilities() -> None:
    loaders = get_new_context()
    vulns = await loaders.finding_vulns_all_typed.load("422286126")
    test_data = group_vulnerabilities(vulns)
    expected_output = (
        Vulnerability(
            finding_id="422286126",
            id="0a848781-b6a4-422e-95fa-692151e6a98z",
            specific="12",
            state=VulnerabilityState(
                modified_by="unittest@fluidattacks.com",
                modified_date="2020-01-03T17:46:10+00:00",
                source=Source.ASM,
                status=VulnerabilityStateStatus.OPEN,
            ),
            type=VulnerabilityType.LINES,
            where="test/data/lib_path/f060/csharp.cs",
            commit="ea871ee",
        ),
        Vulnerability(
            finding_id="422286126",
            id="80d6a69f-a376-46be-98cd-2fdedcffdcc0",
            specific="phone",
            state=VulnerabilityState(
                modified_by="test@unittesting.com",
                modified_date="2020-09-09T21:01:26+00:00",
                source=Source.ASM,
                status=VulnerabilityStateStatus.OPEN,
            ),
            type=VulnerabilityType.INPUTS,
            where="https://example.com",
            commit=None,
        ),
    )
    assert test_data == expected_output


async def test_format_vulnerabilities() -> None:
    loaders: Dataloaders = get_new_context()
    finding_id = "422286126"
    finding_vulns = await loaders.finding_vulns_typed.load(finding_id)
    test_data = format_vulnerabilities(finding_vulns)
    expected_output = {
        "inputs": [
            {
                "url": "https://example.com",
                "field": "phone",
                "state": "open",
            }
        ],
        "lines": [
            {
                "commit_hash": "ea871eee64cfd5ce293411efaf4d3b446d04eb4a",
                "line": "12",
                "path": "test/data/lib_path/f060/csharp.cs",
                "state": "open",
            }
        ],
        "ports": [],
    }
    assert test_data == expected_output


async def test_load_vulnerabilities() -> None:
    loaders: Dataloaders = get_new_context()
    finding_ids = ["436992569", "422286126", "560175507"]
    test_data_delete_listed = list(
        chain.from_iterable(
            await loaders.finding_vulns_all_typed.load_many(finding_ids)
        )
    )
    test_data = await loaders.finding_vulns_typed.load_many_chained(
        finding_ids
    )
    assert isinstance(test_data, tuple)
    assert len(test_data_delete_listed) == 31
    assert len(test_data) == 30
    assert isinstance(test_data[0], Vulnerability)
    assert test_data[0] is not None


@pytest.mark.changes_db
async def test_update_vulnerability_state() -> None:
    vuln_id = "e248e8e0-0323-41c7-bc02-4ee61d09f9c4"
    user_email = "unittest@fluidattacks.com"
    request = await create_dummy_session(user_email)
    info = GraphQLResolveInfo(
        None, None, None, None, None, None, None, None, None, None, request
    )
    loaders: Dataloaders = info.context.loaders
    vuln: Vulnerability = await loaders.vulnerability_typed.load(vuln_id)
    assert vuln.state.status == VulnerabilityStateStatus.OPEN
    today = datetime_utils.get_iso_date()
    await update_state(
        current_value=vuln.state,
        finding_id=vuln.finding_id,
        vulnerability_id=vuln.id,
        state=VulnerabilityState(
            modified_by=user_email,
            modified_date=today,
            source=Source.ASM,
            status=VulnerabilityStateStatus.CLOSED,
        ),
    )
    loaders.vulnerability_typed.clear(vuln_id)
    closed_vuln: Vulnerability = await loaders.vulnerability_typed.load(
        vuln_id
    )
    assert closed_vuln.state.status == VulnerabilityStateStatus.CLOSED
    assert closed_vuln.state.modified_by == user_email


@pytest.mark.changes_db
async def test_get_updated_manager_mail_content() -> None:
    finding_id = "422286126"
    loaders = get_new_context()
    finding_vulns = await loaders.finding_vulns_all_typed.load(finding_id)
    grouped_vulns = group_vulnerabilities(finding_vulns)
    vulns_data = format_vulnerabilities(grouped_vulns)
    test_data = get_updated_manager_mail_content(vulns_data)
    expected_output = "- test/data/lib_path/f060/csharp.cs (12)\n- https://example.com (phone)\n"  # noqa
    assert test_data == expected_output


def test_ungroup_vulnerability_specific() -> None:
    vuln_type = "ports"
    specific = "4444"
    # FP: local testing
    data = {"where": "192.168.100.107", "state": "open"}  # NOSONAR
    test_data = ungroup_vulnerability_specific(vuln_type, specific, data)
    expected_output = [{**data, "specific": "4444"}]
    assert isinstance(test_data, list)
    assert test_data == expected_output


@pytest.mark.changes_db
async def test_verify_vulnerabilities() -> None:
    finding_id = "436992569"
    request = await create_dummy_session("unittest@fluidattacks.com")
    info = GraphQLResolveInfo(
        None, None, None, None, None, None, None, None, None, None, request
    )
    user_info = {
        "first_name": "Miguel",
        "last_name": "de Orellana",
        "user_email": "unittest@fluidattacks.com",
    }
    justification = "Vuln verified"
    open_vulns_ids = ["587c40de-09a0-4d85-a9f9-eaa46aa895d7"]
    closed_vulns_ids: List[str] = []
    test_data = await verify_vulnerabilities(
        context=info.context,
        finding_id=finding_id,
        user_info=user_info,
        justification=justification,
        open_vulns_ids=open_vulns_ids,
        closed_vulns_ids=closed_vulns_ids,
        vulns_to_close_from_file=[],
    )
    expected_output = True
    assert isinstance(test_data, bool)
    assert test_data == expected_output


async def test_validate_file_schema_invalid() -> None:
    finding_id = "463461507"
    request = await create_dummy_session("unittest@fluidattacks.com")
    info = GraphQLResolveInfo(
        None, None, None, None, None, None, None, None, None, None, request
    )
    # FP: the generated filename is unpredictable
    file_url = (
        f"/tmp/vulnerabilities-{uuid.uuid4()}-{finding_id}.yaml"  # NOSONAR
    )
    with open(file_url, "w", encoding="utf-8") as stream:
        yaml.safe_dump("", stream)
    with pytest.raises(InvalidSchema):  # NOQA
        await validate_file_schema(file_url, info)


async def test_get_vulnerabilities_file() -> None:
    context = get_new_context()
    finding_id = "988493279"
    group_name = "unittesting"
    assert (
        f"localhost:9000/fluidintegrates.reports/{group_name}-{finding_id}"
        in await get_vulnerabilities_file(context, finding_id, group_name)
    )


@freeze_time("2020-10-08")
@pytest.mark.parametrize(
    ["finding_id", "expected"],
    [
        ["988493279", True],
        ["463461507", False],
    ],
)
async def test_send_treatment_change_mail(
    finding_id: str, expected: bool
) -> None:
    context = get_new_context()
    group_name = "dummy"
    finding_title = "dummy"
    assert (
        await send_treatment_change_mail(
            context,
            finding_id,
            finding_title,
            group_name,
            get_now_minus_delta(days=1),
        )
        == expected
    )


@pytest.mark.parametrize(
    ["finding_id", "expected"],
    [
        ["988493279", [0, 1, 0, 0]],
        ["422286126", [0, 0, 1, 0]],
    ],
)
async def test_get_treatments(finding_id: str, expected: List[int]) -> None:
    context = get_new_context()
    finding_vulns_loader = context.finding_vulns_nzr_typed
    vulns = await finding_vulns_loader.load(finding_id)
    treatments = get_treatments_count(vulns)
    assert treatments.accepted == expected[0]
    assert treatments.accepted_undefined == expected[1]
    assert treatments.in_progress == expected[2]
    assert treatments.new == expected[3]


@freeze_time("2018-12-27")
async def test_get_total_treatment_stats() -> None:
    group_name = "unittesting"
    last_day = datetime_utils.get_now_minus_delta(hours=24)
    loaders = get_new_context()
    findings: Tuple[Finding, ...] = await loaders.group_findings.load(
        group_name
    )
    findings_ids = list(map(lambda finding: finding.id, findings))
    group_vulns = await loaders.finding_vulns_nzr_typed.load_many_chained(
        findings_ids
    )
    historics: Tuple[
        Tuple[VulnerabilityTreatment, ...], ...
    ] = await loaders.vulnerability_historic_treatment.load_many(
        [vuln.id for vuln in group_vulns]
    )
    treatment_stats = get_total_treatment_date(historics, last_day)
    expected_output = {
        "accepted": 3,
        "accepted_undefined_submitted": 1,
        "accepted_undefined_approved": 1,
        "undefined_treatment": 32,
    }
    assert expected_output == treatment_stats


@freeze_time("2018-12-27")
async def test_get_total_reattacks_stats() -> None:
    group_name = "unittesting"
    last_day = datetime_utils.get_now_minus_delta(hours=24)
    loaders = get_new_context()
    findings: Tuple[Finding, ...] = await loaders.group_findings.load(
        group_name
    )
    findings_ids = list(map(lambda finding: finding.id, findings))
    group_vulns = await loaders.finding_vulns_nzr_typed.load_many_chained(
        findings_ids
    )
    historics: Tuple[
        Tuple[VulnerabilityVerification, ...], ...
    ] = await loaders.vulnerability_historic_verification.load_many(
        [vuln.id for vuln in group_vulns]
    )
    reattacks_stats = get_total_reattacks_stats(
        group_vulns, historics, last_day
    )
    expected_output = {
        "effective_reattacks": 0,
        "effective_reattacks_total": 0,
        "reattacks_requested": 2,
        "last_requested_date": "2020-02-19 10:41:04",
        "reattacks_executed": 1,
        "reattacks_executed_total": 1,
        "last_executed_date": "2020-02-19 10:41:04",
        "pending_attacks": 1,
    }
    assert expected_output == reattacks_stats


@pytest.mark.changes_db
async def test_mask_vulnerability() -> None:
    masked: str = "Masked"
    vuln_id = "80d6a69f-a376-46be-98cd-2fdedcffdcc0"
    loaders: Dataloaders = get_new_context()
    vuln: Vulnerability = await loaders.vulnerability_typed.load(vuln_id)
    assert vuln.specific == "phone"
    assert vuln.where == "https://example.com"
    assert vuln.treatment == VulnerabilityTreatment(
        justification="This is a treatment justification",
        assigned="integratesuser@gmail.com",
        modified_by="integratescustomer@gmail.com",
        modified_date="2020-11-23T17:46:10+00:00",
        status=VulnerabilityTreatmentStatus.IN_PROGRESS,
    )
    assert await mask_vulnerability(
        loaders=loaders,
        finding_id=vuln.finding_id,
        vulnerability=vuln,
    )
    loaders.vulnerability_typed.clear(vuln_id)
    masked_vuln: Vulnerability = await loaders.vulnerability_typed.load(
        vuln_id
    )
    assert masked_vuln.specific == masked
    assert masked_vuln.where == masked
    assert masked_vuln.treatment == VulnerabilityTreatment(
        justification=masked,
        assigned=masked,
        modified_by="integratescustomer@gmail.com",
        modified_date="2020-11-23T17:46:10+00:00",
        status=VulnerabilityTreatmentStatus.IN_PROGRESS,
    )


async def test_adjust_historic_dates() -> None:
    historic = (
        VulnerabilityTreatment(
            modified_date="2021-12-12T00:00:01+00:00",
            status=VulnerabilityTreatmentStatus.NEW,
        ),
        VulnerabilityTreatment(
            modified_date="2021-12-12T00:00:01+00:00",
            status=VulnerabilityTreatmentStatus.IN_PROGRESS,
        ),
        VulnerabilityTreatment(
            modified_date="2021-01-01T00:00:00+00:00",
            status=VulnerabilityTreatmentStatus.ACCEPTED,
        ),
        VulnerabilityTreatment(
            modified_date="2021-12-30T14:35:01+00:00",
            status=VulnerabilityTreatmentStatus.ACCEPTED_UNDEFINED,
        ),
    )
    assert adjust_historic_dates(historic) == (
        VulnerabilityTreatment(
            modified_date="2021-12-12T00:00:01+00:00",
            status=VulnerabilityTreatmentStatus.NEW,
        ),
        VulnerabilityTreatment(
            modified_date="2021-12-12T00:00:02+00:00",
            status=VulnerabilityTreatmentStatus.IN_PROGRESS,
        ),
        VulnerabilityTreatment(
            modified_date="2021-12-12T00:00:03+00:00",
            status=VulnerabilityTreatmentStatus.ACCEPTED,
        ),
        VulnerabilityTreatment(
            modified_date="2021-12-30T14:35:01+00:00",
            status=VulnerabilityTreatmentStatus.ACCEPTED_UNDEFINED,
        ),
    )
