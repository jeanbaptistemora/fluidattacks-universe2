import type { MockedResponse } from "@apollo/client/testing";
import { MockedProvider } from "@apollo/client/testing";
import { PureAbility } from "@casl/ability";
import type { ReactWrapper } from "enzyme";
import { mount } from "enzyme";
import React from "react";
import { act } from "react-dom/test-utils";
import { MemoryRouter } from "react-router-dom";
import waitForExpect from "wait-for-expect";

import { AdditionalInformation } from ".";
import type { IVulnRowAttr } from "../types";
import { GET_VULN_ADDITIONAL_INFO } from "scenes/Dashboard/components/Vulnerabilities/AdditionalInfo/queries";
import { getLastTreatment } from "scenes/Dashboard/components/Vulnerabilities/UpdateDescription/utils";
import { authzPermissionsContext } from "utils/authz/config";
import { formatDropdownField } from "utils/formatHelpers";
import { translate } from "utils/translations/translate";

describe("AdditionalInformation", (): void => {
  const mockedPermissions: PureAbility<string> = new PureAbility([
    { action: "api_mutations_remove_vulnerability_tags_mutate" },
    { action: "api_mutations_request_vulnerabilities_zero_risk_mutate" },
    { action: "api_mutations_update_vulnerability_treatment_mutate" },
    { action: "api_mutations_update_vulnerabilities_treatment_mutate" },
  ]);
  const mock: IVulnRowAttr = {
    assigned: "",
    currentState: "open",
    currentStateCapitalized: "Open",
    externalBugTrackingSystem: null,
    historicTreatment: [
      {
        acceptanceDate: "",
        acceptanceStatus: "",
        assigned: "usertreatment@test.test",
        date: "2019-07-05 09:56:40",
        justification: "test progress justification",
        treatment: "IN PROGRESS",
        user: "usertreatment@test.test",
      },
    ],
    id: "89521e9a-b1a3-4047-a16e-15d530dc1340",
    lastTreatmentDate: "2019-07-05 09:56:40",
    lastVerificationDate: null,
    remediated: true,
    reportDate: "",
    severity: "3",
    specific: "specific-1",
    stream: null,
    tag: "tag-1, tag-2",
    treatment: translate.t(formatDropdownField("IN_PROGRESS")),
    treatmentAcceptanceStatus: "",
    treatmentAssigned: "",
    treatmentDate: "2019-07-05 09:56:40",
    treatmentJustification: "test progress justification",
    verification: "Requested",
    vulnerabilityType: "inputs",
    where: "https://example.com/inputs",
    zeroRisk: null,
  };

  const mockQueryVulnAdditionalInfo: MockedResponse = {
    request: {
      query: GET_VULN_ADDITIONAL_INFO,
      variables: {
        canRetrieveHacker: true,
        vulnId: "89521e9a-b1a3-4047-a16e-15d530dc1340",
      },
    },
    result: {
      data: {
        vulnerability: {
          __typename: "Vulnerability",
          commitHash: null,
          cycles: "1",
          efficacy: "0",
          hacker: "hacker@test.com",
          historicTreatment: [
            {
              treatment: "IN PROGRESS",
            },
          ],
          lastReattackRequester: "testrequester@test.com",
          lastRequestedReattackDate: null,
        },
      },
    },
  };

  it("should return a function", (): void => {
    expect.hasAssertions();

    expect(typeof AdditionalInformation).toStrictEqual("function");
  });

  it("should render vulnerabilities modal and keep info between tabs", async (): Promise<void> => {
    expect.hasAssertions();

    const onCloseAdditionalInfoModal: jest.Mock = jest.fn();
    const wrapper: ReactWrapper = mount(
      <MemoryRouter initialEntries={["/testgroup/vulns/480857698/locations"]}>
        <MockedProvider
          addTypename={false}
          mocks={[mockQueryVulnAdditionalInfo]}
        >
          <AdditionalInformation
            canDisplayHacker={true}
            canRemoveVulnsTags={true}
            canRequestZeroRiskVuln={true}
            canUpdateVulnsTreatment={true}
            clearSelectedVulns={jest.fn()}
            closeAdditionalInfoModal={onCloseAdditionalInfoModal}
            currentRow={mock}
            findingId={"480857698"}
            groupName={"testgroup"}
            isAdditionalInfoOpen={true}
            isFindingReleased={true}
          />
        </MockedProvider>
      </MemoryRouter>,
      {
        wrappingComponent: authzPermissionsContext.Provider,
        wrappingComponentProps: { value: mockedPermissions },
      }
    );

    const placeOfTreatment: number = 4;
    const placeOfJustification: number = 7;
    await act(async (): Promise<void> => {
      await waitForExpect((): void => {
        wrapper.update();

        expect(wrapper).toHaveLength(1);
        expect(wrapper.text()).toContain(
          translate.t(
            formatDropdownField(
              getLastTreatment(mock.historicTreatment).treatment
            )
          )
        );
        expect(
          wrapper.find("Value").at(placeOfJustification).text()
        ).toStrictEqual("test progress justification");
      });
    });

    wrapper
      .find({ id: "vulnerabilityTreatmentsTab" })
      .first()
      .find("a")
      .first()
      .simulate("click", { button: 0 });

    await act(async (): Promise<void> => {
      await waitForExpect((): void => {
        wrapper.update();

        expect(wrapper).toHaveLength(1);
        expect(
          wrapper.find({ name: "treatment" }).find("select").prop("value")
        ).toStrictEqual("IN_PROGRESS");
        expect(
          wrapper.find({ name: "justification" }).find("textarea").prop("value")
        ).toStrictEqual("");
      });
    });

    const treatment: ReactWrapper = wrapper
      .find({ name: "treatment" })
      .find("select")
      .first();
    treatment.simulate("change", {
      target: { name: "treatment", value: "ACCEPTED" },
    });

    const treatmentJustification: ReactWrapper = wrapper
      .find({ name: "justification" })
      .find("textarea")
      .at(0);
    treatmentJustification.simulate("change", {
      target: {
        name: "justification",
        value: "test justification to accepted treatment",
      },
    });

    wrapper
      .find({ id: "vulnerabilityDetailsTab" })
      .first()
      .find("a")
      .first()
      .simulate("click", { button: 0 });

    await act(async (): Promise<void> => {
      await waitForExpect((): void => {
        wrapper.update();

        expect(wrapper).toHaveLength(1);
        expect(wrapper.find("Value").at(placeOfTreatment).text()).toStrictEqual(
          translate.t(
            formatDropdownField(
              getLastTreatment(mock.historicTreatment).treatment
            )
          )
        );
        expect(
          wrapper.find("Value").at(placeOfJustification).text()
        ).toStrictEqual("test progress justification");
      });
    });

    wrapper
      .find({ id: "vulnerabilityTreatmentsTab" })
      .first()
      .find("a")
      .first()
      .simulate("click", { button: 0 });

    await act(async (): Promise<void> => {
      await waitForExpect((): void => {
        wrapper.update();

        expect(wrapper).toHaveLength(1);
        expect(
          wrapper.find({ name: "treatment" }).find("select").prop("value")
        ).toStrictEqual("ACCEPTED");
        expect(
          wrapper.find({ name: "justification" }).find("textarea").prop("value")
        ).toStrictEqual("test justification to accepted treatment");
      });
    });

    const closeButton: ReactWrapper = wrapper
      .find("Button")
      .filterWhere((element: ReactWrapper): boolean =>
        element.contains("Close")
      );
    closeButton.simulate("click");

    await act(async (): Promise<void> => {
      await waitForExpect((): void => {
        wrapper.update();

        expect(onCloseAdditionalInfoModal).toHaveBeenCalledTimes(1);
      });
    });
  });
});
