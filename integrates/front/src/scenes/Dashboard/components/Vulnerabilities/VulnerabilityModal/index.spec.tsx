import { MockedProvider } from "@apollo/client/testing";
import { PureAbility } from "@casl/ability";
import type { ReactWrapper } from "enzyme";
import { mount } from "enzyme";
import React from "react";
import { act } from "react-dom/test-utils";
import waitForExpect from "wait-for-expect";

import { AdditionalInformation } from ".";
import type { IVulnRowAttr } from "../types";
import { getLastTreatment } from "scenes/Dashboard/components/Vulnerabilities/UpdateDescription/utils";
import { authzPermissionsContext } from "utils/authz/config";
import { formatDropdownField } from "utils/formatHelpers";
import { translate } from "utils/translations/translate";

describe("AdditionalInformation", (): void => {
  const mockedPermissions: PureAbility<string> = new PureAbility([
    { action: "api_mutations_remove_vulnerability_tags_mutate" },
    { action: "api_mutations_request_vulnerabilities_zero_risk_mutate" },
    { action: "api_mutations_update_vulnerability_treatment_mutate" },
    { action: "api_mutations_update_vulnerabilities_treatment_mutate" },
  ]);
  const mock: IVulnRowAttr = {
    assigned: "",
    commitHash: null,
    currentState: "open",
    currentStateCapitalized: "Open",
    cycles: "1",
    efficacy: "0",
    externalBugTrackingSystem: null,
    historicTreatment: [
      {
        acceptanceDate: "",
        acceptanceStatus: "",
        assigned: "usertreatment@test.test",
        date: "2019-07-05 09:56:40",
        justification: "test progress justification",
        treatment: "IN PROGRESS",
        user: "usertreatment@test.test",
      },
    ],
    id: "89521e9a-b1a3-4047-a16e-15d530dc1340",
    lastReattackDate: null,
    lastReattackRequester: "testrequester@test.com",
    lastRequestedReattackDate: null,
    remediated: true,
    reportDate: "",
    severity: "3",
    specific: "specific-1",
    stream: null,
    tag: "tag-1, tag-2",
    treatment: translate.t(formatDropdownField("IN_PROGRESS")),
    treatmentChanges: 1,
    treatmentDate: "",
    verification: "Requested",
    vulnerabilityType: "inputs",
    where: "https://example.com/inputs",
    zeroRisk: null,
  };

  it("should return a function", (): void => {
    expect.hasAssertions();

    expect(typeof AdditionalInformation).toStrictEqual("function");
  });

  it("should render vulnerabilities modal and keep info between tabs", async (): Promise<void> => {
    expect.hasAssertions();

    const onCloseAdditionalInfoModal: jest.Mock = jest.fn();
    const wrapper: ReactWrapper = mount(
      <MockedProvider addTypename={false} mocks={[]}>
        <AdditionalInformation
          canDisplayHacker={true}
          canRemoveVulnsTags={true}
          canRequestZeroRiskVuln={true}
          canUpdateVulnsTreatment={true}
          clearSelectedVulns={jest.fn()}
          closeAdditionalInfoModal={onCloseAdditionalInfoModal}
          currentRow={mock}
          findingId={"480857698"}
          groupName={"testgroup"}
          isAdditionalInfoOpen={true}
          isFindingReleased={true}
        />
      </MockedProvider>,
      {
        wrappingComponent: authzPermissionsContext.Provider,
        wrappingComponentProps: { value: mockedPermissions },
      }
    );

    const placeOfTreatment: number = 4;
    const placeOfJustification: number = 7;
    await act(async (): Promise<void> => {
      await waitForExpect((): void => {
        wrapper.update();

        expect(wrapper).toHaveLength(1);
        expect(wrapper.find("Value").at(placeOfTreatment).text()).toStrictEqual(
          translate.t(
            formatDropdownField(
              getLastTreatment(mock.historicTreatment).treatment
            )
          )
        );
        expect(
          wrapper.find("Value").at(placeOfJustification).text()
        ).toStrictEqual("test progress justification");
      });
    });

    wrapper
      .find({ id: "vulnerabilityTreatmentsTab" })
      .first()
      .find("a")
      .first()
      .simulate("click", { button: 0 });

    await act(async (): Promise<void> => {
      await waitForExpect((): void => {
        wrapper.update();

        expect(wrapper).toHaveLength(1);
        expect(
          wrapper.find({ name: "treatment" }).find("select").prop("value")
        ).toStrictEqual("IN_PROGRESS");
        expect(
          wrapper.find({ name: "justification" }).find("textarea").prop("value")
        ).toStrictEqual("");
      });
    });

    const treatment: ReactWrapper = wrapper
      .find({ name: "treatment" })
      .find("select")
      .first();
    treatment.simulate("change", {
      target: { name: "treatment", value: "ACCEPTED" },
    });

    const treatmentJustification: ReactWrapper = wrapper
      .find({ name: "justification" })
      .find("textarea")
      .at(0);
    treatmentJustification.simulate("change", {
      target: {
        name: "justification",
        value: "test justification to accepted treatment",
      },
    });

    wrapper
      .find({ id: "vulnerabilityDetailsTab" })
      .first()
      .find("a")
      .first()
      .simulate("click", { button: 0 });

    await act(async (): Promise<void> => {
      await waitForExpect((): void => {
        wrapper.update();

        expect(wrapper).toHaveLength(1);
        expect(wrapper.find("Value").at(placeOfTreatment).text()).toStrictEqual(
          translate.t(
            formatDropdownField(
              getLastTreatment(mock.historicTreatment).treatment
            )
          )
        );
        expect(
          wrapper.find("Value").at(placeOfJustification).text()
        ).toStrictEqual("test progress justification");
      });
    });

    wrapper
      .find({ id: "vulnerabilityTreatmentsTab" })
      .first()
      .find("a")
      .first()
      .simulate("click", { button: 0 });

    await act(async (): Promise<void> => {
      await waitForExpect((): void => {
        wrapper.update();

        expect(wrapper).toHaveLength(1);
        expect(
          wrapper.find({ name: "treatment" }).find("select").prop("value")
        ).toStrictEqual("ACCEPTED");
        expect(
          wrapper.find({ name: "justification" }).find("textarea").prop("value")
        ).toStrictEqual("test justification to accepted treatment");
      });
    });

    const closeButton: ReactWrapper = wrapper
      .find("Button")
      .filterWhere((element: ReactWrapper): boolean =>
        element.contains("Close")
      );
    closeButton.simulate("click");

    await act(async (): Promise<void> => {
      await waitForExpect((): void => {
        wrapper.update();

        expect(onCloseAdditionalInfoModal).toHaveBeenCalledTimes(1);
      });
    });
  });
});
