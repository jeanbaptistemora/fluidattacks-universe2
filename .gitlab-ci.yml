image: registry.gitlab.com/fluidsignal/serves:builder

variables:
  DOCKER_DRIVER: overlay2

services:
   - docker:dind


before_script:
  - echo "$CI_REGISTRY_PASSWORD" |
        docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin

after_script:
  - docker logout "$CI_REGISTRY"

stages:
  - deps
  - test-infra
  - build
  - tag
  - deploy
  - dns

build_base:
  stage: deps
  script:
    - sh containers/base/build.sh
    - docker push
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:base"
  except:
    - master

build_builder:
  stage: deps
  script:
    - docker build
        --cache-from "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:builder"
        -t "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:builder"
        containers/builder/
    - docker push
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:builder"
  except:
    - master

test_terraform:
  stage: test-infra
  before_script:
    - mkdir infrastructure/vars
    - cd infrastructure
    - torus run -- ./set-tfvars.sh
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/terraform.tfstate
        terraform.tfstate || echo "No previous state for infrastructure found"
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/dns/terraform.tfstate
        dns/terraform.tfstate || echo "No previous state for DNS found"
    - cp vars/aws.tfvars dns/
  script:
    - terraform init
    - tflint --var-file="vars/aws.tfvars"
    - terraform plan -var-file="vars/aws.tfvars"
    - terraform output variable_ip >> dns/terraform.tfvars
    - terraform output variable_db >> dns/terraform.tfvars
    - terraform output variable_web >> dns/terraform.tfvars
    - terraform output variable_integrates >> dns/terraform.tfvars
    - cd dns/
    - export TF_VAR_ELB_DNS="$(aws elb --region us-east-1
        describe-load-balancers |
        jq -r '.LoadBalancerDescriptions[].DNSName')"
    - export TF_VAR_ELB_ZONE="$(aws elb --region us-east-1
        describe-load-balancers |
        jq -r '.LoadBalancerDescriptions[].CanonicalHostedZoneNameID')"
    - terraform init
    - terraform plan -var-file="aws.tfvars"
  after_script:
    - rm -rf infrastructure/vars
    - rm -rf infrastructure/terraform.tfvars
    - rm -rf infrastructure/dns/aws.tfvars
    - rm -rf infrastructure/dns/terraform.tfvars
  except:
    - master

build_alg:
  stage: build
  script:
    - torus run -- sh containers/alg/build.sh
    - docker push
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/alg/dev:$CI_COMMIT_SHA"
  except:
    - master

build_exams:
  stage: build
  script:
    - torus run -- sh containers/exams/build.sh
    - docker push
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/exams/dev:$CI_COMMIT_SHA"
  except:
    - master

build_vpn:
  stage: build
  script:
    - torus run -- sh containers/vpn/build.sh
    - docker push
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/vpn/dev:$CI_COMMIT_SHA"
  except:
    - master

tag-alg:
  stage: tag
  script:
    - docker pull
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/alg/dev:$CI_COMMIT_SHA"
    - docker tag
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/alg/dev:$CI_COMMIT_SHA"
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/alg:master"
    - docker push
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/alg:master"
  only:
    - master

tag-exams:
  stage: tag
  script:
    - docker pull
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/exams/dev:$CI_COMMIT_SHA"
    - docker tag
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/exams/dev:$CI_COMMIT_SHA"
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/exams:master"
    - docker push
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/exams:master"
  only:
    - master

tag-vpn:
  stage: tag
  script:
    - docker pull
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/vpn/dev:$CI_COMMIT_SHA"
    - docker tag
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/vpn/dev:$CI_COMMIT_SHA"
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/vpn:master"
    - docker push
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/vpn:master"
  only:
    - master

deploy_infra:
  stage: deploy
  before_script:
    - mkdir infrastructure/vars
    - mkdir -p $HOME/.kube
    - echo sudo docker login "$CI_REGISTRY"
        -u "$DOCKER_USER" -p "$DOCKER_PASS" >> infrastructure/ec2/host/script.sh
    - cd infrastructure
    - torus run -- ./set-tfvars.sh
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/FLUID_Serves.pem
        vars/FLUID_Serves.pem ||
        (pip install boto && python infrastructure/create-key.py && export
        NEW_DEPLOY=true)
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/terraform.tfstate
        terraform.tfstate || echo "No previous state found"
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/kubeconfig
        $HOME/.kube/config || echo "No Kubernetes configuration file found"
  script:
    - terraform init
    - torus run -- terraform apply -auto-approve -var-file="vars/aws.tfvars"
    - terraform output instance_ip > ip.txt
    - torus run -- ./eks/manifests/deploy.sh
    - sh set-keys.sh
    - if [ -n "${NEW_DEPLOY}" ]; then
            git clone https://github.com/checkr/s3-sync.git;
            fi
    - if [ -n "${NEW_DEPLOY}" ]; then
            sh create-config.sh && cd s3-sync && \
            go run main.go sync --config ./config-prod.yaml;
            fi
  after_script:
    - aws s3 cp
        infrastructure/terraform.tfstate
        s3://$FS_S3_BUCKET_NAME/terraform/terraform.tfstate
    - aws s3 cp
        $HOME/.kube/config
        s3://$FS_S3_BUCKET_NAME/terraform/kubeconfig
    - aws s3 cp
        infrastructure/vars/FLUID_Serves.pem
        s3://$FS_S3_BUCKET_NAME/terraform/FLUID_Serves.pem
    - rm -rf infrastructure/vars
    - rm -rf infrastructure/terraform.tfvars
  artifacts:
    paths:
      - infrastructure/ip.txt
    expire_in: 12 hrs
    when: on_success
  only:
    - master

# install_alg:
#   stage: install
#   dependencies:
#     - deploy_terraform
#   before_script:
#     - aws s3 cp
#         s3://$FS_S3_BUCKET_NAME/terraform/FLUID_Serves.pem
#         infrastructure/FLUID_Serves.pem
#     - cd infrastructure
#   script:
#     - chmod 600 FLUID_Serves.pem
#     - ssh
#         -o StrictHostKeyChecking=no
#         -i FLUID_Serves.pem
#         admin@$(cat ip.txt)
#         'sudo docker pull
#         registry.gitlab.com/fluidsignal/serves/alg:master &&
#         (sudo docker stop tmp_alg_1 || echo "") &&
#         (sudo docker rm tmp_alg_1 || echo "")'
#     - ssh
#         -o StrictHostKeyChecking=no
#         -i FLUID_Serves.pem
#         admin@$(cat ip.txt)
#         'sudo docker run -d -p 443:443 -p 80:80 --name=tmp_alg_1
#         registry.gitlab.com/fluidsignal/serves/alg:master'
#   only:
#     - master

# install_exams:
#   stage: install
#   dependencies:
#     - deploy_terraform
#   before_script:
#     - aws s3 cp
#         s3://$FS_S3_BUCKET_NAME/terraform/FLUID_Serves.pem
#         infrastructure/FLUID_Serves.pem
#     - cd infrastructure
#   script:
#     - chmod 600 FLUID_Serves.pem
#     - ssh
#         -o StrictHostKeyChecking=no
#         -i FLUID_Serves.pem
#         admin@$(cat ip.txt)
#         'sudo docker pull
#         registry.gitlab.com/fluidsignal/serves/exams:master &&
#         (sudo docker stop tmp_exams_1 || echo "") &&
#         (sudo docker rm tmp_exams_1 || echo "")'
#     - ssh
#         -o StrictHostKeyChecking=no
#         -i FLUID_Serves.pem
#         admin@$(cat ip.txt)
#         'sudo docker run -d -p 8080:80 --name=tmp_exams_1
#         registry.gitlab.com/fluidsignal/serves/exams:master'
#   only:
#     - master

# install_integrates:
#   stage: install
#   dependencies:
#     - deploy_terraform
#   before_script:
#     - aws s3 cp
#         s3://$FS_S3_BUCKET_NAME/terraform/FLUID_Serves.pem
#         infrastructure/FLUID_Serves.pem
#     - cd infrastructure
#   script:
#     - chmod 600 FLUID_Serves.pem
#     - ssh
#         -o StrictHostKeyChecking=no
#         -i FLUID_Serves.pem
#         admin@$(cat ip.txt)
#         'sudo docker pull
#         registry.gitlab.com/fluidsignal/integrates:master &&
#         (sudo docker stop integrates || echo true) &&
#         (sudo docker rm integrates || echo true) &&
#         sudo docker run
#         -d -p 8000:443 --name=integrates
#         -e TORUS_TOKEN_SECRET='"$FI_TORUS_TOKEN_SECRET"'
#         -e TORUS_TOKEN_ID='"$FI_TORUS_TOKEN_ID"'
#         registry.gitlab.com/fluidsignal/integrates:master'
#     - ssh
#         -o StrictHostKeyChecking=no
#         -i FLUID_Serves.pem
#         admin@$(cat ip.txt)
#         'sudo docker pull
#         registry.gitlab.com/fluidsignal/integrates/bot:master &&
#         (sudo docker stop bot || echo true) &&
#         (sudo docker rm bot || echo true) &&
#         sudo docker run
#         -d --restart always --name=bot
#         -e TORUS_TOKEN_SECRET='"$FI_TORUS_TOKEN_SECRET"'
#         -e TORUS_TOKEN_ID='"$FI_TORUS_TOKEN_ID"'
#         registry.gitlab.com/fluidsignal/integrates/bot:master'
#   only:
#     - master

# install_vpn:
#   stage: install
#   dependencies:
#     - deploy_terraform
#   before_script:
#     - aws s3 cp
#         s3://$FS_S3_BUCKET_NAME/terraform/FLUID_Serves.pem
#         infrastructure/FLUID_Serves.pem
#     - cd infrastructure
#   script:
#     - chmod 600 FLUID_Serves.pem
#     - ssh
#         -o StrictHostKeyChecking=no
#         -i FLUID_Serves.pem
#         admin@$(cat ip.txt)
#         'sudo docker pull
#         registry.gitlab.com/fluidsignal/serves/vpn:master &&
#         (sudo docker stop tmp_vpn_1 || echo "") &&
#         (sudo docker rm tmp_vpn_1 || echo "")'
#     - ssh
#         -o StrictHostKeyChecking=no
#         -i FLUID_Serves.pem
#         admin@$(cat ip.txt)
#         'sudo docker run
#         -d --privileged=true -p 8081:443 --name=tmp_vpn_1
#         registry.gitlab.com/fluidsignal/serves/vpn:master'
#   only:
#     - master

# install_web:
#   stage: install
#   dependencies: []
#   script:
#     - docker pull
#         "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/web:master"
#     - docker run
#         -e AWS_ACCESS_KEY_ID="$FW_AWS_ACCESS_KEY_ID"
#         -e AWS_SECRET_ACCESS_KEY="$FW_AWS_SECRET_ACCESS_KEY"
#         -e S3_BUCKET_NAME="$FW_S3_BUCKET_NAME"
#         "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/web:master"
#         bash -c "./deploy.sh"
#     - docker logout "$CI_REGISTRY"
#   only:
#     - master

change_dns:
  stage: dns
  dependencies: []
  before_script:
    - mkdir infrastructure/vars
    - cd infrastructure
    - torus run -- ./set-tfvars.sh
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/FLUID_Serves.pem
        vars/FLUID_Serves.pem
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/terraform.tfstate
        terraform.tfstate
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/dns/terraform.tfstate
        dns/terraform.tfstate || echo ""
    - cp vars/aws.tfvars dns/
    - terraform init
    - terraform refresh -var-file="vars/aws.tfvars" > /dev/null
    - terraform output variable_ip >> dns/terraform.tfvars
    - terraform output variable_db >> dns/terraform.tfvars
    - terraform output variable_web >> dns/terraform.tfvars
    - terraform output variable_integrates >> dns/terraform.tfvars
  script:
    - cd dns/
    - export TF_VAR_ELB_DNS="$(aws elb --region us-east-1
        describe-load-balancers |
        jq -r '.LoadBalancerDescriptions[].DNSName')"
    - export TF_VAR_ELB_ZONE="$(aws elb --region us-east-1
        describe-load-balancers |
        jq -r '.LoadBalancerDescriptions[].CanonicalHostedZoneNameID')"
    - terraform init
    - terraform apply -auto-approve -var-file="aws.tfvars";
  after_script:
    - aws s3 cp
        infrastructure/dns/terraform.tfstate
        s3://$FS_S3_BUCKET_NAME/terraform/dns/terraform.tfstate
    - rm -rf infrastructure/dns/aws.tfvars
    - rm -rf infrastructure/vars
    - rm -rf infrastructure/terraform.tfvars
  only:
    - master
