image: registry.gitlab.com/fluidattacks/web:base

stages:
  - build
  - check
  - review
  - mr-check
  - deployment
  - postdeploy

.vault_vars: &vault_vars
  variables:
    VAULT_HOST: "${VAULT_S3_BUCKET}.com"
    VAULT_ADDR: "https://${VAULT_S3_BUCKET}.com"
    VAULT_PORT: 443
    VAULT_API_URL: "https://${VAULT_S3_BUCKET}.com/v1"
    ROLE_ID: "${WEB_ROLE_ID}"
    SECRET_ID: "${WEB_SECRET_ID}"
    VAULTENV_SECRETS_FILE: "${CI_PROJECT_DIR}/env.vars"

.fa_default_registry_vars: &fa_default_registry_vars
  variables:
    CI_REGISTRY_USER: "${GITLAB_USER}"
    CI_REGISTRY_PASSWORD: "${GITLAB_PASS}"
    CI_REGISTRY_EMAIL: "${GITLAB_EMAIL}"
    CI_REGISTRY_IMAGE: "${CI_REGISTRY}/fluidsignal/default/web"

.vault_login: &vault_login
  <<: *vault_vars
  before_script:
    - export VAULT_TOKEN=$(curl
        --request POST
        --data '{"role_id":"'"${ROLE_ID}"'","secret_id":"'"${SECRET_ID}"'"}'
        "${VAULT_API_URL}/auth/approle/login" | jq -r '.auth.client_token')

.kaniko_config: &kaniko_config
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  before_script:
    - echo '{"auths":{"'"${CI_REGISTRY}"'":{"username":"'"${CI_REGISTRY_USER}"'","password":"'"${CI_REGISTRY_PASSWORD}"'"}}}'
        > /kaniko/.docker/config.json

.kaniko_fa_default_registry_config: &kaniko_fa_default_registry_config
  <<: *fa_default_registry_vars
  <<: *kaniko_config

builder:
  tags: [autoscaling]
  stage: build
  <<: *kaniko_config
  script:
    - /kaniko/executor
        --verbosity warn
        --cache=true
        --cache-repo "${CI_REGISTRY_IMAGE}/cache"
        --cleanup
        --context "${CI_PROJECT_DIR}/builder/base/"
        --dockerfile "${CI_PROJECT_DIR}/builder/base/Dockerfile"
        --destination "${CI_REGISTRY_IMAGE}:base"

content:
  tags: [autoscaling]
  stage: check
  script:
    - pre-commit run --all-files
    - ./check-changed.sh
    - python3 ci-scripts/checkall.py changes
    - python3 ci-scripts/imgchecker.py
  except:
    - master

pelican:
  tags: [autoscaling-large]
  stage: check
  <<: *kaniko_fa_default_registry_config
  script:
    - /kaniko/executor
        --build-arg CI_COMMIT_REF_NAME="${CI_COMMIT_REF_NAME}"
        --build-arg CI_PROJECT_NAME="${CI_PROJECT_NAME}"
        --build-arg CI_PROJECT_NAMESPACE="${CI_PROJECT_NAMESPACE}"
        --build-arg CI_REPOSITORY_URL="${CI_REPOSITORY_URL}"
        --build-arg ENV_DNS="${ENV_DNS}"
        --build-arg REGISTRY_IMAGE="${CI_REGISTRY_IMAGE}/review"
        --verbosity warn
        --cleanup
        --context "${CI_PROJECT_DIR}/review/"
        --dockerfile "${CI_PROJECT_DIR}/review/Dockerfile"
        --destination "${CI_REGISTRY_IMAGE}/review:${CI_COMMIT_REF_SLUG}"
      ||
      ( sed -i '/as cache/d; /from=cache/d; s/from=1/from=0/g'  review/Dockerfile &&
        /kaniko/executor
          --build-arg CI_COMMIT_REF_NAME="${CI_COMMIT_REF_NAME}"
          --build-arg CI_PROJECT_NAME="${CI_PROJECT_NAME}"
          --build-arg CI_PROJECT_NAMESPACE="${CI_PROJECT_NAMESPACE}"
          --build-arg CI_REPOSITORY_URL="${CI_REPOSITORY_URL}"
          --build-arg ENV_DNS="${ENV_DNS}"
          --build-arg REGISTRY_IMAGE="${CI_REGISTRY_IMAGE}/review"
          --verbosity warn
          --cleanup
          --context "${CI_PROJECT_DIR}/review/"
          --dockerfile "${CI_PROJECT_DIR}/review/Dockerfile"
          --destination "${CI_REGISTRY_IMAGE}/review:${CI_COMMIT_REF_SLUG}" )
  except:
    - master

commitlint:
  tags: [autoscaling]
  stage: check
  image: starefossen/ruby-node:2-10
  before_script:
    - npm install --unsafe-perm
  script:
    - ./ci-scripts/commitlint-checks.sh
  except:
    - master

review-web:
  tags: [autoscaling]
  stage: review
  <<: *fa_default_registry_vars
  image: registry.gitlab.com/fluidattacks/web:base
  script:
    - ./review/cluster-config.sh
  environment:
    name: review/${CI_COMMIT_REF_SLUG}
    url: https://${CI_PROJECT_NAME}.${ENV_DNS}/${CI_COMMIT_REF_SLUG}/web/
    on_stop: stop-review
  except:
    - master

stop-review:
  tags: [autoscaling]
  stage: review
  image: registry.gitlab.com/fluidattacks/web:base
  variables:
    GIT_STRATEGY: none
  script:
    - kubectl config set-context
        "$(kubectl config current-context)"
        --namespace="${CI_PROJECT_NAME}"
    - kubectl delete deployment "review-${CI_COMMIT_REF_SLUG}"
    - kubectl delete service "service-${CI_COMMIT_REF_SLUG}"
    - kubectl get ingress "ingress-${CI_PROJECT_NAME}" -o yaml
        | tac | sed '/path:\ \/'"${CI_COMMIT_REF_SLUG}"'/,+3d'
        | tac > current-ingress.yaml
    - kubectl delete ingress "ingress-${CI_PROJECT_NAME}"
    - if
        kubectl get deployments | grep 'review-*';
        then kubectl create -f current-ingress.yaml;
      fi
  when: manual
  environment:
    name: review/${CI_COMMIT_REF_SLUG}
    action: stop
  except:
    - master

mr-test:
  tags: [autoscaling]
  stage: mr-check
  image: registry.gitlab.com/fluidattacks/web:base
  only:
    - merge_requests
  variables:
    GIT_STRATEGY: clone
  script:
    ./ci-scripts/check-branch.sh

danger:
  tags: [autoscaling]
  stage: mr-check
  image: fluidattacks/danger-ruby
  only:
    - merge_requests
  variables:
    DANGER_GITLAB_API_TOKEN: $DANGER_TOKEN
  before_script:
    - export CI_MERGE_REQUEST_ID=$(git ls-remote -q origin merge-requests\*\head
      | grep ${CI_COMMIT_SHA}
      | sed 's/.*refs\/merge-requests\/\([0-9]*\)\/head/\1/g')
    - npm install --unsafe-perm
  script:
    - danger --verbose --fail-on-errors=true

deploy:
  tags: [autoscaling]
  stage: deployment
  <<: *vault_login
  script:
    - if curl --fail -Lo artifacts.zip
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/jobs/artifacts/${CI_COMMIT_REF_NAME}/download?job=${CI_JOB_NAME}&job_token=${CI_JOB_TOKEN}"; then
          unzip artifacts.zip 'cache/*' -d .;
          rm artifacts.zip;
        else
          echo "There are no artifacts";
      fi
    - for FILE in $(find content/blog content/pages -iname '*.adoc'); do
        sed -i 's#^include::#include::'"${CI_PROJECT_DIR/\/web/}"'#g' ${FILE};
      done
    - ./build-site.sh
    - export AWS_ACCESS_KEY_ID="$(vault read -field=aws_s3_access_key secret/web)"
    - export AWS_SECRET_ACCESS_KEY="$(vault read -field=aws_s3_secret_key secret/web)"
    - export S3_BUCKET_NAME="$(vault read -field=aws_s3_bucket secret/web)"
    - ./deploy.sh
    - ./amz-redirect.sh
    - rm -rf output
  artifacts:
    untracked: true
    when: on_success
    expire_in: 18 hrs
    paths:
      - cache/
  only:
    - master

new_version_mail:
  tags: [autoscaling]
  stage: postdeploy
  image: registry.gitlab.com/fluidattacks/web:base
  <<: *vault_login
  script:
    - export MANDRILL_APIKEY=$(vault read -field=mandrill_apikey secret/web)
    - export MANDRILL_EMAIL_TO=$(vault read -field=mandrill_email_to secret/web)
    - curl -Lo mail.py https://gitlab.com/fluidattacks/default/raw/master/shared-scripts/mail.py
    - "echo \"send_mail('new_version',
        MANDRILL_EMAIL_TO,
        context={'project': PROJECT, 'project_url': 'https://fluidattacks.com',
          'version': _get_version_date(), 'message': _get_message()},
        tags=['general'])\" >> mail.py"
    - python3 mail.py
  only:
    - master
  except:
    - schedules
