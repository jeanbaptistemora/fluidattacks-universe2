# pylint: disable=import-error

from typing import List, cast, Dict

from asgiref.sync import sync_to_async
from django.core.files.uploadedfile import (
    InMemoryUploadedFile, TemporaryUploadedFile
)
from magic import Magic
from backend.decorators import (
    enforce_group_level_auth_async, require_login, require_finding_access
)
from backend.domain.project import get_finding_project_name
from backend.domain.vulnerability import (
    delete_tags, delete_vulnerability, process_file, request_verification,
    update_approval_status, update_last_vuln_date, update_all_pending_vulns,
    update_treatments, verify_vulnerabilities
)
from backend.exceptions import (
    ErrorUploadingFileS3, InvalidFileSize,
    InvalidFileType, InvalidSeverity
)
from backend.domain import finding as finding_domain
from backend.services import is_customeradmin
from backend import util

from ariadne import convert_kwargs_to_snake_case


@convert_kwargs_to_snake_case
@require_login
@enforce_group_level_auth_async
@require_finding_access
def resolve_approve_vulnerability(
        _, info, finding_id: str, approval_status: str, uuid: str = '') -> \
        Dict[str, bool]:
    """Resolve approve_vulnerability mutation."""
    return util.run_async(
        _resolve_approve_vulnerability,
        info, finding_id, approval_status, uuid
    )


@sync_to_async
def _resolve_approve_vulnerability(info, finding_id: str, approval_status: str,
                                   uuid: str = '') -> Dict[str, bool]:
    """Resolve approve_vulnerability mutation."""
    project_name = get_finding_project_name(finding_id)
    success = False
    if uuid:
        success = update_approval_status(
            finding_id, uuid, approval_status)
    else:
        success = update_all_pending_vulns(finding_id, approval_status)
    if success:
        update_last_vuln_date(finding_id)
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project_name)
        util.cloudwatch_log(
            info.context, 'Security: Approve vulnerability from {project}\
                project succesfully'.format(
                project=project_name))
    else:
        util.cloudwatch_log(info.context, 'Security: Attempted to approve\
            vulnerability from {project} project'.format(
            project=project_name))
    return dict(success=success)


@convert_kwargs_to_snake_case
@require_login
@enforce_group_level_auth_async
@require_finding_access
def resolve_delete_tags(_, info, finding_id: str,
                        vulnerabilities: List) -> Dict[str, bool]:
    """Resolve delete_tags mutation."""
    return util.run_async(
        _resolve_delete_tags,
        info, finding_id, vulnerabilities
    )


@sync_to_async
def _resolve_delete_tags(info, finding_id: str,
                         vulnerabilities: List) -> Dict[str, bool]:
    """Resolve delete_tags mutation."""
    project_name = get_finding_project_name(finding_id)
    success = delete_tags(finding_id, cast(List[str], vulnerabilities))
    if success:
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project_name)
        util.cloudwatch_log(
            info.context, f'Delete tags from {finding_id}')
    return dict(success=success)


@convert_kwargs_to_snake_case
@require_login
@enforce_group_level_auth_async
@require_finding_access
def resolve_update_treatment_vuln(_, info, **parameters) -> Dict[str, bool]:
    """Resolve update_treatment_vuln mutation."""
    return util.run_async(
        _resolve_update_treatment_vuln,
        info, **parameters
    )


@sync_to_async
def _resolve_update_treatment_vuln(info, **parameters) -> Dict[str, bool]:
    """Resolve update_treatment_vuln mutation."""
    min_value = 0
    max_value = 1000000000
    vulnerabilities = parameters.get('vulnerabilities', [])
    finding_id = parameters.get('finding_id', '')
    severity = parameters.get('severity')
    if severity and severity != -1:
        if min_value > severity > max_value:
            raise InvalidSeverity([min_value, max_value])
    user_data = util.get_jwt_content(info.context)
    project_name = cast(str,
                        finding_domain.get_finding(finding_id)['projectName'])
    is_customer_admin = is_customeradmin(project_name, user_data['user_email'])
    result_update_vuln = update_treatments(vulnerabilities, finding_id,
                                           parameters, info, is_customer_admin)
    if result_update_vuln:
        util.invalidate_cache(finding_id)
    return dict(success=result_update_vuln)


@convert_kwargs_to_snake_case
@require_login
@enforce_group_level_auth_async
@require_finding_access
def resolve_request_verification_vuln(
        _, info, finding_id: str, justification: str,
        vulnerabilities: List[str]) -> Dict[str, bool]:
    """Resolve request_verification_vuln mutation."""
    return util.run_async(
        _resolve_request_verification_vuln,
        info, finding_id, justification, vulnerabilities
    )


@sync_to_async
def _resolve_request_verification_vuln(
        info, finding_id: str, justification: str,
        vulnerabilities: List[str]) -> Dict[str, bool]:
    """Resolve request_verification_vuln mutation."""
    project_name = get_finding_project_name(finding_id)
    user_info = util.get_jwt_content(info.context)
    success = request_verification(
        finding_id,
        user_info['user_email'],
        str.join(' ', [user_info.get('first_name', ''),
                       user_info.get('last_name', '')]),
        justification,
        cast(List[str], vulnerabilities)
    )
    if success:
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project_name)
        util.cloudwatch_log(info.context, 'Security: Verified a request '
                            f'in finding_id: {finding_id}')
    return dict(success=success)


@convert_kwargs_to_snake_case
@require_login
@enforce_group_level_auth_async
@require_finding_access
def resolve_verify_request_vuln(_, info, **parameters) -> Dict[str, bool]:
    """Resolve verify_request_vuln mutation."""
    return util.run_async(
        _resolve_verify_request_vuln,
        info, **parameters
    )


@sync_to_async
def _resolve_verify_request_vuln(info, **parameters) -> Dict[str, bool]:
    """Resolve verify_request_vuln mutation."""
    finding_id = parameters.get('finding_id', '')
    project_name = get_finding_project_name(finding_id)
    user_info = util.get_jwt_content(info.context)
    success = verify_vulnerabilities(
        finding_id,
        user_info['user_email'],
        str.join(' ', [user_info.get('first_name', ''),
                       user_info.get('last_name', '')]),
        info,
        parameters
    )
    if success:
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project_name)
        util.cloudwatch_log(info.context, 'Security: Verified a request '
                            f'in finding_id: {finding_id}')
    return dict(success=success)


@convert_kwargs_to_snake_case
@require_login
@enforce_group_level_auth_async
@require_finding_access
def resolve_delete_vulnerability(_, info, **kwargs) -> Dict[str, bool]:
    """Resolve delete_vulnerability mutation."""
    return util.run_async(
        _resolve_delete_vulnerability,
        info, **kwargs
    )


@sync_to_async
def _resolve_delete_vulnerability(info, **kwargs) -> Dict[str, bool]:
    """Resolve delete_vulnerability mutation."""
    finding_id = kwargs.get('finding_id', '')
    uuid = kwargs.get('id', '')
    justification = kwargs.get('justification', '')
    project = get_finding_project_name(finding_id)
    user_email = util.get_jwt_content(info.context).get('user_email', '')
    success = delete_vulnerability(
        finding_id, uuid, justification, user_email)

    if success:
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project)
        util.cloudwatch_log(
            info.context, f'Security: Deleted vulnerability: {uuid} '
            f'from {project} project succesfully')
    else:
        util.cloudwatch_log(
            info.context, 'Security: Attempted to delete vulnerability: '
            f'{uuid} from {project} project')
    return dict(success=success)


@convert_kwargs_to_snake_case
@require_login
@enforce_group_level_auth_async
@require_finding_access
def resolve_upload_file(_, info, **kwargs) -> Dict[str, bool]:
    """Resolve upload_file mutation."""
    return util.run_async(
        _resolve_upload_file,
        info, **kwargs
    )


@sync_to_async
def _resolve_upload_file(info, **kwargs) -> Dict[str, bool]:
    """Resolve upload_file mutation."""
    finding_id = kwargs.get('finding_id', '')
    file_input = kwargs.get('file')
    origin = kwargs.get('origin', '')
    project = finding_domain.get_project(finding_id)
    mime = Magic(mime=True)
    if isinstance(file_input, TemporaryUploadedFile):
        mime_type = mime.from_file(file_input.temporary_file_path())
    elif isinstance(file_input, InMemoryUploadedFile):
        mime_type = mime.from_buffer(file_input.file.getvalue())
    else:
        mime_type = ''
    mib = 1048576
    if (file_input and
            mime_type in ['text/x-yaml', 'text/plain', 'text/html']):
        if file_input.size < 1 * mib:
            success = process_file(file_input, finding_id, info, origin)
        else:
            raise InvalidFileSize()
    else:
        raise InvalidFileType()
    if success:
        update_last_vuln_date(finding_id)
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project)
        util.cloudwatch_log(
            info.context, 'Security: Uploaded file in {project} \
project succesfully'.format(project=project))
    else:
        util.cloudwatch_log(info.context,
                            'Security: Attempted to delete file \
            from {project} project'.format(project=project))
        raise ErrorUploadingFileS3()
    return dict(success=success)
