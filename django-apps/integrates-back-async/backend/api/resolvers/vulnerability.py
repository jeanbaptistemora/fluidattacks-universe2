# pylint: disable=import-error

from typing import List, cast

from backend.decorators import (
    enforce_authz_async, require_login, require_finding_access
)
from backend.domain.project import get_finding_project_name
from backend.domain.vulnerability import (
    delete_tags, request_verification, update_approval_status,
    update_last_vuln_date, update_all_pending_vulns, update_treatments,
    verify_vulnerabilities
)
from backend.exceptions import InvalidSeverity
from backend.domain import finding as finding_domain
from backend.services import is_customeradmin
from backend import util

from ariadne import convert_kwargs_to_snake_case


@convert_kwargs_to_snake_case
@require_login
@enforce_authz_async
@require_finding_access
def resolve_approve_vulnerability(
    _, info, finding_id: str, approval_status: str, uuid: str = ''
) -> object:
    """Resolve approve_vulnerability mutation."""
    project_name = get_finding_project_name(finding_id)
    success = False
    if uuid:
        success = update_approval_status(
            finding_id, uuid, approval_status)
    else:
        success = update_all_pending_vulns(finding_id, approval_status)
    if success:
        update_last_vuln_date(finding_id)
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project_name)
        util.cloudwatch_log(
            info.context, 'Security: Approve vulnerability from {project}\
                project succesfully'.format(
                project=project_name))
    else:
        util.cloudwatch_log(info.context, 'Security: Attempted to approve\
            vulnerability from {project} project'.format(
            project=project_name))
    return dict(success=success)


@convert_kwargs_to_snake_case
@require_login
@enforce_authz_async
@require_finding_access
def resolve_delete_tags(
    _, info, finding_id: str, vulnerabilities: List
) -> object:
    """Resolve delete_tags mutation."""
    project_name = get_finding_project_name(finding_id)
    success = delete_tags(finding_id, cast(List[str], vulnerabilities))
    if success:
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project_name)
        util.cloudwatch_log(
            info.context, f'Delete tags from {finding_id}')
    return dict(success=success)


@convert_kwargs_to_snake_case
@require_login
@enforce_authz_async
@require_finding_access
def resolve_update_treatment_vuln(_, info, **parameters):
    """Resolve update_treatment_vuln mutation."""
    min_value = 0
    max_value = 1000000000
    vulnerabilities = parameters.get('vulnerabilities')
    finding_id = parameters.get('finding_id')
    severity = parameters.get('severity')
    if severity and severity != -1:
        if min_value > severity > max_value:
            raise InvalidSeverity([min_value, max_value])
    user_data = util.get_jwt_content(info.context)
    project_name = finding_domain.get_finding(finding_id)['projectName']
    is_customer_admin = is_customeradmin(project_name, user_data['user_email'])
    result_update_vuln = update_treatments(vulnerabilities, finding_id,
                                           parameters, info, is_customer_admin)
    if result_update_vuln:
        util.invalidate_cache(finding_id)
    return dict(success=result_update_vuln)


@convert_kwargs_to_snake_case
@require_login
@enforce_authz_async
@require_finding_access
def resolve_request_verification_vuln(
    _, info, finding_id: str, justification: str, vulnerabilities: List
) -> object:
    """Resolve request_verification_vuln mutation."""
    project_name = get_finding_project_name(finding_id)
    user_info = util.get_jwt_content(info.context)
    success = request_verification(
        finding_id,
        user_info['user_email'],
        str.join(' ', [user_info.get('first_name', ''),
                       user_info.get('last_name', '')]),
        justification,
        cast(List[str], vulnerabilities)
    )
    if success:
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project_name)
        util.cloudwatch_log(info.context, 'Security: Verified a request '
                            f'in finding_id: {finding_id}')
    return dict(success=success)


@convert_kwargs_to_snake_case
@require_login
@enforce_authz_async
@require_finding_access
def resolve_verify_request_vuln(_, info, **parameters):
    """Resolve verify_request_vuln mutation."""
    finding_id = parameters.get('finding_id')
    project_name = get_finding_project_name(finding_id)
    user_info = util.get_jwt_content(info.context)
    success = verify_vulnerabilities(
        finding_id,
        user_info['user_email'],
        str.join(' ', [user_info.get('first_name', ''),
                       user_info.get('last_name', '')]),
        info,
        parameters
    )
    if success:
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project_name)
        util.cloudwatch_log(info.context, 'Security: Verified a request '
                            f'in finding_id: {finding_id}')
    return dict(success=success)
