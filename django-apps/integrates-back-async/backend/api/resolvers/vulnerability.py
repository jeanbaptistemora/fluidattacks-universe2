import sys

from typing import List, cast

from asgiref.sync import sync_to_async
from django.core.files.uploadedfile import (
    InMemoryUploadedFile, TemporaryUploadedFile
)
from magic import Magic
from backend.decorators import (
    require_integrates,
    enforce_group_level_auth_async, require_login, require_finding_access
)
from backend.domain.vulnerability import (
    delete_tags, delete_vulnerability, process_file, request_verification,
    update_approval_status, update_last_vuln_date, update_all_pending_vulns,
    update_treatments, verify_vulnerabilities
)
from backend.exceptions import (
    ErrorUploadingFileS3, InvalidFileSize,
    InvalidFileType, InvalidSeverity
)
from backend.decorators import (
    get_entity_cache_async
)
from backend.domain import (
    finding as finding_domain,
)
from backend.typing import (
    SimplePayload as SimplePayloadType,
    Historic as HistoricType,
)

from backend import authz, util

from ariadne import convert_kwargs_to_snake_case


@convert_kwargs_to_snake_case
async def resolve_vulnerability_mutation(obj, info, **parameters):
    """Wrap vulnerability mutations."""
    field = util.camelcase_to_snakecase(info.field_name)
    resolver_func = getattr(sys.modules[__name__], f'_do_{field}')
    return await resolver_func(obj, info, **parameters)


@require_login
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
async def _do_approve_vulnerability(_, info, finding_id: str,
                                    approval_status: bool,
                                    uuid: str = '') -> SimplePayloadType:
    """Resolve approve_vulnerability mutation."""
    success = False
    if uuid:
        success = await sync_to_async(update_approval_status)(
            finding_id, uuid, approval_status)
    else:
        success = await \
            sync_to_async(update_all_pending_vulns)(
                finding_id, approval_status)
    finding_loader = info.context.loaders['finding']
    finding_data = await finding_loader.load(finding_id)
    project_name = finding_data['project_name']
    if success:
        await sync_to_async(update_last_vuln_date)(finding_id)
        finding_loader.clear(finding_id)
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project_name)
        util.forces_trigger_deployment(project_name)
        util.cloudwatch_log(
            info.context, f'Security: Approve vulnerability from \
{project_name} project successfully')  # pragma: no cover
    else:
        util.cloudwatch_log(
            info.context, f'Security: Attempted to approve \
vulnerability from {project_name} project')  # pragma: no cover
    return SimplePayloadType(success=success)


@require_login
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
async def _do_delete_tags(_, info, finding_id: str, vulnerabilities: List,
                          tag: str = '') -> SimplePayloadType:
    """Resolve delete_tags mutation."""
    success = await \
        sync_to_async(delete_tags)(
            finding_id, cast(List[str], vulnerabilities), tag)
    if success:
        finding_loader = info.context.loaders['finding']
        finding_data = await finding_loader.load(finding_id)
        project_name = finding_data['project_name']
        finding_loader.clear(finding_id)
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project_name)
        util.cloudwatch_log(
            info.context, f'Delete tags from {finding_id}')  # pragma: no cover
    return SimplePayloadType(success=success)


@require_login
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
async def _do_update_treatment_vuln(_, info,
                                    **parameters) -> SimplePayloadType:
    """Resolve update_treatment_vuln mutation."""
    min_value = 0
    max_value = 1000000000
    vulnerabilities = parameters.get('vulnerabilities', [])
    finding_id = parameters.get('finding_id', '')
    severity = parameters.get('severity')
    if severity and severity != -1:
        if min_value > severity > max_value:
            raise InvalidSeverity([min_value, max_value])
    user_data = util.get_jwt_content(info.context)
    user_email = user_data['user_email']
    finding_loader = info.context.loaders['finding']
    finding_data = await finding_loader.load(finding_id)
    project_name = finding_data['project_name']

    user_role = await sync_to_async(
        authz.get_group_level_role)(user_email, project_name)

    is_customer_admin = user_role == 'customeradmin'
    result_update_vuln = await \
        update_treatments(vulnerabilities, finding_id,
                          parameters, info, is_customer_admin)

    if result_update_vuln:
        finding_loader.clear(finding_id)
        util.invalidate_cache(finding_id)
        util.forces_trigger_deployment(project_name)
    return SimplePayloadType(success=result_update_vuln)


@require_login
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
async def _do_request_verification_vuln(
        _, info, finding_id: str, justification: str,
        vulnerabilities: List[str]) -> SimplePayloadType:
    """Resolve request_verification_vuln mutation."""
    user_info = util.get_jwt_content(info.context)
    success = await sync_to_async(request_verification)(
        finding_id,
        user_info['user_email'],
        str.join(' ', [user_info.get('first_name', ''),
                       user_info.get('last_name', '')]),
        justification,
        cast(List[str], vulnerabilities)
    )
    if success:
        finding_loader = info.context.loaders['finding']
        finding_data = await finding_loader.load(finding_id)
        project_name = finding_data['project_name']
        finding_loader.clear(finding_id)
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project_name)
        util.cloudwatch_log(
            info.context, 'Security: Verified a request '
            f'in finding_id: {finding_id}')  # pragma: no cover
    return SimplePayloadType(success=success)


@require_login
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
async def _do_verify_request_vuln(_, info, **parameters) -> SimplePayloadType:
    """Resolve verify_request_vuln mutation."""
    finding_id = parameters.get('finding_id', '')
    user_info = util.get_jwt_content(info.context)
    success = await sync_to_async(verify_vulnerabilities)(
        finding_id,
        user_info['user_email'],
        str.join(' ', [user_info.get('first_name', ''),
                       user_info.get('last_name', '')]),
        info,
        parameters
    )
    if success:
        finding_loader = info.context.loaders['finding']
        finding_data = await finding_loader.load(finding_id)
        project_name = finding_data['project_name']
        finding_loader.clear(finding_id)
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project_name)
        util.forces_trigger_deployment(project_name)
        util.cloudwatch_log(
            info.context, 'Security: Verified a request '
            f'in finding_id: {finding_id}')  # pragma: no cover
    return SimplePayloadType(success=success)


@get_entity_cache_async
async def _get_historic_verification(info, identifier: str) -> HistoricType:
    """Get historic verification."""
    finding = await info.context.loaders['vuln'].load(identifier)
    return finding['historic_verification']


@require_login
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
async def _do_delete_vulnerability(_, info, **kwargs) -> SimplePayloadType:
    """Resolve delete_vulnerability mutation."""
    finding_id = kwargs.get('finding_id', '')
    uuid = kwargs.get('id', '')
    justification = kwargs.get('justification', '')
    user_email = util.get_jwt_content(info.context).get('user_email', '')
    finding_loader = info.context.loaders['finding']
    finding_data = await finding_loader.load(finding_id)
    project = finding_data['project_name']
    success = await sync_to_async(delete_vulnerability)(
        finding_id, uuid, justification, user_email)

    if success:
        finding_loader.clear(finding_id)
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project)
        util.forces_trigger_deployment(project)
        util.cloudwatch_log(
            info.context, f'Security: Deleted vulnerability: {uuid} '
            f'from {project} project successfully')  # pragma: no cover
    else:
        util.cloudwatch_log(
            info.context, 'Security: Attempted to delete vulnerability: '
            f'{uuid} from {project} project')  # pragma: no cover
    return SimplePayloadType(success=success)


@require_login
@enforce_group_level_auth_async
@require_integrates
@require_finding_access
async def _do_upload_file(_, info, **kwargs) -> SimplePayloadType:
    """Resolve upload_file mutation."""
    finding_id = kwargs.get('finding_id', '')
    file_input = kwargs.get('file')
    origin = kwargs.get('origin', '')
    project = await sync_to_async(finding_domain.get_project)(finding_id)
    mime = Magic(mime=True)
    if isinstance(file_input, TemporaryUploadedFile):
        mime_type = mime.from_file(file_input.temporary_file_path())
    elif isinstance(file_input, InMemoryUploadedFile):
        mime_type = mime.from_buffer(file_input.file.getvalue())
    else:
        mime_type = ''
    mib = 1048576
    if (file_input and
            mime_type in ['text/x-yaml', 'text/plain', 'text/html']):
        if file_input.size < 1 * mib:
            success = await \
                sync_to_async(process_file)(
                    file_input, finding_id, info, origin)
        else:
            raise InvalidFileSize()
    else:
        raise InvalidFileType()
    if success:
        update_last_vuln_date(finding_id)
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project)
        util.forces_trigger_deployment(project)
        util.cloudwatch_log(
            info.context, 'Security: Uploaded file in {project} \
project successfully'.format(project=project))  # pragma: no cover
    else:
        util.cloudwatch_log(
            info.context,
            f'Security: Attempted to delete file \
from {project} project')  # pragma: no cover
        raise ErrorUploadingFileS3()
    return SimplePayloadType(success=success)
