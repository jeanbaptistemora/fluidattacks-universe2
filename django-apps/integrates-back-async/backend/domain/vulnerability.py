"""Domain functions for vulnerabilities."""   # pylint:disable=too-many-lines

import asyncio
import html
import html.parser
import copy
import os
import threading
import uuid
from datetime import datetime
from time import time
from contextlib import AsyncExitStack
from typing import Collection, Dict, List, Iterable, Optional, Set, Union, cast
import yaml

import aioboto3
from asgiref.sync import async_to_sync, sync_to_async
from pykwalify.core import Core
from pykwalify.errors import CoreError, SchemaError
from graphql import GraphQLError

import pytz
import rollbar

from django.conf import settings
from django.core.files.base import ContentFile

from backend import authz, mailer, util
from backend.exceptions import (
    AlreadyRequested,
    InvalidPath,
    InvalidPort,
    InvalidSchema,
    InvalidSpecific,
    NotVerificationRequested,
    VulnAlreadyClosed,
    VulnNotFound
)
from backend.utils import (
    vulnerabilities as vuln_utils,
    findings as finding_utils,
    validations
)
from backend.dal.helpers.dynamodb import start_context
from backend.dal import (
    finding as finding_dal,
    project as project_dal,
    vulnerability as vuln_dal,
    comment as comment_dal
)
from backend.typing import (
    Finding as FindingType,
    User as UserType,
    Vulnerability as VulnerabilityType,
)
from backend.utils import aio
from __init__ import BASE_URL


def filter_open_vulnerabilities(
    vulnerabilities: List[VulnerabilityType],
) -> List[VulnerabilityType]:
    return [
        vulnerability
        for vulnerability in vulnerabilities
        if (vulnerability['current_state'] == 'open' and
            (vulnerability['current_approval_status'] != 'PENDING' or
             vulnerability['last_approved_status']))
    ]


def approve_vulnerability(
        finding_id: str,
        historic_state: List[Dict[str, str]],
        last_state: Dict[str, str],
        vulnerability: List[Dict[str, str]]) -> bool:
    """ Approve vulnerability """
    tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
    current_day = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    current_state = {
        'date': current_day,
        'state': last_state.get('state', ''),
        'approval_status': 'APPROVED',
        'analyst': last_state.get('analyst', '')
    }

    historic_state[-1] = current_state
    return vuln_dal.update_state(
        finding_id,
        str(vulnerability[0].get('UUID', '')),
        'historic_state',
        historic_state,
        vulnerability
    )


def reject_vulnerability(
        finding_id: str,
        historic_state: List[Dict[str, str]],
        vulnerability: List[Dict[str, str]],
        vuln_id: str) -> bool:
    """ Reject vulnerability: remove last_state of historic_state or remove
        if only one state present in historic_state """
    historic_state.pop()
    response = False
    if historic_state:
        response = vuln_dal.update_state(
            finding_id,
            str(vulnerability[0].get('UUID', '')),
            'historic_state',
            historic_state,
            vulnerability
        )
    else:
        response = vuln_dal.delete(vuln_id, finding_id)
    return response


def update_approval_status(
        finding_id: str,
        vuln_id: str,
        approval_status: bool) -> bool:
    """ Update vulnerability approval state """
    vulnerability = cast(
        List[Dict[str, str]],
        vuln_dal.get(finding_id, uuid=vuln_id)
    )
    response = False

    if vulnerability:
        historic_state = cast(
            List[Dict[str, str]],
            vulnerability[0].get('historic_state')
        )
        last_state = historic_state[-1]
        del vulnerability[0]['historic_state']

        if last_state.get('approval_status') == 'PENDING':
            if approval_status:
                response = approve_vulnerability(
                    finding_id,
                    historic_state,
                    last_state,
                    vulnerability
                )
            else:
                response = reject_vulnerability(
                    finding_id,
                    historic_state,
                    vulnerability,
                    vuln_id
                )
        else:
            # vuln approval_status is different than pending
            pass
    else:
        # vuln not found
        pass

    return response


async def update_vuln_state(
        info,
        vulnerability: Dict[str, FindingType],
        item: Dict[str, str],
        finding_id: str,
        current_day: str) -> bool:
    """Update vulnerability state."""
    historic_state = cast(
        List[Dict[str, str]],
        vulnerability.get('historic_state')
    )
    last_state = historic_state[-1]
    response = False
    if last_state.get('state') != item.get('state'):
        user_data = cast(UserType, util.get_jwt_content(info.context))
        analyst = str(user_data['user_email'])
        if util.is_api_token(user_data):
            current_state = {
                'date': current_day,
                'state': item.get('state', ''),
                'origin': item.get('origin', ''),
                'approval_status': 'PENDING',
                'analyst': f'api-{analyst}'
            }
        else:
            current_state = {
                'date': current_day,
                'state': item.get('state', ''),
                'analyst': analyst
            }

        historic_state.append(current_state)
        data_to_update: Dict[str, FindingType] = {
            'historic_state': historic_state
        }
        if item.get('state') == 'closed':
            data_to_update.update({'treatment_manager': None})

        response = await vuln_dal.update(
            finding_id,
            str(vulnerability.get('UUID')),
            data_to_update
        )
    else:
        response = True
    return response


def add_vuln_to_dynamo(
        item: Dict[str, str],
        specific: str,
        vuln: str,
        finding_id: str,
        info) -> bool:
    """Add vulnerability to dynamo."""
    historic_state = []
    last_finding_state = cast(
        List[Dict[str, str]],
        async_to_sync(finding_dal.get_finding)(
            finding_id)['historic_treatment']
    )[-1]
    where = item.get('where', '')
    vulnerability = cast(
        List[Dict[str, str]],
        vuln_dal.get(
            finding_id,
            vuln_type=vuln,
            where=where,
            specific=specific
        )
    )
    response = False
    tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
    current_day = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    user_data = cast(UserType, util.get_jwt_content(info.context))
    email = str(user_data['user_email'])
    if vulnerability:
        response = async_to_sync(update_vuln_state)(
            info, vulnerability[0], item, finding_id, current_day
        )
    else:
        data: Dict[str, FindingType] = {}
        data['vuln_type'] = vuln
        data['where'] = where
        data['specific'] = specific
        data['finding_id'] = finding_id
        data['UUID'] = str(uuid.uuid4())
        data['treatment'] = 'NEW'
        if last_finding_state['treatment'] != 'NEW':
            data['treatment_manager'] = last_finding_state.get('user', '')
        if item.get('state'):
            if util.is_api_token(user_data):
                historic_state.append({
                    'date': current_day,
                    'state': item.get('state', ''),
                    'origin': item.get('origin', ''),
                    'approval_status': 'PENDING',
                    'analyst': f'api-{email}'
                })
            else:
                historic_state.append({
                    'date': current_day,
                    'state': item.get('state', ''),
                    'analyst': email
                })

            data['historic_state'] = historic_state
            response = vuln_dal.create(data)
        else:
            util.cloudwatch_log_sync(
                info.context,
                'Security: Attempted to add vulnerability without state'
            )
    return response


def process_file(file_input, finding_id: str, info, origin: str) -> bool:
    """Process a file."""
    success = False
    raw_content = file_input.read()
    raw_content = raw_content.decode()
    file_content = html.escape(raw_content, quote=False)
    file_input.seek(0)
    vulnerabilities = yaml.safe_load(file_content)
    file_url = f'/tmp/vulnerabilities-{uuid.uuid4()}-{finding_id}.yaml'
    with open(file_url, 'w') as stream:
        yaml.safe_dump(vulnerabilities, stream)
    if validate_file_schema(file_url, info):
        success = map_vulns_to_dynamo(
            vulnerabilities,
            finding_id,
            info,
            origin
        )
    else:
        success = False
    return success


def map_vulns_to_dynamo(vulnerabilities: Dict[str, FindingType],
                        finding_id: str, info, origin: str) -> bool:
    """Map vulnerabilities and send it to dynamo."""
    where = ['inputs', 'lines', 'ports']
    vulns_added = []
    for vuln in where:
        file_vuln = vulnerabilities.get(vuln)
        if file_vuln:
            inputs_added = list(map(
                lambda x,  # type: ignore
                vuln=vuln: add_vulnerability(
                    x, vuln, finding_id, info, origin
                ),
                cast(List[str], file_vuln)
            ))
            vulns_added.append(all(inputs_added))
        else:
            pass
            # If a file does not have a type of vulnerabilities,
            # this does not represent an error or an exceptional condition.
    if vulns_added:
        success = all(vulns_added)
    else:
        success = False
    return success


def validate_file_schema(file_url: str, info) -> bool:
    """Validate if a file has the correct schema."""
    schema_dir = os.path.dirname(os.path.abspath(__file__))
    schema_dir = os.path.join(schema_dir, 'vuln_template.yaml')
    core = Core(source_file=file_url, schema_files=[schema_dir])
    is_valid = False
    try:
        core.validate(raise_exception=True)
        is_valid = True
    except SchemaError:
        lines_of_exceptions = core.errors
        errors_values = [
            x.value
            for x in lines_of_exceptions
            if not hasattr(x, 'key')
        ]
        errors_keys = [
            x
            for x in lines_of_exceptions
            if hasattr(x, 'key')
        ]
        errors_values_formated = [f'"{x}"' for x in errors_values]
        errors_keys_formated = [
            f'"{x.key}"'
            for x in errors_keys
            if x.msg and str(x.msg).find('was not defined') >= 0
        ]
        errors_keys_joined = ','.join(errors_keys_formated)
        errors_values_joined = ','.join(errors_values_formated)
        error_value = (
            f'"values": [{errors_values_joined}], '
            f'"keys": [{errors_keys_joined}]'
        )
        util.cloudwatch_log_sync(
            info.context,
            'Error: An error occurred validating vulnerabilities file'
        )
        raise InvalidSchema(expr=error_value)
    except CoreError:
        raise InvalidSchema()
    finally:
        os.unlink(file_url)
    return is_valid


async def update_last_vuln_date(finding_id: str) -> bool:
    inc = 0
    has_new_open_vulns = False
    vulnerabilities = await list_vulnerabilities_async([finding_id])
    today_date = str(datetime.today().strftime('%Y-%m-%d %H:%M:%S'))
    while inc < len(vulnerabilities) and has_new_open_vulns is False:
        vuln_historics = cast(
            List[Dict[str, str]],
            vulnerabilities[inc].get('historic_state')
        )
        current_state = vuln_historics[-1].get('state', '')
        current_date = vuln_historics[-1].get('date', '')
        if (current_state == 'open' and
            current_date.split(' ')[0] == today_date.split(' ')[0] and
            ('approval_status' not in vuln_historics[-1] or
                vuln_historics[-1].get('approval_status') == 'APPROVED')):
            description: Dict[str, FindingType] = {
                'lastVulnerability': today_date
            }
            await finding_dal.update(finding_id, description)
            has_new_open_vulns = True
        else:
            inc += 1
    success = has_new_open_vulns
    return success


def update_treatment_vuln(
        vulnerabilities: List[str],
        finding_id: str,
        updated_values: Dict[str, FindingType],
        info) -> bool:
    del updated_values['finding_id']
    updated_vuln_description = []
    for vulnerability in vulnerabilities:
        vuln_info = cast(
            List[Dict[str, FindingType]],
            vuln_dal.get(finding_id, uuid=vulnerability)
        )
        new_info = copy.copy(updated_values)
        if new_info.get('tag'):
            new_info['tag'] = cast(
                List[str],
                vuln_info[0].get('tag', [])
            )
            tags = str(updated_values['tag']).split(',')
            validations.validate_fields(tags)
            for tag in tags:
                if tag.strip():
                    cast(List[str], new_info['tag']).append(tag.strip())
            new_info['tag'] = cast(
                # conflict between mypy and pylint -> \
                # 'github.com/PyCQA/pylint/issues/2377'
                # pylint: disable=unsubscriptable-object
                List[str],
                list(set(cast(
                    Iterable[Collection[str]],
                    new_info['tag']
                )))
            )
            new_info['tag'] = [
                html.unescape(tag)
                for tag in cast(List[str], new_info['tag'])
            ]
        new_info = {
            key: None
            if not value
            else value
            for key, value in new_info.items()
        }
        new_info = {
            util.camelcase_to_snakecase(k): new_info.get(k)
            for k in new_info
        }
        result_update_vuln = async_to_sync(vuln_dal.update)(
            finding_id,
            vulnerability,
            new_info
        )
        if 'lines' in str(vuln_info[0]['vuln_type']):
            where = 'Path'
            specific = 'Line'
        elif 'ports' in str(vuln_info[0]['vuln_type']):
            where = 'Host'
            specific = 'Port'
        else:
            where = 'URL'
            specific = 'Field'
        mail_description = (
            f'<b>{where}:</b>{vuln_info[0]["where"]}&nbsp;'
            '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'
            f'<b>{specific}:</b> {vuln_info[0]["specific"]}'
        )
        updated_vuln_description.append(
            {'updated_vuln_description': mail_description}
        )
        if not result_update_vuln:
            util.cloudwatch_log_sync(
                info.context,
                ('Security: Attempted to update vulnerability'
                 f':{vulnerability} from finding:{finding_id}')
            )
            return False
        util.cloudwatch_log_sync(
            info.context,
            ('Security: Updated vulnerability:'
             f'{vulnerability} from finding:{finding_id} successfully')
        )

    return True


async def update_treatments(vulnerabilities: List[str], finding_id: str,
                            updated_values: Dict[str, FindingType],
                            info, is_customer_admin: bool) -> bool:
    """Update treatments data in vulnerability"""
    user_data = util.get_jwt_content(info.context)
    finding = await finding_dal.get_finding(finding_id)
    updated_values['treatment'] = cast(
        List[Dict[str, str]],
        finding.get('historic_treatment')
    )[-1]['treatment']
    updated_values['treatment_manager'] = await sync_to_async(
        set_treatment_manager
    )(
        str(updated_values.get('treatment', '')),
        str(updated_values.get('treatment_manager', '')),
        finding, is_customer_admin, user_data['user_email']
    )
    updated_values.pop('vulnerabilities', None)
    if updated_values.get('tag') == '':
        updated_values.pop('tag', None)
    vulns = await asyncio.gather(*[
        asyncio.create_task(
            sync_to_async(vuln_dal.get)(
                finding_id, uuid=vulnerability
            )
        )
        for vulnerability in vulnerabilities
    ])
    updated_vulns = [vuln[0] for vuln in vulns]
    if any([
        (
            vulnerability.get('treatment_manager', '') !=
            str(updated_values.get('treatment_manager', ''))
        )
        for vulnerability in updated_vulns
    ]):
        vulns_grouped = group_vulnerabilities(updated_vulns)
        vulns_data = vuln_utils.format_vulnerabilities(
            cast(List[Dict[str, FindingType]], vulns_grouped)
        )
        mail_content = set_updated_manager_mail_content(
            cast(Dict[str, List[Dict[str, str]]], vulns_data)
        )
        await aio.ensure_io_bound(
            send_updated_manager_mail,
            str(updated_values.get('treatment_manager', '')),
            finding,
            mail_content
        )

    return await sync_to_async(update_treatment_vuln)(
        vulnerabilities, finding_id, updated_values, info)


def set_treatment_manager(
        treatment: str,
        treatment_manager: str,
        finding: Dict[str, FindingType],
        is_customer_admin: bool,
        user_mail: str) -> str:
    if treatment == 'IN PROGRESS':
        if not is_customer_admin:
            treatment_manager = user_mail
        if treatment_manager:
            group_name = cast(str, finding.get('project_name', ''))
            project_users = project_dal.get_users(group_name)
            customer_roles = ['customer', 'customeradmin']
            customer_users = [
                user
                for user in project_users
                if authz.get_group_level_role(
                    user, group_name) in customer_roles
            ]
            if treatment_manager not in customer_users:
                raise GraphQLError('Invalid treatment manager')
        else:
            raise GraphQLError('Invalid treatment manager')
    elif treatment == 'ACCEPTED':
        treatment_manager = user_mail
    elif treatment == 'ACCEPTED_UNDEFINED':
        last_state = cast(
            List[Dict[str, str]],
            finding.get('historic_treatment')
        )[-1]
        if last_state['acceptance_status'] == 'SUBMITTED':
            treatment_manager = user_mail
        else:
            treatment_manager = last_state['user']

    return treatment_manager


def set_updated_manager_mail_content(
        vulnerabilities: Dict[str, List[Dict[str, str]]]) -> str:
    mail_content = ''
    for vuln_type in ['ports', 'lines', 'inputs']:
        type_vulns = vulnerabilities.get(vuln_type)
        if type_vulns:
            mail_content += '<br />'.join([
                f'- {list(vuln.values())[0]} ({list(vuln.values())[1]})'
                for vuln in type_vulns
            ])
            mail_content += '<br />'
    return mail_content


def send_updated_manager_mail(
        treatment_manager: str,
        finding: Dict[str, FindingType],
        vulnerabilities: str):
    finding_id = str(finding.get('finding_id'))
    project_name = str(finding.get('project_name')).upper()
    email_send_thread = threading.Thread(
        name='Vuln treatment manager changed email thread',
        target=mailer.send_mail_updated_manager,
        args=([treatment_manager], {
            'finding': str(finding.get('finding')),
            'vulnerabilities': vulnerabilities,
            'finding_link':
                f'{BASE_URL}/groups/{project_name}/findings/{finding_id}'
        }))
    email_send_thread.start()


async def get_open_vuln_by_type(
        finding_id: str,
        context) -> Dict[str, Union[int, List[str]]]:
    """Get open vulnerabilities group by type."""
    vulnerabilities = await list_vulnerabilities_async([finding_id])
    finding: Dict[str, Union[int, List[str]]] = {
        'openVulnerabilities': 0,
        'closedVulnerabilities': 0,
        'portsVulns': [],
        'linesVulns': [],
        'inputsVulns': []
    }
    vulns_types = ['ports', 'lines', 'inputs']
    for vuln in vulnerabilities:
        current_state = get_last_approved_status(vuln)
        if current_state == 'open':
            finding['openVulnerabilities'] += 1  # type: ignore
            if vuln.get('vuln_type') in vulns_types:
                finding[  # type: ignore
                    f'{vuln.get("vuln_type", "")}Vulns'
                ].append({  # type: ignore
                    'where': vuln.get('where'),
                    'specific': vuln.get('specific')
                })
            else:
                error_msg = (
                    f'Error: Vulnerability {vuln.get("UUID")} of finding '
                    f'{finding_id} does not have the right type'
                )
                rollbar.report_message(error_msg, 'error')
        elif current_state == 'closed':
            finding['closedVulnerabilities'] += 1  # type: ignore
        else:
            error_msg = (
                f'Error: Vulnerability {vuln.get("UUID")} of finding '
                f'{finding_id} does not have the right state'
            )
            util.cloudwatch_log(context, error_msg)
    return finding


async def get_vulnerabilities_by_type(
        finding_id: str) -> Dict[str, List[FindingType]]:
    """Get vulnerabilities group by type."""
    vulnerabilities = await list_vulnerabilities_async([finding_id])
    vulnerabilities_grouped = cast(
        List[Dict[str, FindingType]],
        await aio.ensure_cpu_bound(group_vulnerabilities, vulnerabilities)
    )
    vulnerabilities_formatted = vuln_utils.format_vulnerabilities(
        vulnerabilities_grouped
    )
    return vulnerabilities_formatted


def group_vulnerabilities(vulnerabilities: List[Dict[str, FindingType]]) -> \
        List[FindingType]:
    """Group vulnerabilities by specific field."""
    vuln_types = ['lines', 'ports', 'inputs']
    vuln_states = ['open', 'closed']
    total_vulnerabilities: Dict[str, Dict[str, FindingType]] = {}
    result_vulns: List[FindingType] = []
    for vuln_type in vuln_types:
        total_vulnerabilities[vuln_type] = {}
        for vuln_state in vuln_states:
            total_vulnerabilities[vuln_type][vuln_state] = []

    for vuln in vulnerabilities:
        all_states = cast(
            List[Dict[str, FindingType]],
            vuln.get('historic_state', [{}])
        )
        current_state = str(
            all_states[-1].get('state', '')
        )
        current_approval_status = all_states[-1].get('approval_status', '')
        vuln_type = str(vuln.get('vuln_type', ''))
        if (current_approval_status != 'PENDING' or
                get_last_approved_status(vuln)):
            cast(List[Dict[str, FindingType]],
                 total_vulnerabilities[vuln_type][current_state]).append(vuln)
        else:
            # vuln has pending approval_status
            pass

    for vuln_type in vuln_types:
        for vuln_state in vuln_states:
            vulns_grouped = cast(
                Iterable[FindingType],
                vuln_utils.group_specific(
                    cast(
                        List[str],
                        total_vulnerabilities[vuln_type][vuln_state]
                    ),
                    vuln_type
                )
            )
            result_vulns.extend(vulns_grouped)
    return result_vulns


async def get_vulnerabilities_async(
        finding_id: str,
        table: aioboto3.session.Session.client,
        should_list_deleted: bool = False) -> List[Dict[str, FindingType]]:
    vulnerabilities = await vuln_dal.get_vulnerabilities_async(
        finding_id,
        table,
        should_list_deleted
    )
    return [
        vuln_utils.format_data(vuln)
        for vuln in vulnerabilities
    ]


async def list_vulnerabilities_async(
        finding_ids: List[str],
        should_list_deleted: bool = False) -> List[Dict[str, FindingType]]:
    """Retrieves all vulnerabilities for the requested findings"""
    vulns: List[Dict[str, FindingType]] = []
    async with AsyncExitStack() as stack:
        resource = await stack.enter_async_context(start_context())
        table = await resource.Table(vuln_dal.TABLE_NAME)
        vulns_tasks = [
            asyncio.create_task(
                get_vulnerabilities_async(
                    finding_id,
                    table,
                    should_list_deleted
                )
            )
            for finding_id in finding_ids
        ]
        vulns = await asyncio.gather(*vulns_tasks)

    result: List[Dict[str, FindingType]] = []
    for result_list in vulns:
        result.extend(cast(
            Iterable[Dict[str, FindingType]],
            result_list
        ))
    return result


def get_last_approved_status(vuln: Dict[str, FindingType]) -> str:
    historic_state = cast(List[Dict[str, str]], vuln['historic_state'])
    last_approved = ''
    for state in list(reversed(historic_state)):
        if (state.get('approval_status') == 'APPROVED' or
                not state.get('approval_status')):
            last_approved = state.get('state', '')
            break
    return last_approved


def filter_deleted_status(vuln: Dict[str, FindingType]) -> bool:
    historic_state = cast(List[Dict[str, str]], vuln['historic_state'])
    last_approved = True
    for state in historic_state:
        if state.get('state') == 'DELETED':
            last_approved = False
            break
    return last_approved


def get_last_approved_analyst(vuln: Dict[str, FindingType]) -> str:
    historic_state = cast(List[Dict[str, str]], vuln['historic_state'])
    last_analyst = ''
    for state in list(reversed(historic_state)):
        if (state.get('approval_status') == 'APPROVED' or
                not state.get('approval_status')):
            last_analyst = state.get('analyst', '')
            break
    return last_analyst


def get_last_approved_state(vuln: Dict[str, FindingType]) -> Dict[str, str]:
    historic_state = cast(List[Dict[str, str]], vuln['historic_state'])
    last_approved_state: Dict[str, str] = {}
    for state in list(reversed(historic_state)):
        if (state.get('approval_status') == 'APPROVED' or
                not state.get('approval_status')):
            last_approved_state = state
            break
    return last_approved_state


async def update_all_pending_vulns(finding_id: str, approval_status: bool) -> \
        bool:
    list_vulns = await list_vulnerabilities_async([finding_id])
    list_pending_vulns = [
        vuln
        for vuln in list_vulns
        if cast(
            List[Dict[str, str]],
            vuln['historic_state']
        )[-1].get('approval_status', '') == 'PENDING'
    ]
    success = await asyncio.gather(*[
        sync_to_async(update_approval_status)(
            finding_id, str(vuln.get('UUID', '')), approval_status
        )
        for vuln in list_pending_vulns
    ])
    return all(success)


def delete_vulnerability(
        finding_id: str,
        vuln_id: str,
        justification: str,
        user_email: str) -> bool:
    vulnerability = vuln_dal.get(finding_id, uuid=vuln_id)
    success = False
    if vulnerability and vulnerability[0].get('historic_state'):
        all_states = cast(
            List[Dict[str, str]],
            vulnerability[0].get('historic_state')
        )
        current_state = all_states[-1].get('state')
        if current_state == 'open':
            tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
            current_day = datetime.now(tz=tzn).today().strftime(
                '%Y-%m-%d %H:%M:%S'
            )
            new_state = {
                'date': current_day,
                'state': 'DELETED',
                'justification': justification,
                'analyst': user_email
            }
            success = vuln_dal.update_state(
                finding_id,
                str(vulnerability[0].get('UUID', '')),
                'historic_state',
                [new_state],
                cast(List[Dict[str, str]], vulnerability)
            )
    return success


async def delete_tags(
        finding_id: str,
        vulnerabilities: List[str],
        tag: str) -> bool:
    vuln_update_tasks = []
    vuln_info = await asyncio.gather(*[
        asyncio.create_task(
            sync_to_async(vuln_dal.get)(
                finding_id, uuid=vulnerability
            )
        )
        for vulnerability in vulnerabilities
    ])
    for index, vulnerability in enumerate(vulnerabilities):
        tag_info: Dict[str, Optional[Set[str]]] = {'tag': set()}
        if tag:
            if vuln_info[index]:
                tag_info['tag'] = cast(
                    Set[str],
                    vuln_info[index][0].get('tag', [])
                )
            if tag in cast(Set[str], tag_info.get('tag', [])):
                cast(Set[str], tag_info.get('tag')).remove(tag)
        if tag_info.get('tag') == set():
            tag_info['tag'] = None
        vuln_update_task = asyncio.create_task(
            vuln_dal.update(
                finding_id,
                vulnerability,
                cast(Dict[str, FindingType], tag_info)
            )
        )
        vuln_update_tasks.append(vuln_update_task)
    success = await asyncio.gather(*vuln_update_tasks)
    return all(success)


def add_vulnerability_aux(
        vuln: str,
        specific: str,
        data: Dict[str, str],
        finding_id: str, info) -> bool:
    """Add vulnerability auxiliar."""
    response = False
    if vuln in ('lines', 'ports'):
        specific_values = vuln_utils.ungroup_specific(specific)
    else:
        specific_values = [
            spec
            for spec in specific.split(',')
            if spec
        ]
    if (vuln == 'ports' and
        not all((0 <= int(i) <= 65535)
                for i in specific_values)):
        error_value = f'"values": "{specific}"'
        raise InvalidPort(expr=error_value)
    if not specific_values:
        raise InvalidSpecific()

    vuln_added = [
        add_vuln_to_dynamo(
            data, i, vuln, finding_id, info
        )
        for i in specific_values
    ]
    response = all(vuln_added)
    return response


def add_vulnerability(
        item: Dict[str, FindingType],
        vuln_type: str,
        finding_id: str,
        info, origin: str) -> bool:
    """Add vulnerability to dynamo."""
    where_haders = {
        'inputs': {'where': 'url', 'specific': 'field'},
        'lines': {'where': 'path', 'specific': 'line'},
        'ports': {'where': 'host', 'specific': 'port'}
    }
    for vuln, vuln_info in list(where_haders.items()):
        if vuln_type == vuln:
            where = str(item.get(vuln_info.get('where', '')))
            specific = str(item.get(vuln_info.get('specific', '')))
            data: Dict[str, str] = {
                'where': where,
                'state': str(item.get('state', '')),
                'origin': origin if origin else 'api'
            }
            if vuln == 'lines' and where.find('\\') >= 0:
                path = where.replace('\\', '\\\\')
                error_value = f'"values": "{path}"'
                raise InvalidPath(expr=error_value)
            if (vuln_utils.is_range(specific) or
                    vuln_utils.is_sequence(specific)):
                response = add_vulnerability_aux(
                    vuln, specific, data, finding_id, info
                )
            else:
                if (vuln == 'ports' and
                        not 0 <= int(specific) <= 65535):
                    error_value = f'"values": "{specific}"'
                    raise InvalidPort(expr=error_value)
                response = add_vuln_to_dynamo(
                    data, specific, vuln_type, finding_id, info
                )
    return response


def get(finding_id: str, vuln_id: str):
    vuln = cast(
        List[Dict[str, FindingType]],
        vuln_dal.get(finding_id, uuid=vuln_id)
    )
    first_vuln = cast(Dict[str, List[Dict[str, str]]], vuln[0])
    if not vuln:
        raise VulnNotFound()
    if first_vuln.get(
        'historic_state', [{}]
    )[-1].get('state', '') == 'DELETED':
        raise VulnNotFound()
    return vuln[0]


def get_by_ids(finding_id: str, vulns_ids: List[str]) -> \
        List[Dict[str, FindingType]]:
    return [
        get(finding_id, vuln_id)
        for vuln_id in vulns_ids
    ]


def validate_requested_verification(
        vuln: Dict[str, FindingType]) -> Dict[str, FindingType]:
    """ Validate vuln is not resquested """
    historic_verification = cast(
        List[Dict[str, FindingType]],
        vuln.get('historic_verification', [{}])
    )
    if historic_verification[-1].get('status', '') == 'REQUESTED':
        raise AlreadyRequested()
    return vuln


def validate_closed(vuln: Dict[str, FindingType]) -> Dict[str, FindingType]:
    """ Validate vuln closed """
    if cast(
        List[Dict[str, FindingType]],
        vuln.get('historic_state', [{}])
    )[-1].get('state') == 'closed':
        raise VulnAlreadyClosed()
    return vuln


async def request_verification(
        finding_id: str,
        user_email: str,
        user_fullname: str,
        justification: str,
        vuln_ids: List[str]) -> bool:
    finding = await finding_dal.get_finding(finding_id)
    vulnerabilities = await aio.ensure_io_bound(
        get_by_ids, finding_id, vuln_ids)
    vulnerabilities = [
        validate_requested_verification(vuln)
        for vuln in vulnerabilities
    ]
    vulnerabilities = [validate_closed(vuln) for vuln in vulnerabilities]
    if not vulnerabilities:
        raise VulnNotFound()
    comment_id = int(round(time() * 1000))
    tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
    today = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    historic_verification = cast(
        List[Dict[str, Union[str, int, List[str]]]],
        finding.get('historic_verification', [])
    )
    historic_verification.append({
        'date': today,
        'user': user_email,
        'status': 'REQUESTED',
        'comment': comment_id,
        'vulns': vuln_ids
    })
    update_finding = await finding_dal.update(
        finding_id, {'historic_verification': historic_verification})
    comment_data = {
        'comment_type': 'verification',
        'content': justification,
        'created': today,
        'email': user_email,
        'finding_id': int(finding_id),
        'fullname': user_fullname,
        'modified': today,
        'parent': 0,
    }
    await comment_dal.create(comment_id, comment_data)
    update_vulns = await aio.materialize(
        map(vuln_dal.request_verification, vulnerabilities)
    )
    if all(update_vulns) and update_finding:
        await aio.ensure_io_bound(
            finding_utils.send_remediation_email,
            user_email, finding_id, str(finding.get('finding', '')),
            str(finding.get('project_name', '')),
            justification
        )
    else:
        await aio.ensure_io_bound(
            rollbar.report_message,
            'Error: An error occurred remediating', 'error'
        )
    return all(update_vulns)


def validate_verify(vuln: Dict[str, FindingType]) -> Dict[str, FindingType]:
    """ Validate vuln is resquested """
    historic_verification = vuln.get('historic_verification', [{}])
    if cast(
        List[Dict[str, str]],
        historic_verification
    )[-1].get('status', '') != 'REQUESTED':
        raise NotVerificationRequested()
    return vuln


async def verify_vulnerabilities(
        finding_id: str,
        user_email: str,
        user_fullname: str,
        info,
        parameters: Dict[str, FindingType]) -> bool:
    finding = await finding_dal.get_finding(finding_id)
    vuln_ids = (
        cast(List[str], parameters.get('open_vulns', [])) +
        cast(List[str], parameters.get('closed_vulns', []))
    )
    vulnerabilities = await aio.ensure_io_bound(
        get_by_ids, finding_id, vuln_ids)
    vulnerabilities = [validate_verify(vuln) for vuln in vulnerabilities]
    vulnerabilities = [validate_closed(vuln) for vuln in vulnerabilities]
    if not vulnerabilities:
        raise VulnNotFound()
    tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
    today = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    comment_id = int(round(time() * 1000))
    historic_verification = cast(
        List[Dict[str, Union[str, int, List[str]]]],
        finding.get('historic_verification', [])
    )
    historic_verification.append({
        'date': today,
        'user': user_email,
        'status': 'VERIFIED',
        'comment': comment_id,
        'vulns': vuln_ids
    })
    update_finding = await finding_dal.update(
        finding_id,
        {'historic_verification': historic_verification}
    )
    comment_data: comment_dal.CommentType = {
        'comment_type': 'verification',
        'content': parameters.get('justification', ''),
        'created': today,
        'email': user_email,
        'finding_id': int(finding_id),
        'fullname': user_fullname,
        'modified': today,
        'parent': 0,
    }
    await comment_dal.create(comment_id, comment_data)
    success = await aio.materialize(
        map(vuln_dal.verify_vulnerability, vulnerabilities)
    )
    if all(success) and update_finding:
        success = await verify(
            info,
            finding_id,
            vulnerabilities,
            cast(List[str], parameters.get('closed_vulns', [])),
            today
        )
    else:
        await aio.ensure_io_bound(
            rollbar.report_message,
            'Error: An error occurred verifying', 'error'
        )
    return all(success)


async def verify(
        info, finding_id: str,
        vulnerabilities: List[Dict[str, FindingType]],
        closed_vulns: List[str], date) -> List[bool]:
    finding = await finding_dal.get_finding(finding_id)
    success = await aio.materialize(
        update_vuln_state(
            info, vuln, {'state': 'closed'}, finding_id, date
        )
        for vuln in vulnerabilities
        if vuln.get('UUID') in closed_vulns
    )
    await aio.ensure_io_bound(
        finding_utils.send_finding_verified_email,
        finding_id,
        str(finding.get('finding', '')),
        str(finding.get('project_name', ''))
    )
    return success


async def get_vulnerabilities_file(finding_id: str, project_name: str) -> str:
    vulnerabilities = await get_vulnerabilities_by_type(finding_id)
    file_name = f'/tmp/{project_name}-{finding_id}_{str(uuid.uuid4())}.yaml'
    with open(file_name, 'w') as stream:
        yaml.safe_dump(vulnerabilities, stream, default_flow_style=False)
    uploaded_file_url = ''
    with open(file_name, 'rb') as bstream:
        uploaded_file_name = await vuln_dal.upload_file(
            ContentFile(bstream.read(), name=bstream.name)
        )
        uploaded_file_url = vuln_dal.sign_url(uploaded_file_name)

    return uploaded_file_url
