"""DAL functions for vulnerabilities."""

from typing import Dict, List, cast
from datetime import datetime
import pytz
import rollbar
import aioboto3

from django.conf import settings
from django.core.files.base import ContentFile

from boto3.dynamodb.conditions import Attr, Key
from botocore.exceptions import ClientError

from backend.exceptions import ErrorUploadingFileS3
from backend.typing import (
    DynamoDelete as DynamoDeleteType,
    Finding as FindingType
)
from backend.dal.helpers import cloudfront, dynamodb, s3
from backend.utils import aio

from __init__ import (
    FI_AWS_S3_REPORTS_BUCKET as VULNS_BUCKET,
    FI_CLOUDFRONT_REPORTS_DOMAIN
)

DYNAMODB_RESOURCE = dynamodb.DYNAMODB_RESOURCE  # type: ignore
TABLE = DYNAMODB_RESOURCE.Table('FI_vulnerabilities')
TABLE_NAME: str = 'FI_vulnerabilities'


async def get_vulnerabilities_async(
        finding_id: str,
        table: aioboto3.session.Session.client,
        should_list_deleted: bool = False) -> List[Dict[str, FindingType]]:
    """Get vulnerabilities of the given finding"""
    query_attrs = {
        'KeyConditionExpression': Key('finding_id').eq(finding_id)
    }
    response = await table.query(**query_attrs)
    vulns = response.get('Items', [])
    while 'LastEvaluatedKey' in response:
        query_attrs.update(
            {'ExclusiveStartKey': response.get('LastEvaluatedKey')}
        )
        response = await table.query(**query_attrs)
        vulns += response.get('Items', [])

    return [
        vuln for vuln in vulns
        if vuln.get('historic_state', [{}])[-1].get('state') != 'DELETED' or
        should_list_deleted
    ]


async def update(
        finding_id: str,
        vuln_id: str,
        data: Dict[str, FindingType]) -> bool:
    success = False
    set_expression = ''
    remove_expression = ''
    expression_values = {}
    for attr, value in data.items():
        if value is None:
            remove_expression += f'{attr}, '
        else:
            set_expression += f'{attr} = :{attr}, '
            expression_values.update({f':{attr }': value})

    if set_expression:
        set_expression = f'SET {set_expression.strip(", ")}'
    if remove_expression:
        remove_expression = f'REMOVE {remove_expression.strip(", ")}'

    update_attrs = {
        'Key': {
            'finding_id': finding_id,
            'UUID': vuln_id,
        },
        'UpdateExpression': f'{set_expression} {remove_expression}'.strip(),
    }
    if expression_values:
        update_attrs.update({'ExpressionAttributeValues': expression_values})
    try:
        success = await dynamodb.async_update_item(TABLE_NAME, update_attrs)
    except ClientError as ex:
        await aio.ensure_io_bound(
            rollbar.report_message,
            'Error: Couldn\'nt update vulnerability',
            'error',
            extra_data=ex,
            payload_data=locals()
        )

    return success


def create(data: Dict[str, FindingType]) -> bool:
    """Add vulnerabilities."""
    resp = False
    try:
        item = {
            'finding_id': str(data.get('finding_id')),
            'UUID': str(data.get('UUID')),
            'vuln_type': data.get('vuln_type'),
            'where': data.get('where'),
            'specific': str(data.get('specific')),
            'historic_state': data.get('historic_state')
        }
        if 'treatment_manager' in data:
            item['treatment_manager'] = data.get('treatment_manager')
        response = TABLE.put_item(
            Item=item
        )
        resp = response['ResponseMetadata']['HTTPStatusCode'] == 200
    except ClientError:
        rollbar.report_exc_info()
    return resp


async def delete(uuid: str, finding_id: str) -> bool:
    """Delete a vulnerability of a finding."""
    resp = False
    try:
        delete_attrs = DynamoDeleteType(
            Key={
                'UUID': uuid,
                'finding_id': finding_id
            }
        )
        resp = await dynamodb.async_delete_item(TABLE_NAME, delete_attrs)
    except ClientError as ex:
        await aio.ensure_io_bound(
            rollbar.report_message,
            'Error: Couldn\'nt delete vulnerability',
            'error',
            extra_data=ex,
            payload_data=locals()
        )
    return resp


def get(finding_id: str, vuln_type: str = '', where: str = '',
        specific: str = '', uuid: str = '') -> List[Dict[str, FindingType]]:
    """Get a vulnerability."""
    hash_key = 'finding_id'
    if finding_id and uuid:
        range_key = 'UUID'
        key_exp: object = (
            Key(hash_key).eq(finding_id) &
            Key(range_key).eq(uuid)
        )
        response = TABLE.query(KeyConditionExpression=key_exp)
    elif finding_id and vuln_type and where and specific:
        key_exp = Key(hash_key).eq(finding_id)
        filtering_exp = (
            Attr('vuln_type').eq(vuln_type) &
            Attr('where').eq(where) &
            Attr('specific').eq(str(specific))
        )
        response = TABLE.query(
            KeyConditionExpression=key_exp,
            FilterExpression=filtering_exp)
    else:
        response = TABLE.query()
    items = response['Items']
    while response.get('LastEvaluatedKey'):
        if filtering_exp:
            response = TABLE.query(
                KeyConditionExpression=key_exp,
                FilterExpression=filtering_exp,
                ExclusiveStartKey=response['LastEvaluatedKey']
            )
        else:
            response = TABLE.query(
                KeyConditionExpression=key_exp,
                ExclusiveStartKey=response['LastEvaluatedKey']
            )
        items += response['Items']
    return items


async def request_verification(vuln: Dict[str, FindingType]) -> bool:
    tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
    today = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    historic_verification = cast(
        List[Dict[str, str]],
        vuln.get('historic_verification', [])
    )
    new_state: Dict[str, str] = {
        'date': today,
        'status': 'REQUESTED',
    }
    historic_verification.append(new_state)
    return await update(
        str(vuln.get('finding_id', '')),
        str(vuln.get('UUID', '')),
        {'historic_verification': historic_verification}
    )


async def verify_vulnerability(vuln: Dict[str, FindingType]) -> bool:
    tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
    today = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    historic_verification = cast(
        List[Dict[str, str]],
        vuln.get('historic_verification', [])
    )
    new_state: Dict[str, str] = {
        'date': today,
        'status': 'VERIFIED',
    }
    historic_verification.append(new_state)
    return await update(
        str(vuln.get('finding_id', '')),
        str(vuln.get('UUID', '')),
        {'historic_verification': historic_verification}
    )


async def upload_file(vuln_file: ContentFile) -> str:
    file_path = vuln_file.name
    file_name = file_path.split('/')[-1]
    if not await s3.upload_memory_file(  # type: ignore
            VULNS_BUCKET, vuln_file, file_name):
        raise ErrorUploadingFileS3()
    return file_name


def sign_url(vuln_file_name: str) -> str:
    return cloudfront.sign_url(
        FI_CLOUDFRONT_REPORTS_DOMAIN,
        vuln_file_name,
        1.0 / 6
    )
