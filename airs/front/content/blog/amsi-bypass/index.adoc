:page-slug: amsi-bypass/
:page-date: 2021-07-09
:page-category: attacks
:page-subtitle: Dynamic in-memory AMSI bypass
:page-tags: vulnerability, hacking, exploit, discovery
:page-image: https://res.cloudinary.com/fluid-attacks/image/upload/v1625837523/blog/amsi-bypass/cover-amsi-bypass_sa9bdi.webp
:page-alt: Photo by Calvin Ma on Unsplash
:page-description: In this article we will be able to bypass AMSI using memory patching.
:page-keywords: Business, Information, Security, Protection, Hacking, Exploit, Ethical Hacking, Pentesting, Bypass
:page-author: Andres Roldan
:page-writer: aroldan
:name: Andres Roldan
:about1: Cybersecurity Specialist, OSCE, OSWP, OSCP, CRTP, CRTE, eWPT
:about2: "We don't need the key, we'll break in" RATM
:source: https://unsplash.com/photos/sCrnFwDYMFs

= AMSI bypass using memory patching

Most of us have faced `AMSI` and had suffered the constraints it poses
whenever we want to load a fancy PowerShell module like
link:https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon[PowerView]
or
link:https://github.com/PowerShellMafia/PowerSploit/tree/master/Exfiltration[Invoke-Mimikatz]
in the middle of a link:../../solutions/red-teaming[Red Team] engagement.

Antimalware Scan Interface or `AMSI` is an programmatic resource offered by
Microsoft to enable an interface to any application for interacting with
any anti-malware product available on the machine. `AMSI` is EDR-agnostic and
can be integrated with any vendor. When `AMSI` appears on stage, something like
this should be familiar:

image::https://res.cloudinary.com/fluid-attacks/image/upload/v1625837510/blog/amsi-bypass/amsi1_glc7wk.webp[AMSI in action]

Programmatically, `AMSI` can be included in an application using
link:https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-functions[Win32 API]
functions and  the `IAmsiStream` `COM`
link:https://docs.microsoft.com/en-us/windows/win32/api/amsi/nn-amsi-iamsistream[interface].

As result, if an application was built with `AMSI`, `amsi.dll` will become
part of the runtime modules of the application. Hence, it is seen as a `DLL`
that is loaded at runtime when the application starts. The basic architecture
of `AMSI` is the following:

.Source link:https://docs.microsoft.com/en-us/windows/win32/amsi/how-amsi-helps[Microsoft]
image::https://res.cloudinary.com/fluid-attacks/image/upload/v1625837511/blog/amsi-bypass/amsi7archi_hlwvqp.png[AMSI Architecture]

As you can see, the functions responsible for checking the content for
malicious content are `AmsiScanBuffer()` and `AmsiScanString()`. Those
functions act as the entry point that use the application to send the
suspected tainted input to the underlying antivirus software.

Using a tool like
link:https://processhacker.sourceforge.io/[Process Hacker] it is possible to
check the runtime modules on any process in the system. Checking the process
of our PowerShell session, we can see the `AMSI` `DLL` loaded in memory:

image::https://res.cloudinary.com/fluid-attacks/image/upload/v1625837510/blog/amsi-bypass/amsidll1_mve67c.webp[AMSI DLL]

We can also check the exported symbols which are the functions that are
provided as the high level interface with `AMSI`.
Here we can see all the exported functions which compose `AMSI`, including
`AmsiScanBuffer()` and `AmsiScanString()`.

image::https://res.cloudinary.com/fluid-attacks/image/upload/v1625837510/blog/amsi-bypass/amsiexports1_ogosn2.webp[AMSI Exports]

However, those two functions are really not different. In fact,
`AmsiScanString()` is a small function which uses `AmsiScanBuffer()`
underneath. This can be seen in WinDBG:

image::https://res.cloudinary.com/fluid-attacks/image/upload/v1625837511/blog/amsi-bypass/amsistring0_tdxnw1.webp[AmsiScanString()]

And with a disassembler:

image::https://res.cloudinary.com/fluid-attacks/image/upload/v1625837512/blog/amsi-bypass/amsistring1_gityf1.webp[AmsiScanString()]

So, if we can bypass the checks performed by `AmsiScanBuffer()`, we can also
bypass `AmsiScanString()`!

Let's get it done!

Here, we can see the disassembly graph of `AmsiScanBuffer()`:

image::https://res.cloudinary.com/fluid-attacks/image/upload/v1625837532/blog/amsi-bypass/amsiscanbuffer1_bqcyo9.webp[AmsiScanBuffer()]

As you can see, it is not a complex function either.

At the end of the function, we can see this:

image::https://res.cloudinary.com/fluid-attacks/image/upload/v1625837510/blog/amsi-bypass/amsiscanbuffer2_oxibne.webp[AmsiScanBuffer()]

It seems that the actual anti-malware scanning is performed in the instructions
that composes the big box of the left. Also, we notice that several `JMP`
instructions land in `mov eax 0x800700057` and then the function ends. The
value `0x80070057` is an standardize error code from Microsoft which is
`E_INVALIDARG`. In this case, it's used by `AmsiScanBuffer()` to return when
the parameters passed by the caller code are not valid.

So, what would happen if we modify the `AmsiScanBuffer()` function in memory
to bypass the anti-malware checking instructions altogether and force it
to always return `0x80070057`? Let's check it!

First, let's check that instructions using WinDBG:

image::https://res.cloudinary.com/fluid-attacks/image/upload/v1625837536/blog/amsi-bypass/amsiscanbuffer3_f0sb0r.webp[AmsiScanBuffer() disassembly]

Here we can see the disassembled instructions of `AmsiScanBuffer()`. We
can also see the byte-code corresponding to the `mov eax,80070057h`
instruction: `b857000780`.

Using that information, we can modify the very beginning of `AmsiScanBuffer()`
with the following instructions:

[source,x86asm]
----
b857000780          mov eax,0x80070057
c3                  ret
----

That would move the `E_INVALIDARG` value (`0x80070057`) to `EAX`, making it the
return value of `AmsiScanBuffer()` and then the function ends with a `RET` .
As can be seen above, the bytes `b857000780` and `c3` are the byte-codes of
those instructions.

We can do the memory patching using link:../hevd-dos/[WinDBG].
The steps are:

* Attach the current PowerShell session to WinDBG.
* Break the execution.
* Try to load a common flagged module, for instance `PowerView` to see `AMSI`
in action.
* Check the current instructions of the beginning of `AmsiScanBuffer()`. This
can be accomplished with `u amsi!AmsiScanBuffer` inside WinDBG.
* As we are in a little-endian architecture (`x86_64`), we need to reverse the
byte-code of the `mov eax,0x80070057 | ret` instructions: `c380070057b8`.
* Modify the start of `amsi!AmsiScanBuffer` with those bytes. This can be done
using `eq amsi!AmsiScanBuffer c380070057b8`.
* Resume the execution.
* Load again `PowerView`.
* Enjoy an `AMSI`-free PowerShell session!

Let's check the bypass in action:

image::https://res.cloudinary.com/fluid-attacks/image/upload/v1625837525/blog/amsi-bypass/success1_e0ak8t.webp[AMSI Bypass]

But returning `80070057` is not the only way to bypass `AmsiScanBuffer()`.
In fact, we can make it return `0`, using something like `sub eax,eax | ret`
and the bypass will be successful as well.

Let's see:

image::https://res.cloudinary.com/fluid-attacks/image/upload/v1625854245/blog/amsi-bypass/success2_zrp8re.webp[AMSI Bypass v2]

Success! Now we can use `PowerView`, `Invoke-Mimikatz` or any other
 link:../../solutions/red-teaming[Red Team] tools!

image::https://res.cloudinary.com/fluid-attacks/image/upload/v1625837515/blog/amsi-bypass/tools1_t2h47m.webp[AMSI Bypass]


== Conclusion

Memory patching is a nice trick to use to modify the behavior of running
applications. Keep in mind that this technique is not persistent.
The modification of `AmsiScanBuffer()` is performed
*on the memory of the PowerView process* and the original `amsi.dll` is never
touched on disk.
