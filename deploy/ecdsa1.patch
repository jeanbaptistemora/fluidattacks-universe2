diff -urN tlslite-ng/.git/config tlslite-ng-simple-ecdsa-support/.git/config
--- tlslite-ng/.git/config	2019-09-27 09:14:00.218090116 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/config	1969-12-31 19:00:00.000000000 -0500
@@ -1,11 +0,0 @@
-[core]
-	repositoryformatversion = 0
-	filemode = true
-	bare = false
-	logallrefupdates = true
-[remote "origin"]
-	url = https://github.com/tomato42/tlslite-ng.git
-	fetch = +refs/heads/*:refs/remotes/origin/*
-[branch "master"]
-	remote = origin
-	merge = refs/heads/master
diff -urN tlslite-ng/.git/description tlslite-ng-simple-ecdsa-support/.git/description
--- tlslite-ng/.git/description	2019-09-27 09:13:55.378035735 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/description	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-Unnamed repository; edit this file 'description' to name the repository.
diff -urN tlslite-ng/.git/HEAD tlslite-ng-simple-ecdsa-support/.git/HEAD
--- tlslite-ng/.git/HEAD	2019-09-27 09:14:00.216090094 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/HEAD	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-ref: refs/heads/master
diff -urN tlslite-ng/.git/hooks/applypatch-msg.sample tlslite-ng-simple-ecdsa-support/.git/hooks/applypatch-msg.sample
--- tlslite-ng/.git/hooks/applypatch-msg.sample	2019-09-27 09:13:55.382035780 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/hooks/applypatch-msg.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,15 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message taken by
-# applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.  The hook is
-# allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "applypatch-msg".
-
-. git-sh-setup
-commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
-test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
-:
diff -urN tlslite-ng/.git/hooks/commit-msg.sample tlslite-ng-simple-ecdsa-support/.git/hooks/commit-msg.sample
--- tlslite-ng/.git/hooks/commit-msg.sample	2019-09-27 09:13:55.382035780 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/hooks/commit-msg.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,24 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message.
-# Called by "git commit" with one argument, the name of the file
-# that has the commit message.  The hook should exit with non-zero
-# status after issuing an appropriate message if it wants to stop the
-# commit.  The hook is allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "commit-msg".
-
-# Uncomment the below to add a Signed-off-by line to the message.
-# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
-# hook is more suited to it.
-#
-# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
-
-# This example catches duplicate Signed-off-by lines.
-
-test "" = "$(grep '^Signed-off-by: ' "$1" |
-	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
-	echo >&2 Duplicate Signed-off-by lines.
-	exit 1
-}
diff -urN tlslite-ng/.git/hooks/fsmonitor-watchman.sample tlslite-ng-simple-ecdsa-support/.git/hooks/fsmonitor-watchman.sample
--- tlslite-ng/.git/hooks/fsmonitor-watchman.sample	2019-09-27 09:13:55.381035769 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/hooks/fsmonitor-watchman.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,114 +0,0 @@
-#!/usr/bin/perl
-
-use strict;
-use warnings;
-use IPC::Open2;
-
-# An example hook script to integrate Watchman
-# (https://facebook.github.io/watchman/) with git to speed up detecting
-# new and modified files.
-#
-# The hook is passed a version (currently 1) and a time in nanoseconds
-# formatted as a string and outputs to stdout all files that have been
-# modified since the given time. Paths must be relative to the root of
-# the working tree and separated by a single NUL.
-#
-# To enable this hook, rename this file to "query-watchman" and set
-# 'git config core.fsmonitor .git/hooks/query-watchman'
-#
-my ($version, $time) = @ARGV;
-
-# Check the hook interface version
-
-if ($version == 1) {
-	# convert nanoseconds to seconds
-	$time = int $time / 1000000000;
-} else {
-	die "Unsupported query-fsmonitor hook version '$version'.\n" .
-	    "Falling back to scanning...\n";
-}
-
-my $git_work_tree;
-if ($^O =~ 'msys' || $^O =~ 'cygwin') {
-	$git_work_tree = Win32::GetCwd();
-	$git_work_tree =~ tr/\\/\//;
-} else {
-	require Cwd;
-	$git_work_tree = Cwd::cwd();
-}
-
-my $retry = 1;
-
-launch_watchman();
-
-sub launch_watchman {
-
-	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
-	    or die "open2() failed: $!\n" .
-	    "Falling back to scanning...\n";
-
-	# In the query expression below we're asking for names of files that
-	# changed since $time but were not transient (ie created after
-	# $time but no longer exist).
-	#
-	# To accomplish this, we're using the "since" generator to use the
-	# recency index to select candidate nodes and "fields" to limit the
-	# output to file names only. Then we're using the "expression" term to
-	# further constrain the results.
-	#
-	# The category of transient files that we want to ignore will have a
-	# creation clock (cclock) newer than $time_t value and will also not
-	# currently exist.
-
-	my $query = <<"	END";
-		["query", "$git_work_tree", {
-			"since": $time,
-			"fields": ["name"],
-			"expression": ["not", ["allof", ["since", $time, "cclock"], ["not", "exists"]]]
-		}]
-	END
-
-	print CHLD_IN $query;
-	close CHLD_IN;
-	my $response = do {local $/; <CHLD_OUT>};
-
-	die "Watchman: command returned no output.\n" .
-	    "Falling back to scanning...\n" if $response eq "";
-	die "Watchman: command returned invalid output: $response\n" .
-	    "Falling back to scanning...\n" unless $response =~ /^\{/;
-
-	my $json_pkg;
-	eval {
-		require JSON::XS;
-		$json_pkg = "JSON::XS";
-		1;
-	} or do {
-		require JSON::PP;
-		$json_pkg = "JSON::PP";
-	};
-
-	my $o = $json_pkg->new->utf8->decode($response);
-
-	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
-		print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
-		$retry--;
-		qx/watchman watch "$git_work_tree"/;
-		die "Failed to make watchman watch '$git_work_tree'.\n" .
-		    "Falling back to scanning...\n" if $? != 0;
-
-		# Watchman will always return all files on the first query so
-		# return the fast "everything is dirty" flag to git and do the
-		# Watchman query just to get it over with now so we won't pay
-		# the cost in git to look up each individual file.
-		print "/\0";
-		eval { launch_watchman() };
-		exit 0;
-	}
-
-	die "Watchman: $o->{error}.\n" .
-	    "Falling back to scanning...\n" if $o->{error};
-
-	binmode STDOUT, ":utf8";
-	local $, = "\0";
-	print @{$o->{files}};
-}
diff -urN tlslite-ng/.git/hooks/post-update.sample tlslite-ng-simple-ecdsa-support/.git/hooks/post-update.sample
--- tlslite-ng/.git/hooks/post-update.sample	2019-09-27 09:13:55.382035780 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/hooks/post-update.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,8 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to prepare a packed repository for use over
-# dumb transports.
-#
-# To enable this hook, rename this file to "post-update".
-
-exec git update-server-info
diff -urN tlslite-ng/.git/hooks/pre-applypatch.sample tlslite-ng-simple-ecdsa-support/.git/hooks/pre-applypatch.sample
--- tlslite-ng/.git/hooks/pre-applypatch.sample	2019-09-27 09:13:55.382035780 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/hooks/pre-applypatch.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed
-# by applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-applypatch".
-
-. git-sh-setup
-precommit="$(git rev-parse --git-path hooks/pre-commit)"
-test -x "$precommit" && exec "$precommit" ${1+"$@"}
-:
diff -urN tlslite-ng/.git/hooks/pre-commit.sample tlslite-ng-simple-ecdsa-support/.git/hooks/pre-commit.sample
--- tlslite-ng/.git/hooks/pre-commit.sample	2019-09-27 09:13:55.383035791 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/hooks/pre-commit.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,49 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed.
-# Called by "git commit" with no arguments.  The hook should
-# exit with non-zero status after issuing an appropriate message if
-# it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-commit".
-
-if git rev-parse --verify HEAD >/dev/null 2>&1
-then
-	against=HEAD
-else
-	# Initial commit: diff against an empty tree object
-	against=$(git hash-object -t tree /dev/null)
-fi
-
-# If you want to allow non-ASCII filenames set this variable to true.
-allownonascii=$(git config --bool hooks.allownonascii)
-
-# Redirect output to stderr.
-exec 1>&2
-
-# Cross platform projects tend to avoid non-ASCII filenames; prevent
-# them from being added to the repository. We exploit the fact that the
-# printable range starts at the space character and ends with tilde.
-if [ "$allownonascii" != "true" ] &&
-	# Note that the use of brackets around a tr range is ok here, (it's
-	# even required, for portability to Solaris 10's /usr/bin/tr), since
-	# the square bracket bytes happen to fall in the designated range.
-	test $(git diff --cached --name-only --diff-filter=A -z $against |
-	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
-then
-	cat <<\EOF
-Error: Attempt to add a non-ASCII file name.
-
-This can cause problems if you want to work with people on other platforms.
-
-To be portable it is advisable to rename the file.
-
-If you know what you are doing you can disable this check using:
-
-  git config hooks.allownonascii true
-EOF
-	exit 1
-fi
-
-# If there are whitespace errors, print the offending file names and fail.
-exec git diff-index --check --cached $against --
diff -urN tlslite-ng/.git/hooks/prepare-commit-msg.sample tlslite-ng-simple-ecdsa-support/.git/hooks/prepare-commit-msg.sample
--- tlslite-ng/.git/hooks/prepare-commit-msg.sample	2019-09-27 09:13:55.383035791 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/hooks/prepare-commit-msg.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,42 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to prepare the commit log message.
-# Called by "git commit" with the name of the file that has the
-# commit message, followed by the description of the commit
-# message's source.  The hook's purpose is to edit the commit
-# message file.  If the hook fails with a non-zero status,
-# the commit is aborted.
-#
-# To enable this hook, rename this file to "prepare-commit-msg".
-
-# This hook includes three examples. The first one removes the
-# "# Please enter the commit message..." help message.
-#
-# The second includes the output of "git diff --name-status -r"
-# into the message, just before the "git status" output.  It is
-# commented because it doesn't cope with --amend or with squashed
-# commits.
-#
-# The third example adds a Signed-off-by line to the message, that can
-# still be edited.  This is rarely a good idea.
-
-COMMIT_MSG_FILE=$1
-COMMIT_SOURCE=$2
-SHA1=$3
-
-/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
-
-# case "$COMMIT_SOURCE,$SHA1" in
-#  ,|template,)
-#    /usr/bin/perl -i.bak -pe '
-#       print "\n" . `git diff --cached --name-status -r`
-# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
-#  *) ;;
-# esac
-
-# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
-# if test -z "$COMMIT_SOURCE"
-# then
-#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
-# fi
diff -urN tlslite-ng/.git/hooks/pre-push.sample tlslite-ng-simple-ecdsa-support/.git/hooks/pre-push.sample
--- tlslite-ng/.git/hooks/pre-push.sample	2019-09-27 09:13:55.382035780 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/hooks/pre-push.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,53 +0,0 @@
-#!/bin/sh
-
-# An example hook script to verify what is about to be pushed.  Called by "git
-# push" after it has checked the remote status, but before anything has been
-# pushed.  If this script exits with a non-zero status nothing will be pushed.
-#
-# This hook is called with the following parameters:
-#
-# $1 -- Name of the remote to which the push is being done
-# $2 -- URL to which the push is being done
-#
-# If pushing without using a named remote those arguments will be equal.
-#
-# Information about the commits which are being pushed is supplied as lines to
-# the standard input in the form:
-#
-#   <local ref> <local sha1> <remote ref> <remote sha1>
-#
-# This sample shows how to prevent push of commits where the log message starts
-# with "WIP" (work in progress).
-
-remote="$1"
-url="$2"
-
-z40=0000000000000000000000000000000000000000
-
-while read local_ref local_sha remote_ref remote_sha
-do
-	if [ "$local_sha" = $z40 ]
-	then
-		# Handle delete
-		:
-	else
-		if [ "$remote_sha" = $z40 ]
-		then
-			# New branch, examine all commits
-			range="$local_sha"
-		else
-			# Update to existing branch, examine new commits
-			range="$remote_sha..$local_sha"
-		fi
-
-		# Check for WIP commit
-		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
-		if [ -n "$commit" ]
-		then
-			echo >&2 "Found WIP commit in $local_ref, not pushing"
-			exit 1
-		fi
-	fi
-done
-
-exit 0
diff -urN tlslite-ng/.git/hooks/pre-rebase.sample tlslite-ng-simple-ecdsa-support/.git/hooks/pre-rebase.sample
--- tlslite-ng/.git/hooks/pre-rebase.sample	2019-09-27 09:13:55.383035791 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/hooks/pre-rebase.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,169 +0,0 @@
-#!/bin/sh
-#
-# Copyright (c) 2006, 2008 Junio C Hamano
-#
-# The "pre-rebase" hook is run just before "git rebase" starts doing
-# its job, and can prevent the command from running by exiting with
-# non-zero status.
-#
-# The hook is called with the following parameters:
-#
-# $1 -- the upstream the series was forked from.
-# $2 -- the branch being rebased (or empty when rebasing the current branch).
-#
-# This sample shows how to prevent topic branches that are already
-# merged to 'next' branch from getting rebased, because allowing it
-# would result in rebasing already published history.
-
-publish=next
-basebranch="$1"
-if test "$#" = 2
-then
-	topic="refs/heads/$2"
-else
-	topic=`git symbolic-ref HEAD` ||
-	exit 0 ;# we do not interrupt rebasing detached HEAD
-fi
-
-case "$topic" in
-refs/heads/??/*)
-	;;
-*)
-	exit 0 ;# we do not interrupt others.
-	;;
-esac
-
-# Now we are dealing with a topic branch being rebased
-# on top of master.  Is it OK to rebase it?
-
-# Does the topic really exist?
-git show-ref -q "$topic" || {
-	echo >&2 "No such branch $topic"
-	exit 1
-}
-
-# Is topic fully merged to master?
-not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
-if test -z "$not_in_master"
-then
-	echo >&2 "$topic is fully merged to master; better remove it."
-	exit 1 ;# we could allow it, but there is no point.
-fi
-
-# Is topic ever merged to next?  If so you should not be rebasing it.
-only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
-only_next_2=`git rev-list ^master           ${publish} | sort`
-if test "$only_next_1" = "$only_next_2"
-then
-	not_in_topic=`git rev-list "^$topic" master`
-	if test -z "$not_in_topic"
-	then
-		echo >&2 "$topic is already up to date with master"
-		exit 1 ;# we could allow it, but there is no point.
-	else
-		exit 0
-	fi
-else
-	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
-	/usr/bin/perl -e '
-		my $topic = $ARGV[0];
-		my $msg = "* $topic has commits already merged to public branch:\n";
-		my (%not_in_next) = map {
-			/^([0-9a-f]+) /;
-			($1 => 1);
-		} split(/\n/, $ARGV[1]);
-		for my $elem (map {
-				/^([0-9a-f]+) (.*)$/;
-				[$1 => $2];
-			} split(/\n/, $ARGV[2])) {
-			if (!exists $not_in_next{$elem->[0]}) {
-				if ($msg) {
-					print STDERR $msg;
-					undef $msg;
-				}
-				print STDERR " $elem->[1]\n";
-			}
-		}
-	' "$topic" "$not_in_next" "$not_in_master"
-	exit 1
-fi
-
-<<\DOC_END
-
-This sample hook safeguards topic branches that have been
-published from being rewound.
-
-The workflow assumed here is:
-
- * Once a topic branch forks from "master", "master" is never
-   merged into it again (either directly or indirectly).
-
- * Once a topic branch is fully cooked and merged into "master",
-   it is deleted.  If you need to build on top of it to correct
-   earlier mistakes, a new topic branch is created by forking at
-   the tip of the "master".  This is not strictly necessary, but
-   it makes it easier to keep your history simple.
-
- * Whenever you need to test or publish your changes to topic
-   branches, merge them into "next" branch.
-
-The script, being an example, hardcodes the publish branch name
-to be "next", but it is trivial to make it configurable via
-$GIT_DIR/config mechanism.
-
-With this workflow, you would want to know:
-
-(1) ... if a topic branch has ever been merged to "next".  Young
-    topic branches can have stupid mistakes you would rather
-    clean up before publishing, and things that have not been
-    merged into other branches can be easily rebased without
-    affecting other people.  But once it is published, you would
-    not want to rewind it.
-
-(2) ... if a topic branch has been fully merged to "master".
-    Then you can delete it.  More importantly, you should not
-    build on top of it -- other people may already want to
-    change things related to the topic as patches against your
-    "master", so if you need further changes, it is better to
-    fork the topic (perhaps with the same name) afresh from the
-    tip of "master".
-
-Let's look at this example:
-
-		   o---o---o---o---o---o---o---o---o---o "next"
-		  /       /           /           /
-		 /   a---a---b A     /           /
-		/   /               /           /
-	       /   /   c---c---c---c B         /
-	      /   /   /             \         /
-	     /   /   /   b---b C     \       /
-	    /   /   /   /             \     /
-    ---o---o---o---o---o---o---o---o---o---o---o "master"
-
-
-A, B and C are topic branches.
-
- * A has one fix since it was merged up to "next".
-
- * B has finished.  It has been fully merged up to "master" and "next",
-   and is ready to be deleted.
-
- * C has not merged to "next" at all.
-
-We would want to allow C to be rebased, refuse A, and encourage
-B to be deleted.
-
-To compute (1):
-
-	git rev-list ^master ^topic next
-	git rev-list ^master        next
-
-	if these match, topic has not merged in next at all.
-
-To compute (2):
-
-	git rev-list master..topic
-
-	if this is empty, it is fully merged to "master".
-
-DOC_END
diff -urN tlslite-ng/.git/hooks/pre-receive.sample tlslite-ng-simple-ecdsa-support/.git/hooks/pre-receive.sample
--- tlslite-ng/.git/hooks/pre-receive.sample	2019-09-27 09:13:55.381035769 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/hooks/pre-receive.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,24 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to make use of push options.
-# The example simply echoes all push options that start with 'echoback='
-# and rejects all pushes when the "reject" push option is used.
-#
-# To enable this hook, rename this file to "pre-receive".
-
-if test -n "$GIT_PUSH_OPTION_COUNT"
-then
-	i=0
-	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
-	do
-		eval "value=\$GIT_PUSH_OPTION_$i"
-		case "$value" in
-		echoback=*)
-			echo "echo from the pre-receive-hook: ${value#*=}" >&2
-			;;
-		reject)
-			exit 1
-		esac
-		i=$((i + 1))
-	done
-fi
diff -urN tlslite-ng/.git/hooks/update.sample tlslite-ng-simple-ecdsa-support/.git/hooks/update.sample
--- tlslite-ng/.git/hooks/update.sample	2019-09-27 09:13:55.382035780 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/hooks/update.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,128 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to block unannotated tags from entering.
-# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
-#
-# To enable this hook, rename this file to "update".
-#
-# Config
-# ------
-# hooks.allowunannotated
-#   This boolean sets whether unannotated tags will be allowed into the
-#   repository.  By default they won't be.
-# hooks.allowdeletetag
-#   This boolean sets whether deleting tags will be allowed in the
-#   repository.  By default they won't be.
-# hooks.allowmodifytag
-#   This boolean sets whether a tag may be modified after creation. By default
-#   it won't be.
-# hooks.allowdeletebranch
-#   This boolean sets whether deleting branches will be allowed in the
-#   repository.  By default they won't be.
-# hooks.denycreatebranch
-#   This boolean sets whether remotely creating branches will be denied
-#   in the repository.  By default this is allowed.
-#
-
-# --- Command line
-refname="$1"
-oldrev="$2"
-newrev="$3"
-
-# --- Safety check
-if [ -z "$GIT_DIR" ]; then
-	echo "Don't run this script from the command line." >&2
-	echo " (if you want, you could supply GIT_DIR then run" >&2
-	echo "  $0 <ref> <oldrev> <newrev>)" >&2
-	exit 1
-fi
-
-if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
-	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
-	exit 1
-fi
-
-# --- Config
-allowunannotated=$(git config --bool hooks.allowunannotated)
-allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
-denycreatebranch=$(git config --bool hooks.denycreatebranch)
-allowdeletetag=$(git config --bool hooks.allowdeletetag)
-allowmodifytag=$(git config --bool hooks.allowmodifytag)
-
-# check for no description
-projectdesc=$(sed -e '1q' "$GIT_DIR/description")
-case "$projectdesc" in
-"Unnamed repository"* | "")
-	echo "*** Project description file hasn't been set" >&2
-	exit 1
-	;;
-esac
-
-# --- Check types
-# if $newrev is 0000...0000, it's a commit to delete a ref.
-zero="0000000000000000000000000000000000000000"
-if [ "$newrev" = "$zero" ]; then
-	newrev_type=delete
-else
-	newrev_type=$(git cat-file -t $newrev)
-fi
-
-case "$refname","$newrev_type" in
-	refs/tags/*,commit)
-		# un-annotated tag
-		short_refname=${refname##refs/tags/}
-		if [ "$allowunannotated" != "true" ]; then
-			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
-			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,delete)
-		# delete tag
-		if [ "$allowdeletetag" != "true" ]; then
-			echo "*** Deleting a tag is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,tag)
-		# annotated tag
-		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
-		then
-			echo "*** Tag '$refname' already exists." >&2
-			echo "*** Modifying a tag is not allowed in this repository." >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,commit)
-		# branch
-		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
-			echo "*** Creating a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,delete)
-		# delete branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/remotes/*,commit)
-		# tracking branch
-		;;
-	refs/remotes/*,delete)
-		# delete tracking branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	*)
-		# Anything else (is there anything else?)
-		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
-		exit 1
-		;;
-esac
-
-# --- Finished
-exit 0
Binary files tlslite-ng/.git/index and tlslite-ng-simple-ecdsa-support/.git/index differ
diff -urN tlslite-ng/.git/info/exclude tlslite-ng-simple-ecdsa-support/.git/info/exclude
--- tlslite-ng/.git/info/exclude	2019-09-27 09:13:55.379035746 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/info/exclude	1969-12-31 19:00:00.000000000 -0500
@@ -1,6 +0,0 @@
-# git ls-files --others --exclude-from=.git/info/exclude
-# Lines that start with '#' are comments.
-# For a project mostly in C, the following would be a good set of
-# exclude patterns (uncomment them if you want to use them):
-# *.[oa]
-# *~
diff -urN tlslite-ng/.git/logs/HEAD tlslite-ng-simple-ecdsa-support/.git/logs/HEAD
--- tlslite-ng/.git/logs/HEAD	2019-09-27 09:14:00.217090105 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/logs/HEAD	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 401712ca8ea16093933991e67d39a344bc1dc627 Andres Roldan <aroldan@fluidattacks.com> 1569593640 -0500	clone: from https://github.com/tomato42/tlslite-ng.git
diff -urN tlslite-ng/.git/logs/refs/heads/master tlslite-ng-simple-ecdsa-support/.git/logs/refs/heads/master
--- tlslite-ng/.git/logs/refs/heads/master	2019-09-27 09:14:00.217090105 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/logs/refs/heads/master	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 401712ca8ea16093933991e67d39a344bc1dc627 Andres Roldan <aroldan@fluidattacks.com> 1569593640 -0500	clone: from https://github.com/tomato42/tlslite-ng.git
diff -urN tlslite-ng/.git/logs/refs/remotes/origin/HEAD tlslite-ng-simple-ecdsa-support/.git/logs/refs/remotes/origin/HEAD
--- tlslite-ng/.git/logs/refs/remotes/origin/HEAD	2019-09-27 09:14:00.216090094 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/logs/refs/remotes/origin/HEAD	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 401712ca8ea16093933991e67d39a344bc1dc627 Andres Roldan <aroldan@fluidattacks.com> 1569593640 -0500	clone: from https://github.com/tomato42/tlslite-ng.git
Binary files tlslite-ng/.git/objects/pack/pack-1fcf425f42d21ae226081e824b95e315258e0433.idx and tlslite-ng-simple-ecdsa-support/.git/objects/pack/pack-1fcf425f42d21ae226081e824b95e315258e0433.idx differ
Binary files tlslite-ng/.git/objects/pack/pack-1fcf425f42d21ae226081e824b95e315258e0433.pack and tlslite-ng-simple-ecdsa-support/.git/objects/pack/pack-1fcf425f42d21ae226081e824b95e315258e0433.pack differ
diff -urN tlslite-ng/.git/packed-refs tlslite-ng-simple-ecdsa-support/.git/packed-refs
--- tlslite-ng/.git/packed-refs	2019-09-27 09:14:00.216090094 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/packed-refs	1969-12-31 19:00:00.000000000 -0500
@@ -1,80 +0,0 @@
-# pack-refs with: peeled fully-peeled sorted 
-3d39d81993eb27acfc4650bd78e876427467597f refs/remotes/origin/autofix/wrapped2_to3_fix
-640745d6420ab1f99788aab6e4fd8970d62540f4 refs/remotes/origin/certificate-transparency-ext
-d512283499fdf28b41dffcfdf4e1a4c3cbc12c63 refs/remotes/origin/client-ecdsa-support
-d2ee9b13d8166992f7f723958a81d574b2856104 refs/remotes/origin/ecdsa-support
-fca578a802159822204c165c1b3ce41e21d10e20 refs/remotes/origin/hello_request
-d3a4b823538aa5492d611130b343056c49cacadd refs/remotes/origin/key-update-support
-401712ca8ea16093933991e67d39a344bc1dc627 refs/remotes/origin/master
-a3c35565ed590f8724ba85008578513f16f867ae refs/remotes/origin/old-ecdsa-support
-14f2c60d93b642f080bef664cc718d2ea1291487 refs/remotes/origin/old-upstream
-67d16128c353cc776f4c5fdd18d227e159ba6425 refs/remotes/origin/ort-3712
-68ecf2438dc959e60620673d5a576305caeed0df refs/remotes/origin/post-handshake-auth
-0199b2d466688c0fc522517bf15459f655a62a1c refs/remotes/origin/simple-ecdsa-support
-b25d22e85e41d2debb710b3eab51a560fc15e912 refs/remotes/origin/timeout-fixes
-8000085e58294e05dce2b3e5dc42c25e896b7511 refs/remotes/origin/tls-intolerance
-2f90ea3ef3907d43b04bef16dcd39325ab2da085 refs/remotes/origin/tlslite-ng-0.5
-719628a46244b9d02fa24da4174cbcda6ce326f3 refs/remotes/origin/tlslite-ng-0.7
-14f2c60d93b642f080bef664cc718d2ea1291487 refs/tags/fork-start
-58188eaa89c96681f7c15b0fb94c7f5a3d69238e refs/tags/v0.3.9x
-^3fe1aece274e0e4118dbeea71530bbba657ab839
-8eae0426c1c85b3e0ead487e309a4a9cbb71e095 refs/tags/v0.4.1
-9aee637fac71a9bcd9bf192330720b5df3bddb4e refs/tags/v0.4.2
-83eaa31b9f9a7ce943dd49f05b6d1322eff38a63 refs/tags/v0.4.3
-6caeab867b49dfa72104a34f1e5ee88b2d511010 refs/tags/v0.4.8
-741f9f8b62ae21cc8ea462a0e0d12ba4e57716e7 refs/tags/v0.5.0
-857da280237402cf607a8ea53652566d2b8ce438 refs/tags/v0.5.0-beta3
-5f788c4266c43fffa5b0e1df1e36dc560adeb74c refs/tags/v0.5.0-beta4
-e0e3d7b4df3f8a7dad405cfe0820e7ee05b818eb refs/tags/v0.5.0-beta6
-6068b82d83b37dfd484d091655af2ddd55c4c30a refs/tags/v0.5.1
-336076afddf199ea71e4eb40786440ea1e3c4f95 refs/tags/v0.5.2
-6f2d849a34b2ba1b44ebe28dd8224b17fdec9d63 refs/tags/v0.6.0
-021bef0edaf8704cae10abed6e2376f44acea7a1 refs/tags/v0.6.0-alpha1
-1923d638579a331f7e0115d16928645e32534143 refs/tags/v0.6.0-alpha2
-9b87ab356d89e5f5f79331b3c935d3e8b3980fc0 refs/tags/v0.6.0-alpha3
-b2d7b362aa0ab625dff2b202427d16ca0b3cc800 refs/tags/v0.6.0-alpha4
-6279f3bf35f78fade5ca1305449c25d9f4a8d7c0 refs/tags/v0.6.0-alpha5
-f9950c8c9df065643b07214ae85a201a87163764 refs/tags/v0.6.0-beta1
-663364b99e79912913c8aadfeb36ad6cfa930533 refs/tags/v0.7.0
-3591a358c80041f749629648273f419481ec9e6e refs/tags/v0.7.0-alpha1
-d69c210826ede718a605271a384377b47ed02777 refs/tags/v0.7.0-alpha2
-73f615ed819593ba313db10acaa4546bc50a0828 refs/tags/v0.7.0-alpha3
-fd670e37498f0e8fb9860164c2e54047d12528dd refs/tags/v0.7.0-alpha4
-cbf4ac97740953d645becb58dbd42ba03dac36f1 refs/tags/v0.7.0-alpha5
-31c7ee1634b506d2a928c2c932335511d15b3220 refs/tags/v0.7.0-alpha6
-f450a90b6a29ef9d3e0742240220c3995a4497e3 refs/tags/v0.7.0-alpha7
-4646646b2ff05b64564ffe857e329b80cbcaac98 refs/tags/v0.7.0-alpha8
-e0f1a75aedcb6db3c9274984d9105e4fc38a7eb0 refs/tags/v0.7.0-alpha9
-6e9855dea2b3b1e2bf9070534dd921a054faa365 refs/tags/v0.7.0-beta1
-2207fb5d7978a699fe3702dcb88103ad7d9fceb6 refs/tags/v0.7.1
-48c454f233947589bf4f8449758c970a399e9847 refs/tags/v0.7.2
-2f24f4edf4645aa6ae597aa768fb9ba7da686a7f refs/tags/v0.7.3
-c9afee632145cfe19e3de32693cf093426699465 refs/tags/v0.7.4
-719628a46244b9d02fa24da4174cbcda6ce326f3 refs/tags/v0.7.5
-ddaf97b06e14603617a8fe35e6039f9bf6070381 refs/tags/v0.8.0-alpha1
-3b9ead628e2513be87f92b714a4a1b097ed00576 refs/tags/v0.8.0-alpha10
-ac9c99a59c3c51abbd6909e76415c6306c3e45d8 refs/tags/v0.8.0-alpha11
-d85eb752aeb37bc5b02834570d3cb5bab4c8a9df refs/tags/v0.8.0-alpha12
-777b4e2ac0e88b2589cb3303839c748ab6095fe2 refs/tags/v0.8.0-alpha13
-7da1a3f726dfbf3ec8ed425b7e098409705b68cf refs/tags/v0.8.0-alpha14
-035e5b5a4e79a2454db2fc1e9d7b9f512874699d refs/tags/v0.8.0-alpha15
-1464d8dc0e29ad50a6d71c4d579f7afa933baaaf refs/tags/v0.8.0-alpha16
-02852484e5ca9ea5e0c69d525ff45a3a999b386b refs/tags/v0.8.0-alpha17
-bc93aa17317f4f3765558cf36249d446b1838987 refs/tags/v0.8.0-alpha18
-af466651a7795ac5a6cf54932d496ca8e79b49bf refs/tags/v0.8.0-alpha19
-69fc79f77e2165e35ca4395fd29843190df74112 refs/tags/v0.8.0-alpha2
-21cebf51b7acf9b6f6313b40b73716adaf344ac7 refs/tags/v0.8.0-alpha20
-460adb1b2ffd3170ba7670b0e7dd9c24d702e4d1 refs/tags/v0.8.0-alpha21
-2a1e00a845dd1d7adc3d74abab40964722bab4f5 refs/tags/v0.8.0-alpha22
-8243cf3140501c7d077cfcdefcef7e3e16cec14c refs/tags/v0.8.0-alpha23
-d61527a01aa92f4ccdcb05316dfbe9b2f20e9882 refs/tags/v0.8.0-alpha24
-76007d5e0bd8c69bb85aad635d06588f7aaae5f6 refs/tags/v0.8.0-alpha25
-029425144f6b26d5ab8acc3a79e3ead79253ad71 refs/tags/v0.8.0-alpha26
-401712ca8ea16093933991e67d39a344bc1dc627 refs/tags/v0.8.0-alpha27
-6498e79f43b6c1ff9ffc0e93f3d781aebdf993bd refs/tags/v0.8.0-alpha3
-270684d207425b184bd308ac5f8f5db9dc84256a refs/tags/v0.8.0-alpha4
-05778bde61ba0be3c8e3b175ace094e53eabb54a refs/tags/v0.8.0-alpha5
-4df30c8c675f7a98b3694d21bb7809cc0abcc5e1 refs/tags/v0.8.0-alpha6
-2ca8c0c15313c73985866007fc7fdfa102fa6d62 refs/tags/v0.8.0-alpha7
-0e8a405d063a5b924b6be512513883eb27993eb8 refs/tags/v0.8.0-alpha8
-2b9c15f697e465e117ff57b89f3ea1537de722e3 refs/tags/v0.8.0-alpha9
diff -urN tlslite-ng/.git/refs/heads/master tlslite-ng-simple-ecdsa-support/.git/refs/heads/master
--- tlslite-ng/.git/refs/heads/master	2019-09-27 09:14:00.217090105 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/refs/heads/master	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-401712ca8ea16093933991e67d39a344bc1dc627
diff -urN tlslite-ng/.git/refs/remotes/origin/HEAD tlslite-ng-simple-ecdsa-support/.git/refs/remotes/origin/HEAD
--- tlslite-ng/.git/refs/remotes/origin/HEAD	2019-09-27 09:14:00.216090094 -0500
+++ tlslite-ng-simple-ecdsa-support/.git/refs/remotes/origin/HEAD	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-ref: refs/remotes/origin/master
diff -urN tlslite-ng/tests/serverECCert.pem tlslite-ng-simple-ecdsa-support/tests/serverECCert.pem
--- tlslite-ng/tests/serverECCert.pem	1969-12-31 19:00:00.000000000 -0500
+++ tlslite-ng-simple-ecdsa-support/tests/serverECCert.pem	2019-09-25 14:20:03.000000000 -0500
@@ -0,0 +1,10 @@
+-----BEGIN CERTIFICATE-----
+MIIBbTCCARSgAwIBAgIJAPM58cskyK+yMAkGByqGSM49BAEwFDESMBAGA1UEAwwJ
+bG9jYWxob3N0MB4XDTE3MTAyMzExNDI0MVoXDTE3MTEyMjExNDI0MVowFDESMBAG
+A1UEAwwJbG9jYWxob3N0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEyDRjEAJe
+3F5T62MyZbhjoJnPLGL2nrTthLFymBupZ2IbnWYnqVWDkT/L6i8sQhf2zCLrlSjj
+1kn7ERqPx/KZyqNQME4wHQYDVR0OBBYEFPfFTUg9o3t6ehLsschSnC8Te8oaMB8G
+A1UdIwQYMBaAFPfFTUg9o3t6ehLsschSnC8Te8oaMAwGA1UdEwQFMAMBAf8wCQYH
+KoZIzj0EAQNIADBFAiA6p0YM5ZzfW+klHPRU2r13/IfKgeRfDR3dtBngmPvxUgIh
+APTeSDeJvYWVBLzyrKTeSerNDKKHU2Rt7sufipv76+7s
+-----END CERTIFICATE-----
diff -urN tlslite-ng/tests/serverECKey.pem tlslite-ng-simple-ecdsa-support/tests/serverECKey.pem
--- tlslite-ng/tests/serverECKey.pem	1969-12-31 19:00:00.000000000 -0500
+++ tlslite-ng-simple-ecdsa-support/tests/serverECKey.pem	2019-09-25 14:20:03.000000000 -0500
@@ -0,0 +1,5 @@
+-----BEGIN PRIVATE KEY-----
+MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgCOZr0Ovs0eCmh+XM
+QWDYVpsQ+sJdjiq/itp/kYnWNSahRANCAATINGMQAl7cXlPrYzJluGOgmc8sYvae
+tO2EsXKYG6lnYhudZiepVYORP8vqLyxCF/bMIuuVKOPWSfsRGo/H8pnK
+-----END PRIVATE KEY-----
diff -urN tlslite-ng/tests/serverP384ECCert.pem tlslite-ng-simple-ecdsa-support/tests/serverP384ECCert.pem
--- tlslite-ng/tests/serverP384ECCert.pem	1969-12-31 19:00:00.000000000 -0500
+++ tlslite-ng-simple-ecdsa-support/tests/serverP384ECCert.pem	2019-09-25 14:20:03.000000000 -0500
@@ -0,0 +1,12 @@
+-----BEGIN CERTIFICATE-----
+MIIBuzCCAUCgAwIBAgIUXnRpq5i0cyDQ1bvx/9HNCvPNS0kwCgYIKoZIzj0EAwIw
+FDESMBAGA1UEAwwJbG9jYWxob3N0MB4XDTE5MDkyNDE5MDU0NVoXDTI5MDkyMTE5
+MDU0NVowFDESMBAGA1UEAwwJbG9jYWxob3N0MHYwEAYHKoZIzj0CAQYFK4EEACID
+YgAEvQl5Mg1IjTzndntcgmWDA5/SCte+uW6haKTNIIldP1N0sLUA5mTxyi5n07h/
+6zNuvzhE/+42ucKiVjRB1TiJGTUiUyRvBfV8qflE4GsQDbtv/u8JKYAKc1tJD7AB
+pYRPo1MwUTAdBgNVHQ4EFgQUmnujKF6/C4TUMpZwyRcPV4ZclfswHwYDVR0jBBgw
+FoAUmnujKF6/C4TUMpZwyRcPV4ZclfswDwYDVR0TAQH/BAUwAwEB/zAKBggqhkjO
+PQQDAgNpADBmAjEA/LzKS2HOxLQuuEskHesrxDA6hKkpL+8Ggyllgbe3ZCWJ7Dq+
+6bsTM7syHtVwi/YQAjEAnQgnzp2OBU7K6adVjPu4Rvj8z1JY6/ZEjOIvhUHDL7ND
+nabWoF+fEWrn6/oiTYkh
+-----END CERTIFICATE-----
diff -urN tlslite-ng/tests/serverP384ECKey.pem tlslite-ng-simple-ecdsa-support/tests/serverP384ECKey.pem
--- tlslite-ng/tests/serverP384ECKey.pem	1969-12-31 19:00:00.000000000 -0500
+++ tlslite-ng-simple-ecdsa-support/tests/serverP384ECKey.pem	2019-09-25 14:20:03.000000000 -0500
@@ -0,0 +1,6 @@
+-----BEGIN PRIVATE KEY-----
+MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDB2WUH+vRvXn6h0A/U9
+i0BO7rMIXa5OW8rt7EM8BXAfhnUqDmWmFrI0nECbjNAU7myhZANiAAS9CXkyDUiN
+POd2e1yCZYMDn9IK1765bqFopM0giV0/U3SwtQDmZPHKLmfTuH/rM26/OET/7ja5
+wqJWNEHVOIkZNSJTJG8F9Xyp+UTgaxANu2/+7wkpgApzW0kPsAGlhE8=
+-----END PRIVATE KEY-----
diff -urN tlslite-ng/tests/serverP521ECCert.pem tlslite-ng-simple-ecdsa-support/tests/serverP521ECCert.pem
--- tlslite-ng/tests/serverP521ECCert.pem	1969-12-31 19:00:00.000000000 -0500
+++ tlslite-ng-simple-ecdsa-support/tests/serverP521ECCert.pem	2019-09-25 14:20:03.000000000 -0500
@@ -0,0 +1,13 @@
+-----BEGIN CERTIFICATE-----
+MIICBTCCAWagAwIBAgIUIM4xqMpH6t3WLCOX8zuGyt0YAOMwCgYIKoZIzj0EAwIw
+FDESMBAGA1UEAwwJbG9jYWxob3N0MB4XDTE5MDkyNDE5MDUyNVoXDTI5MDkyMTE5
+MDUyNVowFDESMBAGA1UEAwwJbG9jYWxob3N0MIGbMBAGByqGSM49AgEGBSuBBAAj
+A4GGAAQBKGIswuKzpL+YTufrWM4IA+eHH6AS/KuJJfwCeNESe+kMPRzkq51wNtWq
+nbNDYFpZPfYejCvvWTm+syWZ9qd8mKAB1e9l0TQdorsVXxTtdiF5bqitThrEovCS
+7uiOn0lKU3A70l06xNF6JLu1EC5b5fZ1BI0vlHGlBDxwOnZcftLy9+6jUzBRMB0G
+A1UdDgQWBBSQ/uAxW+uiIo8BkoXxCXsZLCYORjAfBgNVHSMEGDAWgBSQ/uAxW+ui
+Io8BkoXxCXsZLCYORjAPBgNVHRMBAf8EBTADAQH/MAoGCCqGSM49BAMCA4GMADCB
+iAJCAeyvcn/1xWhpe/W46I2GMARgY/wE6K+0Xo9o3jsgyTMcVrjl9irotxUgW7kY
+wqR+J2E8AiPpnvQ37SkaLQC289dlAkIAsh5cybNKIeEVdSPNY3dLA3HT5F2acm2S
+gq99uAqJ6kmE+eFL0G/UWMbgvZ12fzbm9YjoIeKopgq12NhUURQtj1c=
+-----END CERTIFICATE-----
diff -urN tlslite-ng/tests/serverP521ECKey.pem tlslite-ng-simple-ecdsa-support/tests/serverP521ECKey.pem
--- tlslite-ng/tests/serverP521ECKey.pem	1969-12-31 19:00:00.000000000 -0500
+++ tlslite-ng-simple-ecdsa-support/tests/serverP521ECKey.pem	2019-09-25 14:20:03.000000000 -0500
@@ -0,0 +1,8 @@
+-----BEGIN PRIVATE KEY-----
+MIHuAgEAMBAGByqGSM49AgEGBSuBBAAjBIHWMIHTAgEBBEIBERKX+ubIlLMTQGG8
+cJgErwtph4DtG72I8ZX86vHQcWIMZnfUlBQJqDqRKgYAooYS9QycyLim94kDo7CX
+opJXPvuhgYkDgYYABAEoYizC4rOkv5hO5+tYzggD54cfoBL8q4kl/AJ40RJ76Qw9
+HOSrnXA21aqds0NgWlk99h6MK+9ZOb6zJZn2p3yYoAHV72XRNB2iuxVfFO12IXlu
+qK1OGsSi8JLu6I6fSUpTcDvSXTrE0Xoku7UQLlvl9nUEjS+UcaUEPHA6dlx+0vL3
+7g==
+-----END PRIVATE KEY-----
diff -urN tlslite-ng/tests/tlstest.py tlslite-ng-simple-ecdsa-support/tests/tlstest.py
--- tlslite-ng/tests/tlstest.py	2019-09-27 09:14:00.238090341 -0500
+++ tlslite-ng-simple-ecdsa-support/tests/tlstest.py	2019-09-25 14:20:03.000000000 -0500
@@ -190,6 +190,22 @@
 
     test_no += 1
 
+    print("Test {0} - good X.509/w RSA-PSS cert in TLSv1.2".format(test_no))
+    synchro.recv(1)
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 3)
+    settings.maxVersion = (3, 3)
+    connection.handshakeClientCert(serverName=address[0], settings=settings)
+    testConnClient(connection)
+    assert(isinstance(connection.session.serverCertChain, X509CertChain))
+    assert(connection.session.serverName == address[0])
+    assert(connection.session.cipherSuite in constants.CipherSuite.aeadSuites)
+    assert(connection.encryptThenMAC == False)
+    connection.close()
+
+    test_no += 1
+
     print("Test {0} - good X.509, small record_size_limit".format(test_no))
     synchro.recv(1)
     connection = connect()
@@ -215,6 +231,135 @@
 
     test_no += 1
 
+    print("Test {0} - good X.509 ECDSA, SSLv3".format(test_no))
+    synchro.recv(1)
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 0)
+    settings.maxVersion = (3, 0)
+    connection.handshakeClientCert(settings=settings)
+    testConnClient(connection)
+    assert connection.session.cipherSuite in\
+            constants.CipherSuite.ecdheEcdsaSuites
+    assert isinstance(connection.session.serverCertChain, X509CertChain)
+    connection.close()
+
+    test_no += 1
+
+    print("Test {0} - good X.509 ECDSA, TLSv1.0".format(test_no))
+    synchro.recv(1)
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 1)
+    settings.maxVersion = (3, 1)
+    connection.handshakeClientCert(settings=settings)
+    testConnClient(connection)
+    assert connection.session.cipherSuite in\
+            constants.CipherSuite.ecdheEcdsaSuites
+    assert isinstance(connection.session.serverCertChain, X509CertChain)
+    connection.close()
+
+    test_no += 1
+
+    print("Test {0} - good X.509 ECDSA, TLSv1.2".format(test_no))
+    synchro.recv(1)
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 3)
+    settings.maxVersion = (3, 3)
+    connection.handshakeClientCert(settings=settings)
+    testConnClient(connection)
+    assert connection.session.cipherSuite in\
+            constants.CipherSuite.ecdheEcdsaSuites
+    assert isinstance(connection.session.serverCertChain, X509CertChain)
+    connection.close()
+
+    test_no += 1
+
+    print("Test {0} - mismatched ECDSA curve, TLSv1.2".format(test_no))
+    synchro.recv(1)
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 3)
+    settings.maxVersion = (3, 3)
+    settings.eccCurves = ["secp384r1"]
+    settings.keyShares = []
+    try:
+        connection.handshakeClientCert(settings=settings)
+        assert False
+    except TLSLocalAlert as e:
+        assert "certificate with curve" in str(e)
+    connection.close()
+
+    test_no += 1
+
+    print("Test {0} - good X.509 ECDSA, TLSv1.3".format(test_no))
+    synchro.recv(1)
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 4)
+    settings.maxVersion = (3, 4)
+    connection.handshakeClientCert(settings=settings)
+    testConnClient(connection)
+    assert connection.session.cipherSuite in\
+            constants.CipherSuite.tls13Suites
+    assert isinstance(connection.session.serverCertChain, X509CertChain)
+    assert len(connection.session.serverCertChain.getEndEntityPublicKey()) \
+            == 256
+    connection.close()
+
+    test_no += 1
+
+    print("Test {0} - mismatched ECDSA curve, TLSv1.3".format(test_no))
+    synchro.recv(1)
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 4)
+    settings.maxVersion = (3, 4)
+    settings.ecdsaSigHashes = ["sha384", "sha512"]
+    try:
+        connection.handshakeClientCert(settings=settings)
+        assert False
+    except TLSRemoteAlert as e:
+        assert "handshake_failure" in str(e)
+    connection.close()
+
+    test_no += 1
+
+    print("Test {0} - good X.509 P-384 ECDSA, TLSv1.3".format(test_no))
+    synchro.recv(1)
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 4)
+    settings.maxVersion = (3, 4)
+    connection.handshakeClientCert(settings=settings)
+    testConnClient(connection)
+    assert connection.session.cipherSuite in\
+            constants.CipherSuite.tls13Suites
+    assert isinstance(connection.session.serverCertChain, X509CertChain)
+    assert len(connection.session.serverCertChain.getEndEntityPublicKey()) \
+            == 384
+    connection.close()
+
+    test_no += 1
+
+    print("Test {0} - good X.509 P-521 ECDSA, TLSv1.3".format(test_no))
+    synchro.recv(1)
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 4)
+    settings.maxVersion = (3, 4)
+    connection.handshakeClientCert(settings=settings)
+    testConnClient(connection)
+    assert connection.session.cipherSuite in\
+            constants.CipherSuite.tls13Suites
+    assert isinstance(connection.session.serverCertChain, X509CertChain)
+    assert len(connection.session.serverCertChain.getEndEntityPublicKey()) \
+            == 521
+    connection.close()
+
+    test_no += 1
+
     print("Test {0} - good X.509, mismatched key_share".format(test_no))
     synchro.recv(1)
     connection = connect()
@@ -1069,10 +1214,11 @@
         s.settimeout(15)
         return TLSConnection(s)
 
-    x509Cert = X509().parse(open(os.path.join(dir, "serverX509Cert.pem")).read())
+    with open(os.path.join(dir, "serverX509Cert.pem")) as f:
+        x509Cert = X509().parse(f.read())
     x509Chain = X509CertChain([x509Cert])
-    s = open(os.path.join(dir, "serverX509Key.pem")).read()
-    x509Key = parsePEMKey(s, private=True)
+    with open(os.path.join(dir, "serverX509Key.pem")) as f:
+        x509Key = parsePEMKey(f.read(), private=True)
 
     with open(os.path.join(dir, "serverRSAPSSSigCert.pem")) as f:
         x509CertRSAPSSSig = X509().parse(f.read())
@@ -1088,6 +1234,28 @@
         x509KeyRSAPSS = parsePEMKey(f.read(), private=True,
                                     implementations=["python"])
 
+    with open(os.path.join(dir, "serverECCert.pem")) as f:
+        x509CertECDSA = X509().parse(f.read())
+    x509ecdsaChain = X509CertChain([x509CertECDSA])
+    assert x509CertECDSA.certAlg == "ecdsa"
+    with open(os.path.join(dir, "serverECKey.pem")) as f:
+        x509ecdsaKey = parsePEMKey(f.read(), private=True,
+                                   implementations=["python"])
+    with open(os.path.join(dir, "serverP384ECCert.pem")) as f:
+        x509CertP384ECDSA = X509().parse(f.read())
+    x509ecdsaP384Chain = X509CertChain([x509CertP384ECDSA])
+    assert x509CertP384ECDSA.certAlg == "ecdsa"
+    with open(os.path.join(dir, "serverP384ECKey.pem")) as f:
+        x509ecdsaP384Key = parsePEMKey(f.read(), private=True,
+                                       implementations=["python"])
+    with open(os.path.join(dir, "serverP521ECCert.pem")) as f:
+        x509CertP521ECDSA = X509().parse(f.read())
+    x509ecdsaP521Chain = X509CertChain([x509CertP521ECDSA])
+    assert x509CertP521ECDSA.certAlg == "ecdsa"
+    with open(os.path.join(dir, "serverP521ECKey.pem")) as f:
+        x509ecdsaP521Key = parsePEMKey(f.read(), private=True,
+                                       implementations=["python"])
+
     test_no = 0
 
     print("Test {0} - Anonymous server handshake".format(test_no))
@@ -1163,6 +1331,22 @@
 
     test_no += 1
 
+    print("Test {0} - good X.509/w RSA-PSS cert".format(test_no))
+    synchro.send(b'R')
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 3)
+    settings.maxVersion = (3, 3)
+    connection.handshakeServer(certChain=x509ChainRSAPSS,
+                               privateKey=x509KeyRSAPSS,
+                               settings=settings)
+    assert(connection.session.serverName == address[0])
+    assert(connection.extendedMasterSecret)
+    testConnServer(connection)
+    connection.close()
+
+    test_no += 1
+
     print("Test {0} - good X.509, small record_size_limit".format(test_no))
     synchro.send(b'R')
     connection = connect()
@@ -1185,6 +1369,122 @@
     testConnServer(connection)
     connection.close()
 
+    test_no += 1
+
+    print("Test {0} - good X.509 ECDSA, SSLv3".format(test_no))
+    synchro.send(b'R')
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 0)
+    settings.maxVersion = (3, 0)
+    connection.handshakeServer(certChain=x509ecdsaChain,
+                               privateKey=x509ecdsaKey, settings=settings)
+    assert not connection.extendedMasterSecret
+    testConnServer(connection)
+    connection.close()
+
+    test_no += 1
+
+    print("Test {0} - good X.509 ECDSA, TLSv1.0".format(test_no))
+    synchro.send(b'R')
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 1)
+    settings.maxVersion = (3, 1)
+    connection.handshakeServer(certChain=x509ecdsaChain,
+                               privateKey=x509ecdsaKey, settings=settings)
+    assert connection.extendedMasterSecret
+    testConnServer(connection)
+    connection.close()
+
+    test_no += 1
+
+    print("Test {0} - good X.509 ECDSA, TLSv1.2".format(test_no))
+    synchro.send(b'R')
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 3)
+    settings.maxVersion = (3, 3)
+    connection.handshakeServer(certChain=x509ecdsaChain,
+                               privateKey=x509ecdsaKey, settings=settings)
+    assert connection.extendedMasterSecret
+    testConnServer(connection)
+    connection.close()
+
+    test_no += 1
+
+    print("Test {0} - mismatched ECDSA curve, TLSv1.2".format(test_no))
+    synchro.send(b'R')
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 3)
+    settings.maxVersion = (3, 3)
+    try:
+        connection.handshakeServer(certChain=x509ecdsaChain,
+                                   privateKey=x509ecdsaKey, settings=settings)
+    except TLSRemoteAlert as e:
+        assert "handshake_failure" in str(e)
+    connection.close()
+
+    test_no += 1
+
+    print("Test {0} - good X.509 ECDSA, TLSv1.3".format(test_no))
+    synchro.send(b'R')
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 4)
+    settings.maxVersion = (3, 4)
+    connection.handshakeServer(certChain=x509ecdsaChain,
+                               privateKey=x509ecdsaKey, settings=settings)
+    assert connection.extendedMasterSecret
+    testConnServer(connection)
+    connection.close()
+
+    test_no += 1
+
+    # check what happens when client doesn't advertise support for signature
+    # algoritm compatible with server key
+    print("Test {0} - mismatched ECDSA curve, TLSv1.3".format(test_no))
+    synchro.send(b'R')
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 4)
+    settings.maxVersion = (3, 4)
+    try:
+        connection.handshakeServer(certChain=x509ecdsaChain,
+                                   privateKey=x509ecdsaKey, settings=settings)
+    except TLSLocalAlert as e:
+        assert "No common signature algorithms" in str(e)
+    connection.close()
+
+    test_no += 1
+
+    print("Test {0} - good X.509 P-384 ECDSA, TLSv1.3".format(test_no))
+    synchro.send(b'R')
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 4)
+    settings.maxVersion = (3, 4)
+    connection.handshakeServer(certChain=x509ecdsaP384Chain,
+                               privateKey=x509ecdsaP384Key, settings=settings)
+    assert connection.extendedMasterSecret
+    testConnServer(connection)
+    connection.close()
+
+    test_no += 1
+
+    print("Test {0} - good X.509 P-521 ECDSA, TLSv1.3".format(test_no))
+    synchro.send(b'R')
+    connection = connect()
+    settings = HandshakeSettings()
+    settings.minVersion = (3, 4)
+    settings.maxVersion = (3, 4)
+    connection.handshakeServer(certChain=x509ecdsaP521Chain,
+                               privateKey=x509ecdsaP521Key, settings=settings)
+    assert connection.extendedMasterSecret
+    testConnServer(connection)
+    connection.close()
+
     test_no += 1
 
     print("Test {0} - good X.509, mismatched key_share".format(test_no))
diff -urN tlslite-ng/tlslite/constants.py tlslite-ng-simple-ecdsa-support/tlslite/constants.py
--- tlslite-ng/tlslite/constants.py	2019-09-27 09:14:00.240090363 -0500
+++ tlslite-ng-simple-ecdsa-support/tlslite/constants.py	2019-09-25 14:20:03.000000000 -0500
@@ -80,6 +80,9 @@
     dss_sign = 2
     rsa_fixed_dh = 3
     dss_fixed_dh = 4
+    ecdsa_sign = 64  # RFC 8422
+    rsa_fixed_ecdh = 65  # RFC 8422
+    ecdsa_fixed_ecdh = 66  # RFC 8422
 
 
 class SSL2HandshakeType(TLSEnum):
@@ -208,6 +211,9 @@
     rsa_pkcs1_sha256 = (4, 1)
     rsa_pkcs1_sha384 = (5, 1)
     rsa_pkcs1_sha512 = (6, 1)
+    ecdsa_secp256r1_sha256 = (4, 3)
+    ecdsa_secp384r1_sha384 = (5, 3)
+    ecdsa_secp521r1_sha512 = (6, 3)
     rsa_pss_rsae_sha256 = (8, 4)
     rsa_pss_rsae_sha384 = (8, 5)
     rsa_pss_rsae_sha512 = (8, 6)
@@ -273,7 +279,7 @@
             kType, _, hName = vals
         else:
             kType, _, _, hName = vals
-        assert kType == 'rsa'
+        assert kType in ('rsa', 'ecdsa')
         return hName
 
 
@@ -764,12 +770,16 @@
     # ChaCha20/Poly1305 based Cipher Suites for TLS1.2
     TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_draft_00 = 0xCCA1
     ietfNames[0xCCA1] = 'TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_draft_00'
+    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_draft_00 = 0xCCA2
+    ietfNames[0xCCA2] = 'TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_draft_00'
     TLS_DHE_RSA_WITH_CHACHA20_POLY1305_draft_00 = 0xCCA3
     ietfNames[0xCCA3] = 'TLS_DHE_RSA_WITH_CHACHA20_POLY1305_draft_00'
 
     # RFC 7905 - ChaCha20-Poly1305 Cipher Suites for TLS
     TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA8
     ietfNames[0xCCA8] = 'TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256'
+    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA9
+    ietfNames[0xCCA9] = 'TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256'
     TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAA
     ietfNames[0xCCAA] = 'TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256'
 
@@ -780,7 +790,7 @@
 
     #: 3DES CBC ciphers
     tripleDESSuites = []
-    tripleDESSuites.append(TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA)  # unsupp
+    tripleDESSuites.append(TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA)
     tripleDESSuites.append(TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA)  # unsupported
     tripleDESSuites.append(TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA)  # unsupported
     tripleDESSuites.append(TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA)
@@ -801,8 +811,8 @@
     aes128Suites.append(TLS_RSA_WITH_AES_128_CBC_SHA256)
     aes128Suites.append(TLS_DHE_RSA_WITH_AES_128_CBC_SHA256)
     aes128Suites.append(TLS_DH_ANON_WITH_AES_128_CBC_SHA256)
-    aes128Suites.append(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256)  # unsupp
-    aes128Suites.append(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA)  # unsupported
+    aes128Suites.append(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256)
+    aes128Suites.append(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA)
     aes128Suites.append(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256)  # unsupported
     aes128Suites.append(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA)  # unsupported
     aes128Suites.append(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256)  # unsupported
@@ -821,8 +831,8 @@
     aes256Suites.append(TLS_RSA_WITH_AES_256_CBC_SHA256)
     aes256Suites.append(TLS_DHE_RSA_WITH_AES_256_CBC_SHA256)
     aes256Suites.append(TLS_DH_ANON_WITH_AES_256_CBC_SHA256)
-    aes256Suites.append(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384)  # unsupported
-    aes256Suites.append(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA)  # unsupported
+    aes256Suites.append(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384)
+    aes256Suites.append(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA)
     aes256Suites.append(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384)  # unsupported
     aes256Suites.append(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA)  # unsupported
     aes256Suites.append(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384)  # unsupported
@@ -836,7 +846,7 @@
     aes128GcmSuites.append(TLS_RSA_WITH_AES_128_GCM_SHA256)
     aes128GcmSuites.append(TLS_DHE_RSA_WITH_AES_128_GCM_SHA256)
     aes128GcmSuites.append(TLS_DH_ANON_WITH_AES_128_GCM_SHA256)
-    aes128GcmSuites.append(TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)  # unsupp
+    aes128GcmSuites.append(TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)
     aes128GcmSuites.append(TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256)  # unsupp
     aes128GcmSuites.append(TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256)  # unsupp
     aes128GcmSuites.append(TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256)
@@ -847,7 +857,7 @@
     aes256GcmSuites.append(TLS_RSA_WITH_AES_256_GCM_SHA384)
     aes256GcmSuites.append(TLS_DHE_RSA_WITH_AES_256_GCM_SHA384)
     aes256GcmSuites.append(TLS_DH_ANON_WITH_AES_256_GCM_SHA384)
-    aes256GcmSuites.append(TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)  # unsupp
+    aes256GcmSuites.append(TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)
     aes256GcmSuites.append(TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384)  # unsupp
     aes256GcmSuites.append(TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384)  # unsupported
     aes256GcmSuites.append(TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384)
@@ -856,18 +866,21 @@
     #: CHACHA20 cipher, 00'th IETF draft (implicit POLY1305 authenticator)
     chacha20draft00Suites = []
     chacha20draft00Suites.append(TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_draft_00)
+    chacha20draft00Suites.append(
+        TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_draft_00)
     chacha20draft00Suites.append(TLS_DHE_RSA_WITH_CHACHA20_POLY1305_draft_00)
 
     #: CHACHA20 cipher (implicit POLY1305 authenticator, SHA256 PRF)
     chacha20Suites = []
     chacha20Suites.append(TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256)
+    chacha20Suites.append(TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256)
     chacha20Suites.append(TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256)
     chacha20Suites.append(TLS_CHACHA20_POLY1305_SHA256)
 
     #: RC4 128 stream cipher
     rc4Suites = []
     rc4Suites.append(TLS_ECDHE_RSA_WITH_RC4_128_SHA)
-    rc4Suites.append(TLS_ECDHE_ECDSA_WITH_RC4_128_SHA)  # unsupported
+    rc4Suites.append(TLS_ECDHE_ECDSA_WITH_RC4_128_SHA)
     rc4Suites.append(TLS_ECDH_ECDSA_WITH_RC4_128_SHA)  # unsupported
     rc4Suites.append(TLS_ECDH_RSA_WITH_RC4_128_SHA)  # unsupported
     rc4Suites.append(TLS_DH_ANON_WITH_RC4_128_MD5)
@@ -880,7 +893,7 @@
     nullSuites.append(TLS_RSA_WITH_NULL_MD5)
     nullSuites.append(TLS_RSA_WITH_NULL_SHA)
     nullSuites.append(TLS_RSA_WITH_NULL_SHA256)
-    nullSuites.append(TLS_ECDHE_ECDSA_WITH_NULL_SHA)  # unsupported
+    nullSuites.append(TLS_ECDHE_ECDSA_WITH_NULL_SHA)
     nullSuites.append(TLS_ECDH_ECDSA_WITH_NULL_SHA)  # unsupported
     nullSuites.append(TLS_ECDH_RSA_WITH_NULL_SHA)  # unsupported
     nullSuites.append(TLS_ECDHE_RSA_WITH_NULL_SHA)
@@ -905,11 +918,11 @@
     shaSuites.append(TLS_DH_ANON_WITH_AES_256_CBC_SHA)
     shaSuites.append(TLS_DH_ANON_WITH_3DES_EDE_CBC_SHA)
     shaSuites.append(TLS_RSA_WITH_NULL_SHA)
-    shaSuites.append(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA)  # unsupported
-    shaSuites.append(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA)  # unsupported
-    shaSuites.append(TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA)  # unsupported
-    shaSuites.append(TLS_ECDHE_ECDSA_WITH_RC4_128_SHA)  # unsupported
-    shaSuites.append(TLS_ECDHE_ECDSA_WITH_NULL_SHA)  # unsupported
+    shaSuites.append(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA)
+    shaSuites.append(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA)
+    shaSuites.append(TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA)
+    shaSuites.append(TLS_ECDHE_ECDSA_WITH_RC4_128_SHA)
+    shaSuites.append(TLS_ECDHE_ECDSA_WITH_NULL_SHA)
     shaSuites.append(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA)  # unsupported
     shaSuites.append(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA)  # unsupported
     shaSuites.append(TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA)  # unsupported
@@ -940,14 +953,14 @@
     sha256Suites.append(TLS_RSA_WITH_NULL_SHA256)
     sha256Suites.append(TLS_DH_ANON_WITH_AES_128_CBC_SHA256)
     sha256Suites.append(TLS_DH_ANON_WITH_AES_256_CBC_SHA256)
-    sha256Suites.append(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256)  # unsupported
+    sha256Suites.append(TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256)
     sha256Suites.append(TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256)  # unsupported
     sha256Suites.append(TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256)  # unsupported
     sha256Suites.append(TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256)
 
     #: SHA-384 HMAC, SHA-384 PRF
     sha384Suites = []
-    sha384Suites.append(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384)  # unsupported
+    sha384Suites.append(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384)
     sha384Suites.append(TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384)  # unsupported
     sha384Suites.append(TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384)  # unsupported
     sha384Suites.append(TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384)
@@ -1012,6 +1025,28 @@
         return [s for s in suites if s in includeSuites]
 
     @staticmethod
+    def filter_for_certificate(suites, cert_chain):
+        """Return a copy of suites without ciphers incompatible with the cert.
+        """
+        includeSuites = set([])
+        includeSuites.update(CipherSuite.tls13Suites)
+        if cert_chain:
+            if cert_chain.x509List[0].certAlg in ("rsa", "rsa-pss"):
+                includeSuites.update(CipherSuite.certAllSuites)
+            if cert_chain.x509List[0].certAlg == "rsa-pss":
+                # suites in which RSA encryption is used can't be used with
+                # rsa-pss
+                includeSuites.symmetric_difference_update(
+                    CipherSuite.certSuites)
+            if cert_chain.x509List[0].certAlg == "ecdsa":
+                includeSuites.update(CipherSuite.ecdheEcdsaSuites)
+        else:
+            includeSuites.update(CipherSuite.srpSuites)
+            includeSuites.update(CipherSuite.anonSuites)
+            includeSuites.update(CipherSuite.ecdhAnonSuites)
+        return [s for s in suites if s in includeSuites]
+
+    @staticmethod
     def _filterSuites(suites, settings, version=None):
         if version is None:
             version = settings.maxVersion
@@ -1059,6 +1094,8 @@
             keyExchangeSuites += CipherSuite.dheCertSuites
         if "ecdhe_rsa" in keyExchangeNames:
             keyExchangeSuites += CipherSuite.ecdheCertSuites
+        if "ecdhe_ecdsa" in keyExchangeNames:
+            keyExchangeSuites += CipherSuite.ecdheEcdsaSuites
         if "srp_sha" in keyExchangeNames:
             keyExchangeSuites += CipherSuite.srpSuites
         if "srp_sha_rsa" in keyExchangeNames:
@@ -1167,6 +1204,8 @@
 
     #: ECDHE key exchange, ECDSA authentication
     ecdheEcdsaSuites = []
+    ecdheEcdsaSuites.append(TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256)
+    ecdheEcdsaSuites.append(TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_draft_00)
     ecdheEcdsaSuites.append(TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)
     ecdheEcdsaSuites.append(TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)
     ecdheEcdsaSuites.append(TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384)
@@ -1177,6 +1216,12 @@
     ecdheEcdsaSuites.append(TLS_ECDHE_ECDSA_WITH_RC4_128_SHA)
     ecdheEcdsaSuites.append(TLS_ECDHE_ECDSA_WITH_NULL_SHA)
 
+    @classmethod
+    def getEcdsaSuites(cls, settings, version=None):
+        """Provide ECDSA authenticated ciphersuites matching settings"""
+        return cls._filterSuites(CipherSuite.ecdheEcdsaSuites,
+                                 settings, version)
+
     #: anon FFDHE key exchange
     anonSuites = []
     anonSuites.append(TLS_DH_ANON_WITH_AES_256_GCM_SHA384)
diff -urN tlslite-ng/tlslite/handshakesettings.py tlslite-ng-simple-ecdsa-support/tlslite/handshakesettings.py
--- tlslite-ng/tlslite/handshakesettings.py	2019-09-27 09:14:00.243090397 -0500
+++ tlslite-ng-simple-ecdsa-support/tlslite/handshakesettings.py	2019-09-25 14:20:03.000000000 -0500
@@ -21,11 +21,12 @@
 # Don't allow "md5" by default
 MAC_NAMES = ["sha", "sha256", "sha384", "aead"]
 ALL_MAC_NAMES = MAC_NAMES + ["md5"]
-KEY_EXCHANGE_NAMES = ["rsa", "dhe_rsa", "ecdhe_rsa", "srp_sha", "srp_sha_rsa",
-                      "ecdh_anon", "dh_anon"]
+KEY_EXCHANGE_NAMES = ["ecdhe_ecdsa", "rsa", "dhe_rsa", "ecdhe_rsa", "srp_sha",
+                      "srp_sha_rsa", "ecdh_anon", "dh_anon"]
 CIPHER_IMPLEMENTATIONS = ["openssl", "pycrypto", "python"]
 CERTIFICATE_TYPES = ["x509"]
 RSA_SIGNATURE_HASHES = ["sha512", "sha384", "sha256", "sha224", "sha1"]
+ECDSA_SIGNATURE_HASHES = ["sha512", "sha384", "sha256", "sha224", "sha1"]
 ALL_RSA_SIGNATURE_HASHES = RSA_SIGNATURE_HASHES + ["md5"]
 RSA_SCHEMES = ["pss", "pkcs1"]
 # while secp521r1 is the most secure, it's also much slower than the others
@@ -37,6 +38,12 @@
     ALL_CURVE_NAMES += ["secp224r1", "secp192r1"]
 ALL_DH_GROUP_NAMES = ["ffdhe2048", "ffdhe3072", "ffdhe4096", "ffdhe6144",
                       "ffdhe8192"]
+CURVE_ALIASES = {"secp256r1": ('NIST256p', 'prime256v1', 'P-256'),
+                 "secp384r1": ('NIST384p', 'P-384'),
+                 "secp521r1": ('NIST521p', 'P-521'),
+                 "secp256k1": ('SECP256k1',),
+                 "secp192r1": ('NIST192p', 'P-192'),
+                 "secp224r1": ('NIST224p', 'P-224')}
 KNOWN_VERSIONS = ((3, 0), (3, 1), (3, 2), (3, 3), (3, 4))
 TICKET_CIPHERS = ["chacha20-poly1305", "aes256gcm", "aes128gcm"]
 PSK_MODES = ["psk_dhe_ke", "psk_ke"]
@@ -145,6 +152,16 @@
         The allowed hashes are: "md5", "sha1", "sha224", "sha256",
         "sha384" and "sha512". The default list does not include md5.
 
+    :vartype ecdsaSigHashes: list
+    :ivar ecdsaSigHashes: List of hashes supported (and advertised as such) for
+        TLS 1.2 signatures over Server Key Exchange or Certificate Verify with
+        ECDSA signature algorithm.
+
+        The list is sorted from most wanted to least wanted algorithm.
+
+        The allowed hashes are: "sha1", "sha224", "sha256",
+        "sha384" and "sha512".
+
     :vartype eccCurves: list
     :ivar eccCurves: List of named curves that are to be supported
 
@@ -225,6 +242,10 @@
         1.2 or lower is the highest enabled version. Must not be set to values
         smaller than 64. Set to None to disable support for the extension.
         See also: RFC 8449.
+
+    :vartype keyExchangeNames: list
+    :ivar keyExchangeNames: Enabled key exchange types for the connection,
+        influences selected cipher suites.
     """
 
     def _init_key_settings(self):
@@ -249,6 +270,7 @@
         self.useExperimentalTackExtension = False
         self.sendFallbackSCSV = False
         self.useEncryptThenMAC = True
+        self.ecdsaSigHashes = list(ECDSA_SIGNATURE_HASHES)
         self.usePaddingExtension = True
         self.useExtendedMasterSecret = True
         self.requireExtendedMasterSecret = False
@@ -340,6 +362,12 @@
             raise ValueError("Key shares for not enabled groups specified: {0}"
                              .format(nonAdvertisedGroup))
 
+        unknownSigHash = not_matching(other.ecdsaSigHashes,
+                                      ECDSA_SIGNATURE_HASHES)
+        if unknownSigHash:
+            raise ValueError("Unknown ECDSA signature hash: '{0}'".\
+                             format(unknownSigHash))
+
         unknownDHGroup = not_matching(other.dhGroups, ALL_DH_GROUP_NAMES)
         if unknownDHGroup:
             raise ValueError("Unknown FFDHE group name: '{0}'"
@@ -388,7 +416,8 @@
             raise ValueError("Unknown RSA padding mode: '{0}'"
                              .format(unknownRSAPad))
 
-        if not other.rsaSigHashes and other.maxVersion >= (3, 3):
+        if not other.rsaSigHashes and not other.ecdsaSigHashes and \
+                other.maxVersion >= (3, 3):
             raise ValueError("TLS 1.2 requires signature algorithms to be set")
 
     @staticmethod
@@ -544,6 +573,7 @@
         other.certificateTypes = self.certificateTypes
         other.rsaSigHashes = self.rsaSigHashes
         other.rsaSchemes = self.rsaSchemes
+        other.ecdsaSigHashes = self.ecdsaSigHashes
         # DH key params
         other.eccCurves = self.eccCurves
         other.dhParams = self.dhParams
diff -urN tlslite-ng/tlslite/keyexchange.py tlslite-ng-simple-ecdsa-support/tlslite/keyexchange.py
--- tlslite-ng/tlslite/keyexchange.py	2019-09-27 09:14:00.245090420 -0500
+++ tlslite-ng-simple-ecdsa-support/tlslite/keyexchange.py	2019-09-25 14:20:03.000000000 -0500
@@ -73,6 +73,32 @@
         """Process the server KEX and return premaster secret"""
         raise NotImplementedError()
 
+    def _tls12_sign_ecdsa_SKE(self, serverKeyExchange, sigHash=None):
+        try:
+            serverKeyExchange.hashAlg, serverKeyExchange.signAlg = \
+                    getattr(SignatureScheme, sigHash)
+            hashName = SignatureScheme.getHash(sigHash)
+        except AttributeError:
+            serverKeyExchange.hashAlg = getattr(HashAlgorithm, sigHash)
+            serverKeyExchange.signAlg = SignatureAlgorithm.ecdsa
+            hashName = sigHash
+
+        hash_bytes = serverKeyExchange.hash(self.clientHello.random,
+                                            self.serverHello.random)
+
+        hash_bytes = hash_bytes[:self.privateKey.private_key.curve.baselen]
+
+        serverKeyExchange.signature = \
+            self.privateKey.sign(hash_bytes, hashAlg=hashName)
+
+        if not serverKeyExchange.signature:
+            raise TLSInternalError("Empty signature")
+
+        if not self.privateKey.verify(serverKeyExchange.signature,
+                                             hash_bytes,
+                                             ecdsa.util.sigdecode_der):
+            raise TLSInternalError("signature validation failure")
+
     def _tls12_signSKE(self, serverKeyExchange, sigHash=None):
         """Sign a TLSv1.2 SKE message."""
         try:
@@ -119,6 +145,8 @@
         :param sigHash: name of the signature hash to be used for signing
         """
         if self.serverHello.server_version < (3, 3):
+            if self.privateKey.key_type == "ecdsa":
+                serverKeyExchange.signAlg = SignatureAlgorithm.ecdsa
             hashBytes = serverKeyExchange.hash(self.clientHello.random,
                                                self.serverHello.random)
 
@@ -131,7 +159,28 @@
                                           hashBytes):
                 raise TLSInternalError("Server Key Exchange signature invalid")
         else:
-            self._tls12_signSKE(serverKeyExchange, sigHash)
+            if self.privateKey.key_type == "ecdsa":
+                self._tls12_sign_ecdsa_SKE(serverKeyExchange, sigHash)
+            else:
+                self._tls12_signSKE(serverKeyExchange, sigHash)
+
+    @staticmethod
+    def _tls12_verify_ecdsa_SKE(serverKeyExchange, publicKey, clientRandom,
+                                serverRandom, validSigAlgs):
+        hashName = HashAlgorithm.toRepr(serverKeyExchange.hashAlg)
+        if not hashName:
+            raise TLSIllegalParameterException("Unknown hash algorithm")
+
+        hashBytes = serverKeyExchange.hash(clientRandom, serverRandom)
+
+        hashBytes = hashBytes[:publicKey.public_key.curve.baselen]
+
+        if not publicKey.verify(serverKeyExchange.signature, hashBytes,
+                                padding=None,
+                                hashAlg=hashName,
+                                saltLen=None):
+            raise TLSDecryptionFailed("Server Key Exchange signature "
+                                      "invalid")
 
     @staticmethod
     def _tls12_verify_SKE(serverKeyExchange, publicKey, clientRandom,
@@ -142,6 +191,12 @@
             raise TLSIllegalParameterException("Server selected "
                                                "invalid signature "
                                                "algorithm")
+        if serverKeyExchange.signAlg == SignatureAlgorithm.ecdsa:
+            return KeyExchange._tls12_verify_ecdsa_SKE(serverKeyExchange,
+                                                       publicKey,
+                                                       clientRandom,
+                                                       serverRandom,
+                                                       validSigAlgs)
         schemeID = (serverKeyExchange.hashAlg,
                     serverKeyExchange.signAlg)
         scheme = SignatureScheme.toRepr(schemeID)
@@ -201,7 +256,7 @@
     @staticmethod
     def calcVerifyBytes(version, handshakeHashes, signatureAlg,
                         premasterSecret, clientRandom, serverRandom,
-                        prf_name = None, peer_tag=b'client'):
+                        prf_name = None, peer_tag=b'client', key_type="rsa"):
         """Calculate signed bytes for Certificate Verify"""
         if version == (3, 0):
             masterSecret = calcMasterSecret(version,
@@ -211,15 +266,22 @@
                                             serverRandom)
             verifyBytes = handshakeHashes.digestSSL(masterSecret, b"")
         elif version in ((3, 1), (3, 2)):
-            verifyBytes = handshakeHashes.digest()
+            if key_type != "ecdsa":
+                verifyBytes = handshakeHashes.digest()
+            else:
+                verifyBytes = handshakeHashes.digest("sha1")
         elif version == (3, 3):
-            scheme = SignatureScheme.toRepr(signatureAlg)
-            if scheme is None:
-                hashName = HashAlgorithm.toRepr(signatureAlg[0])
-                padding = 'pkcs1'
+            if signatureAlg[1] != SignatureAlgorithm.ecdsa:
+                scheme = SignatureScheme.toRepr(signatureAlg)
+                if scheme is None:
+                    hashName = HashAlgorithm.toRepr(signatureAlg[0])
+                    padding = 'pkcs1'
+                else:
+                    hashName = SignatureScheme.getHash(scheme)
+                    padding = SignatureScheme.getPadding(scheme)
             else:
-                hashName = SignatureScheme.getHash(scheme)
-                padding = SignatureScheme.getPadding(scheme)
+                padding = None
+                hashName = HashAlgorithm.toRepr(signatureAlg[0])
             verifyBytes = handshakeHashes.digest(hashName)
             if padding == 'pkcs1':
                 verifyBytes = RSAKey.addPKCS1Prefix(verifyBytes, hashName)
@@ -238,7 +300,7 @@
                           handshakeHashes.digest(prf_name)
             verifyBytes = secureHash(verifyBytes, hash_name)
         else:
-            raise ValueError("Unsupported TLS version {}".format(version))
+            raise ValueError("Unsupported TLS version {0}".format(version))
         return verifyBytes
 
     @staticmethod
@@ -260,6 +322,8 @@
             SSLv3
         """
         signatureAlgorithm = None
+        if privateKey.key_type == "ecdsa" and version < (3, 3):
+            signatureAlgorithm = (HashAlgorithm.sha1, SignatureAlgorithm.ecdsa)
         # in TLS 1.2 we must decide which algorithm to use for signing
         if version == (3, 3):
             serverSigAlgs = certificateRequest.supported_signature_algs
@@ -271,19 +335,27 @@
                                                   signatureAlgorithm,
                                                   premasterSecret,
                                                   clientRandom,
-                                                  serverRandom)
-        scheme = SignatureScheme.toRepr(signatureAlgorithm)
-        # for pkcs1 signatures hash is used to add PKCS#1 prefix, but
-        # that was already done by calcVerifyBytes
-        hashName = None
-        saltLen = 0
-        if scheme is None:
-            padding = 'pkcs1'
+                                                  serverRandom,
+                                                  privateKey.key_type)
+        if signatureAlgorithm and \
+                signatureAlgorithm[1] == SignatureAlgorithm.ecdsa:
+            padding = None
+            hashName = HashAlgorithm.toRepr(signatureAlgorithm[0])
+            saltLen = None
+            verifyBytes = verifyBytes[:privateKey.private_key.curve.baselen]
         else:
-            padding = SignatureScheme.getPadding(scheme)
-            if padding == 'pss':
-                hashName = SignatureScheme.getHash(scheme)
-                saltLen = getattr(hashlib, hashName)().digest_size
+            scheme = SignatureScheme.toRepr(signatureAlgorithm)
+            # for pkcs1 signatures hash is used to add PKCS#1 prefix, but
+            # that was already done by calcVerifyBytes
+            hashName = None
+            saltLen = 0
+            if scheme is None:
+                padding = 'pkcs1'
+            else:
+                padding = SignatureScheme.getPadding(scheme)
+                if padding == 'pss':
+                    hashName = SignatureScheme.getHash(scheme)
+                    saltLen = getattr(hashlib, hashName)().digest_size
 
         signedBytes = privateKey.sign(verifyBytes,
                                       padding,
@@ -297,6 +369,7 @@
 
         return certificateVerify
 
+
 class AuthenticatedKeyExchange(KeyExchange):
     """
     Common methods for key exchanges that authenticate Server Key Exchange
diff -urN tlslite-ng/tlslite/messages.py tlslite-ng-simple-ecdsa-support/tlslite/messages.py
--- tlslite-ng/tlslite/messages.py	2019-09-27 09:14:00.246090431 -0500
+++ tlslite-ng-simple-ecdsa-support/tlslite/messages.py	2019-09-25 14:20:03.000000000 -0500
@@ -1455,6 +1455,7 @@
         self.curve_type = curve_type
         self.named_curve = named_curve
         self.ecdh_Ys = point
+        return self
 
     def parse(self, parser):
         """
@@ -1488,7 +1489,8 @@
         else:
             raise AssertionError()
 
-        if self.cipherSuite in CipherSuite.certAllSuites:
+        if self.cipherSuite in CipherSuite.certAllSuites or\
+                self.cipherSuite in CipherSuite.ecdheEcdsaSuites:
             if self.version == (3, 3):
                 self.hashAlg = parser.get(1)
                 self.signAlg = parser.get(1)
@@ -1536,7 +1538,8 @@
         """
         writer = Writer()
         writer.bytes += self.writeParams()
-        if self.cipherSuite in CipherSuite.certAllSuites:
+        if self.cipherSuite in CipherSuite.certAllSuites or \
+                self.cipherSuite in CipherSuite.ecdheEcdsaSuites:
             if self.version >= (3, 3):
                 assert self.hashAlg != 0 and self.signAlg != 0
                 writer.add(self.hashAlg, 1)
@@ -1561,6 +1564,10 @@
             else:
                 hashAlg = SignatureScheme.getHash(sigScheme)
             return secureHash(bytesToHash, hashAlg)
+        # ECDSA ciphers in TLS 1.1 and earlier sign the messages using
+        # SHA-1 only
+        if self.cipherSuite in CipherSuite.ecdheEcdsaSuites:
+            return SHA1(bytesToHash)
         return MD5(bytesToHash) + SHA1(bytesToHash)
 
 
diff -urN tlslite-ng/tlslite/tlsconnection.py tlslite-ng-simple-ecdsa-support/tlslite/tlsconnection.py
--- tlslite-ng/tlslite/tlsconnection.py	2019-09-27 09:14:00.251090487 -0500
+++ tlslite-ng-simple-ecdsa-support/tlslite/tlsconnection.py	2019-09-25 14:20:03.000000000 -0500
@@ -29,7 +29,7 @@
 from .errors import *
 from .messages import *
 from .mathtls import *
-from .handshakesettings import HandshakeSettings, KNOWN_VERSIONS
+from .handshakesettings import HandshakeSettings, KNOWN_VERSIONS, CURVE_ALIASES
 from .handshakehashes import HandshakeHashes
 from .utils.tackwrapper import *
 from .utils.deprecations import deprecated_params
@@ -659,6 +659,7 @@
             cipherSuites += CipherSuite.getSrpAllSuites(settings)
         elif certParams:
             cipherSuites += CipherSuite.getTLS13Suites(settings)
+            cipherSuites += CipherSuite.getEcdsaSuites(settings)
             cipherSuites += CipherSuite.getEcdheCertSuites(settings)
             cipherSuites += CipherSuite.getDheCertSuites(settings)
             cipherSuites += CipherSuite.getCertSuites(settings)
@@ -1259,12 +1260,22 @@
                                                             None, None, None,
                                                             prfName, b'server')
 
-            scheme = SignatureScheme.toRepr(signature_scheme)
-            padType = SignatureScheme.getPadding(scheme)
-            hashName = SignatureScheme.getHash(scheme)
-            saltLen = getattr(hashlib, hashName)().digest_size
+            for result in self._clientGetKeyFromChain(certificate, settings):
+                if result in (0, 1):
+                    yield result
+                else:
+                    break
+            publicKey, serverCertChain, tackExt = result
 
-            publicKey = certificate.cert_chain.getEndEntityPublicKey()
+            if signature_scheme[1] == SignatureAlgorithm.ecdsa:
+                padType = None
+                hashName = HashAlgorithm.toRepr(signature_scheme[0])
+                saltLen = None
+            else:
+                scheme = SignatureScheme.toRepr(signature_scheme)
+                padType = SignatureScheme.getPadding(scheme)
+                hashName = SignatureScheme.getHash(scheme)
+                saltLen = getattr(hashlib, hashName)().digest_size
 
             if not publicKey.verify(certificate_verify.signature,
                                     signature_context,
@@ -1348,9 +1359,14 @@
                                                 signature_scheme, None, None,
                                                 None, prfName, b'client')
 
-                pad_type = SignatureScheme.getPadding(scheme)
-                hash_name = SignatureScheme.getHash(scheme)
-                salt_len = getattr(hashlib, hash_name)().digest_size
+                if signature_scheme[1] == SignatureAlgorithm.ecdsa:
+                    pad_type = None
+                    hash_name = HashAlgorithm.toRepr(signature_scheme[0])
+                    salt_len = None
+                else:
+                    pad_type = SignatureScheme.getPadding(scheme)
+                    hash_name = SignatureScheme.getHash(scheme)
+                    salt_len = getattr(hashlib, hash_name)().digest_size
 
                 signature = privateKey.sign(signature_context,
                                             pad_type,
@@ -1533,7 +1549,8 @@
                            keyExchange):
         """Perform the client side of key exchange"""
         # if server chose cipher suite with authentication, get the certificate
-        if cipherSuite in CipherSuite.certAllSuites:
+        if cipherSuite in CipherSuite.certAllSuites or \
+                cipherSuite in CipherSuite.ecdheEcdsaSuites:
             for result in self._getMsg(ContentType.handshake,
                                        HandshakeType.certificate,
                                        certificateType):
@@ -1568,6 +1585,7 @@
 
             #abort if Certificate Request with inappropriate ciphersuite
             if cipherSuite not in CipherSuite.certAllSuites \
+                and cipherSuite not in CipherSuite.ecdheEcdsaSuites \
                 or cipherSuite in CipherSuite.srpAllSuites:
                 for result in self._sendError(\
                         AlertDescription.unexpected_message,
@@ -1584,7 +1602,8 @@
 
         serverCertChain = None
         publicKey = None
-        if cipherSuite in CipherSuite.certAllSuites:
+        if cipherSuite in CipherSuite.certAllSuites or \
+                cipherSuite in CipherSuite.ecdheEcdsaSuites:
             # get the certificate
             for result in self._clientGetKeyFromChain(serverCertificate,
                                                       settings,
@@ -1618,7 +1637,8 @@
         if serverKeyExchange:
             # store key exchange metadata for user applications
             if self.version >= (3, 3) \
-                    and cipherSuite in CipherSuite.certAllSuites \
+                    and (cipherSuite in CipherSuite.certAllSuites or
+                         cipherSuite in CipherSuite.ecdheEcdsaSuites) \
                     and cipherSuite not in CipherSuite.certSuites:
                 self.serverSigAlg = (serverKeyExchange.hashAlg,
                                      serverKeyExchange.signAlg)
@@ -1757,15 +1777,56 @@
 
         #Get and check public key from the cert chain
         publicKey = cert_chain.getEndEntityPublicKey()
-        if len(publicKey) < settings.minKeySize:
-            for result in self._sendError(AlertDescription.handshake_failure,
-                    "Other party's public key too small: %d" % len(publicKey)):
-                yield result
-        if len(publicKey) > settings.maxKeySize:
-            for result in self._sendError(AlertDescription.handshake_failure,
-                    "Other party's public key too large: %d" % len(publicKey)):
-                yield result
-        
+        cert_type = cert_chain.x509List[0].certAlg
+        if cert_type == "ecdsa":
+            curve_name = publicKey.curve_name
+            for name, aliases in CURVE_ALIASES.items():
+                if curve_name in aliases:
+                    curve_name = name
+                    break
+
+            if self.version <= (3, 3) and curve_name not in settings.eccCurves:
+                for result in self._sendError(
+                        AlertDescription.handshake_failure,
+                        "Peer sent certificate with curve we did not "
+                        "advertise support for: {0}".format(curve_name)):
+                    yield result
+            if self.version >= (3, 4):
+                if curve_name not in ('secp256r1', 'secp384r1', 'secp521r1'):
+                    for result in self._sendError(
+                            AlertDescription.illegal_parameter,
+                            "Peer sent certificate with curve not supported "
+                            "in TLS 1.3: {0}".format(curve_name)):
+                        yield result
+                if curve_name == 'secp256r1':
+                    sig_alg_for_curve = 'sha256'
+                elif curve_name == 'secp384r1':
+                    sig_alg_for_curve = 'sha384'
+                else:
+                    assert curve_name == 'secp521r1'
+                    sig_alg_for_curve = 'sha512'
+                if sig_alg_for_curve not in settings.ecdsaSigHashes:
+                    for result in self._sendError(
+                            AlertDescription.illegal_parameter,
+                            "Peer selected certificate with ECDSA curve we "
+                            "did not advertise support for: {0}"
+                            .format(curve_name)):
+                        yield result
+        else:
+            # for RSA keys
+            if len(publicKey) < settings.minKeySize:
+                for result in self._sendError(
+                        AlertDescription.handshake_failure,
+                        "Other party's public key too small: %d" %
+                        len(publicKey)):
+                    yield result
+            if len(publicKey) > settings.maxKeySize:
+                for result in self._sendError(
+                        AlertDescription.handshake_failure,
+                        "Other party's public key too large: %d" %
+                        len(publicKey)):
+                    yield result
+
         # If there's no TLS Extension, look for a TACK cert
         if tackpyLoaded:
             if not tackExt:
@@ -1997,7 +2058,8 @@
             nextProtos = None
 
         # If not doing a certificate-based suite, discard the TACK
-        if not cipherSuite in CipherSuite.certAllSuites:
+        if not cipherSuite in CipherSuite.certAllSuites and \
+                not cipherSuite in CipherSuite.ecdheEcdsaSuites:
             tacks = None
 
         # Prepare a TACK Extension if requested
@@ -2112,7 +2174,8 @@
         # Perform a certificate-based key exchange
         elif (cipherSuite in CipherSuite.certSuites or
               cipherSuite in CipherSuite.dheCertSuites or
-              cipherSuite in CipherSuite.ecdheCertSuites):
+              cipherSuite in CipherSuite.ecdheCertSuites or
+              cipherSuite in CipherSuite.ecdheEcdsaSuites):
             if cipherSuite in CipherSuite.certSuites:
                 keyExchange = RSAKeyExchange(cipherSuite,
                                              clientHello,
@@ -2126,7 +2189,8 @@
                                                  privateKey,
                                                  settings.dhParams,
                                                  dhGroups)
-            elif cipherSuite in CipherSuite.ecdheCertSuites:
+            elif cipherSuite in CipherSuite.ecdheCertSuites or \
+                    cipherSuite in CipherSuite.ecdheEcdsaSuites:
                 acceptedCurves = self._curveNamesToList(settings)
                 defaultCurve = getattr(GroupName, settings.defaultCurve)
                 keyExchange = ECDHE_RSAKeyExchange(cipherSuite,
@@ -2179,7 +2243,8 @@
 
         #Create the session object
         self.session = Session()
-        if cipherSuite in CipherSuite.certAllSuites:        
+        if cipherSuite in CipherSuite.certAllSuites or \
+                cipherSuite in CipherSuite.ecdheEcdsaSuites:
             serverCertChain = cert_chain
         else:
             serverCertChain = None
@@ -2536,9 +2601,14 @@
                                             signature_scheme, None, None, None,
                                             prf_name, b'server')
 
-            padType = SignatureScheme.getPadding(scheme)
-            hashName = SignatureScheme.getHash(scheme)
-            saltLen = getattr(hashlib, hashName)().digest_size
+            if signature_scheme[1] == SignatureAlgorithm.ecdsa:
+                hashName = HashAlgorithm.toRepr(signature_scheme[0])
+                padType = None
+                saltLen = None
+            else:
+                padType = SignatureScheme.getPadding(scheme)
+                hashName = SignatureScheme.getHash(scheme)
+                saltLen = getattr(hashlib, hashName)().digest_size
 
             signature = privateKey.sign(signature_context,
                                         padType,
@@ -3112,6 +3182,7 @@
                 cipherSuites += CipherSuite.getTLS13Suites(settings,
                                                            version)
             if ecGroupIntersect:
+                cipherSuites += CipherSuite.getEcdsaSuites(settings, version)
                 cipherSuites += CipherSuite.getEcdheCertSuites(settings,
                                                                version)
             if ffGroupIntersect:
@@ -3130,6 +3201,8 @@
         cipherSuites = CipherSuite.filterForVersion(cipherSuites,
                                                     minVersion=version,
                                                     maxVersion=version)
+        cipherSuites = CipherSuite.filter_for_certificate(cipherSuites,
+                                                          cert_chain)
         #If resumption was requested and we have a session cache...
         if clientHello.session_id and sessionCache:
             session = None
@@ -3327,8 +3400,10 @@
                 yield result
 
         #If an RSA suite is chosen, check for certificate type intersection
-        if cipherSuite in CipherSuite.certAllSuites and CertificateType.x509 \
-                                not in clientHello.certificate_types:
+        if (cipherSuite in CipherSuite.certAllSuites or
+            cipherSuite in CipherSuite.ecdheEcdsaSuites) \
+                    and CertificateType.x509 \
+                    not in clientHello.certificate_types:
             for result in self._sendError(\
                     AlertDescription.handshake_failure,
                     "the client doesn't support my certificate type"):
@@ -3549,9 +3624,13 @@
         try:
             serverKeyExchange = keyExchange.makeServerKeyExchange(sigHash)
         except TLSUnknownPSKIdentity:
-            for result in self._sendError(\
+            for result in self._sendError(
                     AlertDescription.unknown_psk_identity):
                 yield result
+        except TLSInsufficientSecurity:
+            for result in self._sendError(
+                    AlertDescription.insufficient_security):
+                yield result
 
         #Send ServerHello[, Certificate], ServerKeyExchange,
         #ServerHelloDone
@@ -3606,7 +3685,18 @@
                     AlertDescription.handshake_failure,
                     str(alert)):
                 yield result
-        serverKeyExchange = keyExchange.makeServerKeyExchange(sigHashAlg)
+        try:
+            serverKeyExchange = keyExchange.makeServerKeyExchange(sigHashAlg)
+        except TLSInternalError as alert:
+            for result in self._sendError(
+                    AlertDescription.internal_error,
+                    str(alert)):
+                yield result
+        except TLSInsufficientSecurity as alert:
+            for result in self._sendError(
+                    AlertDescription.insufficient_security,
+                    str(alert)):
+                yield result
         if serverKeyExchange is not None:
             msgs.append(serverKeyExchange)
         if reqCert:
@@ -3970,7 +4060,8 @@
         for schemeID in supported:
             if schemeID in hashAndAlgsExt.sigalgs:
                 name = SignatureScheme.toRepr(schemeID)
-                if not name and schemeID[1] == SignatureAlgorithm.rsa:
+                if not name and schemeID[1] in (SignatureAlgorithm.rsa,
+                                                SignatureAlgorithm.ecdsa):
                     name = HashAlgorithm.toRepr(schemeID[0])
 
                 if name:
@@ -3984,41 +4075,66 @@
                          version=(3, 3)):
         """Convert list of valid signature hashes to array of tuples"""
         certType = None
+        publicKey = None
         if certList:
             certType = certList.x509List[0].certAlg
+            publicKey = certList.x509List[0].publicKey
 
         sigAlgs = []
-        for schemeName in settings.rsaSchemes:
-            # pkcs#1 v1.5 signatures are not allowed in TLS 1.3
-            if version > (3, 3) and schemeName == "pkcs1":
-                continue
 
-            for hashName in settings.rsaSigHashes:
-                # rsa-pss certificates can't be used to make PKCS#1 v1.5
-                # signatures
-                if certType == "rsa-pss" and schemeName == "pkcs1":
+        if not certType or certType == "ecdsa":
+            for hashName in settings.ecdsaSigHashes:
+                # only SHA256, SHA384 and SHA512 are allowed in TLS 1.3
+                if version > (3, 3) and hashName in ("sha1", "sha224"):
                     continue
-                try:
-                    # 1024 bit keys are too small to create valid
-                    # rsa-pss-SHA512 signatures
-                    if schemeName == 'pss' and hashName == 'sha512'\
-                            and privateKey and privateKey.n < 2**2047:
+
+                # in TLS 1.3 ECDSA key curve is bound to hash
+                if publicKey and version > (3, 3):
+                    size = len(publicKey)
+                    size, r = divmod(size, 8)
+                    size += int(bool(r))
+                    if size == 32 and hashName != "sha256":
                         continue
-                    # advertise support for both rsaEncryption and RSA-PSS OID
-                    # key type
-                    if certType != 'rsa-pss':
-                        sigAlgs.append(getattr(SignatureScheme,
-                                               "rsa_{0}_rsae_{1}"
-                                               .format(schemeName, hashName)))
-                    if certType != 'rsa':
-                        sigAlgs.append(getattr(SignatureScheme,
-                                               "rsa_{0}_pss_{1}"
-                                               .format(schemeName, hashName)))
-                except AttributeError:
-                    if schemeName == 'pkcs1':
-                        sigAlgs.append((getattr(HashAlgorithm, hashName),
-                                        SignatureAlgorithm.rsa))
+                    if size == 48 and hashName != "sha384":
+                        continue
+                    if size == 65 and hashName != "sha512":
+                        continue
+
+                sigAlgs.append((getattr(HashAlgorithm, hashName),
+                                SignatureAlgorithm.ecdsa))
+
+        if not certType or certType in ("rsa", "rsa-pss"):
+            for schemeName in settings.rsaSchemes:
+                # pkcs#1 v1.5 signatures are not allowed in TLS 1.3
+                if version > (3, 3) and schemeName == "pkcs1":
                     continue
+
+                for hashName in settings.rsaSigHashes:
+                    # rsa-pss certificates can't be used to make PKCS#1 v1.5
+                    # signatures
+                    if certType == "rsa-pss" and schemeName == "pkcs1":
+                        continue
+                    try:
+                        # 1024 bit keys are too small to create valid
+                        # rsa-pss-SHA512 signatures
+                        if schemeName == 'pss' and hashName == 'sha512'\
+                                and privateKey and privateKey.n < 2**2047:
+                            continue
+                        # advertise support for both rsaEncryption and RSA-PSS OID
+                        # key type
+                        if certType != 'rsa-pss':
+                            sigAlgs.append(getattr(SignatureScheme,
+                                                   "rsa_{0}_rsae_{1}"
+                                                   .format(schemeName, hashName)))
+                        if certType != 'rsa':
+                            sigAlgs.append(getattr(SignatureScheme,
+                                                   "rsa_{0}_pss_{1}"
+                                                   .format(schemeName, hashName)))
+                    except AttributeError:
+                        if schemeName == 'pkcs1':
+                            sigAlgs.append((getattr(HashAlgorithm, hashName),
+                                            SignatureAlgorithm.rsa))
+                        continue
         return sigAlgs
 
     @staticmethod
diff -urN tlslite-ng/tlslite/utils/ecdsakey.py tlslite-ng-simple-ecdsa-support/tlslite/utils/ecdsakey.py
--- tlslite-ng/tlslite/utils/ecdsakey.py	1969-12-31 19:00:00.000000000 -0500
+++ tlslite-ng-simple-ecdsa-support/tlslite/utils/ecdsakey.py	2019-09-25 14:20:03.000000000 -0500
@@ -0,0 +1,181 @@
+# Author: Stanislav Zidek
+# See the LICENSE file for legal information regarding use of this file.
+
+"""Abstract class for ECDSA."""
+
+from .cryptomath import secureHash
+
+
+class ECDSAKey(object):
+    """This is an abstract base class for ECDSA keys.
+
+    Particular implementations of ECDSA keys, such as
+    :py:class:`~.python_ecdsakey.Python_ECDSAKey`
+    ... more coming
+    inherit from this.
+
+    To create or parse an ECDSA key, don't use one of these classes
+    directly.  Instead, use the factory functions in
+    :py:class:`~tlslite.utils.keyfactory`.
+    """
+
+    def __init__(self, public_key, private_key):
+        """Create a new ECDSA key.
+
+        If public_key or private_key are passed in, the new key
+        will be initialized.
+
+        :param public_key: ECDSA public key.
+
+        :param private_key: ECDSA private key.
+        """
+        raise NotImplementedError()
+
+    def __len__(self):
+        """Return the size of the order of the curve of this key, in bits.
+
+        :rtype: int
+        """
+        raise NotImplementedError()
+
+    def hasPrivateKey(self):
+        """Return whether or not this key has a private component.
+
+        :rtype: bool
+        """
+        raise NotImplementedError()
+
+    def _sign(self, data, hash_alg):
+        raise NotImplementedError()
+
+    def _hashAndSign(self, data, hAlg):
+        raise NotImplementedError()
+
+    def _verify(self, signature, hash_bytes):
+        raise NotImplementedError()
+
+    def hashAndSign(self, bytes, rsaScheme=None, hAlg='sha1', sLen=None):
+        """Hash and sign the passed-in bytes.
+
+        This requires the key to have a private component. It performs
+        a signature on the passed-in data with selected hash algorithm.
+
+        :type bytes: bytes-like object
+        :param bytes: The value which will be hashed and signed.
+
+        :type rsaScheme: str
+        :param rsaScheme: Ignored, present for API compatibility with RSA
+
+        :type hAlg: str
+        :param hAlg: The hash algorithm that will be used to hash data
+
+        :type sLen: int
+        :param sLen: Ignored, present for API compatibility with RSA
+
+        :rtype: bytearray
+        :returns: An ECDSA signature on the passed-in data.
+        """
+        hAlg = hAlg.lower()
+        hashBytes = secureHash(bytearray(bytes), hAlg)
+        return self.sign(hashBytes, padding=rsaScheme, hashAlg=hAlg,
+                         saltLen=sLen)
+
+    def hashAndVerify(self, sigBytes, bytes, rsaScheme=None, hAlg='sha1',
+                      sLen=None):
+        """Hash and verify the passed-in bytes with the signature.
+
+        This verifies an ECDSA signature on the passed-in data
+        with selected hash algorithm.
+
+        :type sigBytes: bytearray
+        :param sigBytes: An ECDSA signature, DER encoded.
+
+        :type bytes: str or bytearray
+        :param bytes: The value which will be hashed and verified.
+
+        :type rsaScheme: str
+        :param rsaScheme: Ignored, present for API compatibility with RSA
+
+        :type hAlg: str
+        :param hAlg: The hash algorithm that will be used
+
+        :type sLen: int
+        :param sLen: Ignored, present for API compatibility with RSA
+
+        :rtype: bool
+        :returns: Whether the signature matches the passed-in data.
+        """
+        hAlg = hAlg.lower()
+
+        hashBytes = secureHash(bytearray(bytes), hAlg)
+        return self.verify(sigBytes, hashBytes, rsaScheme, hAlg, sLen)
+
+    def sign(self, bytes, padding=None, hashAlg="sha1", saltLen=None):
+        """Sign the passed-in bytes.
+
+        This requires the key to have a private component.  It performs
+        an ECDSA signature on the passed-in data.
+
+        :type bytes: bytearray
+        :param bytes: The value which will be signed (generally a binary
+            encoding of hash output.
+
+        :type padding: str
+        :param padding: Ignored, present for API compatibility with RSA
+
+        :type hashAlg: str
+        :param hashAlg: name of hash that was used for calculating the bytes
+
+        :type saltLen: int
+        :param saltLen: Ignored, present for API compatibility with RSA
+
+        :rtype: bytearray
+        :returns: An ECDSA signature on the passed-in data.
+        """
+        sigBytes = self._sign(bytes, hashAlg)
+        return sigBytes
+
+    def verify(self, sigBytes, bytes, padding=None, hashAlg=None,
+               saltLen=None):
+        """Verify the passed-in bytes with the signature.
+
+        This verifies a PKCS1 signature on the passed-in data.
+
+        :type sigBytes: bytearray
+        :param sigBytes: A PKCS1 signature.
+
+        :type bytes: bytearray
+        :param bytes: The value which will be verified.
+
+        :type padding: str
+        :param padding: Ignored, present for API compatibility with RSA
+
+        :rtype: bool
+        :returns: Whether the signature matches the passed-in data.
+        """
+        return self._verify(sigBytes, bytes)
+
+    def acceptsPassword(self):
+        """Return True if the write() method accepts a password for use
+        in encrypting the private key.
+
+        :rtype: bool
+        """
+        raise NotImplementedError()
+
+    def write(self, password=None):
+        """Return a string containing the key.
+
+        :rtype: str
+        :returns: A string describing the key, in whichever format (PEM)
+            is native to the implementation.
+        """
+        raise NotImplementedError()
+
+    @staticmethod
+    def generate(bits):
+        """Generate a new key with the specified curve.
+
+        :rtype: ~tlslite.utils.ECDSAKey.ECDSAKey
+        """
+        raise NotImplementedError()
diff -urN tlslite-ng/tlslite/utils/keyfactory.py tlslite-ng-simple-ecdsa-support/tlslite/utils/keyfactory.py
--- tlslite-ng/tlslite/utils/keyfactory.py	2019-09-27 09:14:00.255090532 -0500
+++ tlslite-ng-simple-ecdsa-support/tlslite/utils/keyfactory.py	2019-09-25 14:20:03.000000000 -0500
@@ -7,6 +7,7 @@
 
 from .rsakey import RSAKey
 from .python_rsakey import Python_RSAKey
+from .python_ecdsakey import Python_ECDSAKey
 from tlslite.utils import cryptomath
 
 if cryptomath.m2cryptoLoaded:
@@ -93,8 +94,20 @@
 
     :raises SyntaxError: If the key is not properly formatted.
     """
+    # as old versions of openssl can't handle RSA-PSS or ECDSA keys, first
+    # try to detect what kind of key it is (we ignore errors as the python
+    # code can't handle encrypted key files while m2crypto/openssl can)
+    key_type = "rsa"
+    try:
+        key = Python_RSAKey.parsePEM(s)
+        key_type = key.key_type
+        del key
+    except Exception:
+        pass
+
     for implementation in implementations:
-        if implementation == "openssl" and cryptomath.m2cryptoLoaded:
+        if implementation == "openssl" and cryptomath.m2cryptoLoaded \
+                and key_type == "rsa":
             key = OpenSSL_RSAKey.parse(s, passwordCallback)
             break
         elif implementation == "python":
@@ -193,3 +206,30 @@
                                  key_type=key_type)
     raise ValueError("No acceptable implementations")
 # pylint: enable=invalid-name
+
+
+def _create_public_ecdsa_key(point_x, point_y, curve_name,
+                             implementations=("python",)):
+    """
+    Convert public key parameters into concrete implementation of verifier.
+
+    The public key in ECDSA is a point on elliptic curve, so it consists of
+    two integers that identify the point and the name of the curve on which
+    it needs to lie on.
+
+    :type point_x: int
+    :param point_x: the 'x' coordinate of the point
+    :type point_y: int
+    :param point_y: the 'y' coordinate of the point
+    :type curve_name: str
+    :param curve_name: well known name of the curve (e.g. 'NIST256p' or
+        'SECP256k1')
+    :type implementations: iterable of str
+    :param implementations: list of implementations that can be used as the
+        concrete implementation of the verifying key (only 'python' is
+        supported currently)
+    """
+    for impl in implementations:
+        if impl == "python":
+            return Python_ECDSAKey(point_x, point_y, curve_name)
+    raise ValueError("No acceptable implementation")
diff -urN tlslite-ng/tlslite/utils/python_ecdsakey.py tlslite-ng-simple-ecdsa-support/tlslite/utils/python_ecdsakey.py
--- tlslite-ng/tlslite/utils/python_ecdsakey.py	1969-12-31 19:00:00.000000000 -0500
+++ tlslite-ng-simple-ecdsa-support/tlslite/utils/python_ecdsakey.py	2019-09-25 14:20:03.000000000 -0500
@@ -0,0 +1,95 @@
+# Author Hubert Kario, copyright 2019
+
+from functools import partial
+from .ecdsakey import ECDSAKey
+from ecdsa.curves import curves
+from ecdsa.util import sigencode_der, sigdecode_der
+from ecdsa.keys import VerifyingKey, SigningKey, BadSignatureError
+from ecdsa.ellipticcurve import Point
+from ecdsa.der import UnexpectedDER
+from .tlshashlib import new
+from .cryptomath import numBits
+from .compat import compatHMAC
+
+class Python_ECDSAKey(ECDSAKey):
+    """
+    Concrete implementation of ECDSA object backed by python-ecdsa.
+
+    Object that uses the common, abstract API of asymmetric keys
+    that uses the python-ecdsa library for the cryptographic operations.
+
+    :vartype public_key: VerifyingKey
+    :ivar public_key: python-ecdsa object for veryfying ECDSA signatures, if
+        `private_key` is set, it should match it (should be able to verify
+        signatures created by it)
+
+    :vartype private_key: SigningKey
+    :ivar private_key: python-ecdsa object for creating ECDSA signatures
+
+    :vartype key_type: str
+    :ivar key_type: type of assymetric algorithm used by the keys - for this
+        objects it is always 'ecdsa'
+    """
+
+    def __init__(self, x, y, curve_name, secret_multiplier=None):
+        if not curve_name:
+            raise ValueError("curve_name must be specified")
+        self.curve_name = curve_name
+
+        for c in curves:
+            if c.name == curve_name or c.openssl_name == curve_name:
+                curve = c
+                break
+        else:
+            raise ValueError("Curve '{0}' not supported by python-ecdsa"
+                             .format(curve_name))
+
+        self.private_key = None
+        self.public_key = None
+        self.key_type = "ecdsa"
+
+        if secret_multiplier:
+            self.private_key = SigningKey.from_secret_exponent(
+                secret_multiplier, curve)
+
+        if x and y:
+            point = Point(curve.curve, x, y)
+            self.public_key = VerifyingKey.from_public_point(point, curve)
+
+        if not self.public_key:
+            self.public_key = self.private_key.get_verifying_key()
+
+    def __len__(self):
+        return numBits(self.public_key.curve.order)
+
+    def hasPrivateKey(self):
+        return bool(self.private_key)
+
+    def acceptsPassword(self):
+        return False
+
+    @staticmethod
+    def generate(bits):
+        raise NotImplementedError()
+
+    def _sign(self, data, hAlg):
+        func = partial(new, hAlg)
+
+        return self.private_key.\
+            sign_digest_deterministic(compatHMAC(data),
+                                      hashfunc=func,
+                                      sigencode=sigencode_der)
+
+    def _hashAndSign(self, data, hAlg):
+        return self.private_key.sign_deterministic(compatHMAC(data),
+                                                   hash=new(hAlg),
+                                                   sigencode=sigencode_der)
+
+    def _verify(self, signature, hash_bytes):
+        try:
+            return self.public_key.verify_digest(compatHMAC(signature),
+                                                 compatHMAC(hash_bytes),
+                                                 sigdecode_der)
+        # https://github.com/warner/python-ecdsa/issues/114
+        except (BadSignatureError, UnexpectedDER, IndexError, AssertionError):
+            return False
diff -urN tlslite-ng/tlslite/utils/python_key.py tlslite-ng-simple-ecdsa-support/tlslite/utils/python_key.py
--- tlslite-ng/tlslite/utils/python_key.py	1969-12-31 19:00:00.000000000 -0500
+++ tlslite-ng-simple-ecdsa-support/tlslite/utils/python_key.py	2019-09-25 14:20:03.000000000 -0500
@@ -0,0 +1,169 @@
+
+
+from .python_rsakey import Python_RSAKey
+from .python_ecdsakey import Python_ECDSAKey
+from .pem import dePem, pemSniff
+from .asn1parser import ASN1Parser
+from .cryptomath import bytesToNumber
+from .compat import compatHMAC
+from ecdsa.curves import NIST256p, NIST384p, NIST521p
+from ecdsa.keys import SigningKey, VerifyingKey
+
+class Python_Key(object):
+    """
+    Generic methods for parsing private keys from files.
+
+    Handles both RSA and ECDSA keys, irrespective of file format.
+    """
+
+    @staticmethod
+    def parsePEM(s, passwordCallback=None):
+        """Parse a string containing a PEM-encoded <privateKey>."""
+
+        if pemSniff(s, "PRIVATE KEY"):
+            bytes = dePem(s, "PRIVATE KEY")
+            return Python_Key._parse_pkcs8(bytes)
+        elif pemSniff(s, "RSA PRIVATE KEY"):
+            bytes = dePem(s, "RSA PRIVATE KEY")
+            return Python_Key._parse_ssleay(bytes)
+        elif pemSniff(s, "EC PRIVATE KEY"):
+            bytes = dePem(s, "EC PRIVATE KEY")
+            return Python_Key._parse_ecc_ssleay(bytes)
+        else:
+            raise SyntaxError("Not a PEM private key file")
+
+    @staticmethod
+    def _parse_pkcs8(bytes):
+        parser = ASN1Parser(bytes)
+
+        # first element in PrivateKeyInfo is an INTEGER
+        version = parser.getChild(0).value
+        if bytesToNumber(version) != 0:
+            raise SyntaxError("Unrecognized PKCS8 version")
+
+        # second element in PrivateKeyInfo is a SEQUENCE of type
+        # AlgorithmIdentifier
+        alg_ident = parser.getChild(1)
+        seq_len = alg_ident.getChildCount()
+        # first item of AlgorithmIdentifier is an OBJECT (OID)
+        oid = alg_ident.getChild(0)
+        if list(oid.value) == [42, 134, 72, 134, 247, 13, 1, 1, 1]:
+            key_type = "rsa"
+        elif list(oid.value) == [42, 134, 72, 134, 247, 13, 1, 1, 10]:
+            key_type = "rsa-pss"
+        elif list(oid.value) == [42, 134, 72, 206, 61, 2, 1]:
+            key_type = "ecdsa"
+        else:
+            raise SyntaxError("Unrecognized AlgorithmIdentifier: {0}"
+                              .format(list(oid.value)))
+        # second item of AlgorithmIdentifier are parameters (defined by
+        # above algorithm)
+        if key_type == "rsa":
+            if seq_len != 2:
+                raise SyntaxError("Missing parameters for RSA algorithm ID")
+            parameters = alg_ident.getChild(1)
+            if parameters.value != bytearray(0):
+                raise SyntaxError("RSA parameters are not NULL")
+        elif key_type == "ecdsa":
+            if seq_len != 2:
+                raise SyntaxError("Invalid encoding of algorithm identifier")
+            curveID = alg_ident.getChild(1)
+            if list(curveID.value) == [42, 134, 72, 206, 61, 3, 1, 7]:
+                curve = NIST256p
+            elif list(curveID.value) == [43, 129, 4, 0, 34]:
+                curve = NIST384p
+            elif list(curveID.value) == [43, 129, 4, 0, 35]:
+                curve = NIST521p
+            else:
+                raise SyntaxError("Unknown curve")
+        else:  # rsa-pss
+            pass  # ignore parameters - don't apply restrictions
+
+        if seq_len > 2:
+            raise SyntaxError("Invalid encoding of AlgorithmIdentifier")
+
+        #Get the privateKey
+        private_key_parser = parser.getChild(2)
+
+        #Adjust for OCTET STRING encapsulation
+        private_key_parser = ASN1Parser(private_key_parser.value)
+
+        if key_type == "ecdsa":
+            return Python_Key._parse_ecdsa_private_key(private_key_parser,
+                                                       curve)
+        else:
+            return Python_Key._parse_asn1_private_key(private_key_parser,
+                                                      key_type)
+
+    @staticmethod
+    def _parse_ssleay(data):
+        """
+        Parse binary structure of the old SSLeay file format used by OpenSSL.
+
+        For RSA keys.
+        """
+        private_key_parser = ASN1Parser(data)
+        # "rsa" type as old format doesn't support rsa-pss parameters
+        return Python_Key._parse_asn1_private_key(private_key_parser, "rsa")
+
+    @staticmethod
+    def _parse_ecc_ssleay(data):
+        """
+        Parse binary structure of the old SSLeay file fromat used by OpenSSL.
+
+        For ECDSA keys.
+        """
+        private_key = SigningKey.from_der(compatHMAC(data))
+        secret_mult = private_key.privkey.secret_multiplier
+        return Python_ECDSAKey(None, None, private_key.curve.name,
+                               secret_mult)
+
+    @staticmethod
+    def _parse_ecdsa_private_key(private, curve):
+        ver = private.getChild(0)
+        if ver.value != b'\x01':
+            raise SyntaxError("Unexpected EC key version")
+        private_key = private.getChild(1)
+        public_key = private.getChild(2)
+        # first two bytes are the ASN.1 custom type and the length of payload
+        # while the latter two bytes are just specification of the public
+        # key encoding (uncompressed)
+        # TODO: update ecdsa lib to be able to parse PKCS#8 files
+        if curve is not NIST521p:
+            if list(public_key.value[:1]) != [3] or \
+                    list(public_key.value[2:4]) != [0, 4]:
+                raise SyntaxError("Invalid or unsupported encoding of public key")
+
+            pub_key = VerifyingKey.from_string(
+                    compatHMAC(public_key.value[4:]),
+                    curve)
+        else:
+            if list(public_key.value[:3]) != [3, 129, 134] or \
+                    list(public_key.value[3:5]) != [0, 4]:
+                raise SyntaxError("Invalid or unsupported encoding of public key")
+
+            pub_key = VerifyingKey.from_string(
+                    compatHMAC(public_key.value[5:]),
+                    curve)
+        pub_x = pub_key.pubkey.point.x()
+        pub_y = pub_key.pubkey.point.y()
+        priv_key = SigningKey.from_string(compatHMAC(private_key.value),
+                                          curve)
+        mult = priv_key.privkey.secret_multiplier
+        return Python_ECDSAKey(pub_x, pub_y, curve.name, mult)
+
+    @staticmethod
+    def _parse_asn1_private_key(private_key_parser, key_type):
+        version = private_key_parser.getChild(0).value[0]
+        if version != 0:
+            raise SyntaxError("Unrecognized RSAPrivateKey version")
+        n = bytesToNumber(private_key_parser.getChild(1).value)
+        e = bytesToNumber(private_key_parser.getChild(2).value)
+        d = bytesToNumber(private_key_parser.getChild(3).value)
+        p = bytesToNumber(private_key_parser.getChild(4).value)
+        q = bytesToNumber(private_key_parser.getChild(5).value)
+        dP = bytesToNumber(private_key_parser.getChild(6).value)
+        dQ = bytesToNumber(private_key_parser.getChild(7).value)
+        qInv = bytesToNumber(private_key_parser.getChild(8).value)
+        return Python_RSAKey(n, e, d, p, q, dP, dQ, qInv, key_type)
+
diff -urN tlslite-ng/tlslite/utils/python_rsakey.py tlslite-ng-simple-ecdsa-support/tlslite/utils/python_rsakey.py
--- tlslite-ng/tlslite/utils/python_rsakey.py	2019-09-27 09:14:00.257090554 -0500
+++ tlslite-ng-simple-ecdsa-support/tlslite/utils/python_rsakey.py	2019-09-25 14:20:03.000000000 -0500
@@ -4,7 +4,6 @@
 """Pure-Python RSA implementation."""
 import threading
 from .cryptomath import *
-from .asn1parser import ASN1Parser
 from .rsakey import *
 from .pem import *
 from .deprecations import deprecated_params
@@ -118,86 +117,5 @@
     @deprecated_params({"data": "s", "password_callback": "passwordCallback"})
     def parsePEM(data, password_callback=None):
         """Parse a string containing a PEM-encoded <privateKey>."""
-        del password_callback
-        if pemSniff(data, "PRIVATE KEY"):
-            data = dePem(data, "PRIVATE KEY")
-            return Python_RSAKey._parse_pkcs8(data)
-        elif pemSniff(data, "RSA PRIVATE KEY"):
-            data = dePem(data, "RSA PRIVATE KEY")
-            return Python_RSAKey._parse_ssleay(data)
-        else:
-            raise SyntaxError("Not a PEM private key file")
-
-    @staticmethod
-    def _parse_pkcs8(data):
-        """Parse data in the binary PKCS#8 format."""
-        parser = ASN1Parser(data)
-
-        # first element in PrivateKeyInfo is an INTEGER
-        version = parser.getChild(0).value
-        if bytesToNumber(version) != 0:
-            raise SyntaxError("Unrecognized PKCS8 version")
-
-        # second element in PrivateKeyInfo is a SEQUENCE of type
-        # AlgorithmIdentifier
-        alg_ident = parser.getChild(1)
-        seqLen = alg_ident.getChildCount()
-        # first item of AlgorithmIdentifier is an OBJECT (OID)
-        oid = alg_ident.getChild(0)
-        if list(oid.value) == [42, 134, 72, 134, 247, 13, 1, 1, 1]:
-            key_type = "rsa"
-        elif list(oid.value) == [42, 134, 72, 134, 247, 13, 1, 1, 10]:
-            key_type = "rsa-pss"
-        else:
-            raise SyntaxError("Unrecognized AlgorithmIdentifier: {0}"
-                              .format(list(oid.value)))
-        # second item of AlgorithmIdentifier are parameters (defined by
-        # above algorithm)
-        if key_type == "rsa":
-            if seqLen != 2:
-                raise SyntaxError("Missing parameters for RSA algorithm ID")
-            parameters = alg_ident.getChild(1)
-            if parameters.value != bytearray(0):
-                raise SyntaxError("RSA parameters are not NULL")
-        else:  # rsa-pss
-            pass  # ignore parameters - don't apply restrictions
-
-        if seqLen > 2:
-            raise SyntaxError("Invalid encoding of AlgorithmIdentifier")
-
-        #Get the privateKey
-        private_key_parser = parser.getChild(2)
-
-        #Adjust for OCTET STRING encapsulation
-        private_key_parser = ASN1Parser(private_key_parser.value)
-
-        return Python_RSAKey._parse_asn1_private_key(private_key_parser,
-                                                     key_type)
-
-    @staticmethod
-    def _parse_ssleay(data):
-        """
-        Parse binary structure of the old SSLeay file format used by OpenSSL.
-        """
-        private_key_parser = ASN1Parser(data)
-
-        # "rsa" type as old format doesn't support rsa-pss parameters
-        return Python_RSAKey._parse_asn1_private_key(private_key_parser, "rsa")
-
-    # n, e, d, etc. are standar names for those values, keep them
-    # pylint: disable=invalid-name
-    @staticmethod
-    def _parse_asn1_private_key(private_key_parser, key_type):
-        version = private_key_parser.getChild(0).value[0]
-        if version != 0:
-            raise SyntaxError("Unrecognized RSAPrivateKey version")
-        n = bytesToNumber(private_key_parser.getChild(1).value)
-        e = bytesToNumber(private_key_parser.getChild(2).value)
-        d = bytesToNumber(private_key_parser.getChild(3).value)
-        p = bytesToNumber(private_key_parser.getChild(4).value)
-        q = bytesToNumber(private_key_parser.getChild(5).value)
-        dP = bytesToNumber(private_key_parser.getChild(6).value)
-        dQ = bytesToNumber(private_key_parser.getChild(7).value)
-        qInv = bytesToNumber(private_key_parser.getChild(8).value)
-        return Python_RSAKey(n, e, d, p, q, dP, dQ, qInv, key_type)
-    # pylint: enable=invalid-name
+        from .python_key import Python_Key
+        return Python_Key.parsePEM(data, password_callback)
diff -urN tlslite-ng/tlslite/x509.py tlslite-ng-simple-ecdsa-support/tlslite/x509.py
--- tlslite-ng/tlslite/x509.py	2019-09-27 09:14:00.260090588 -0500
+++ tlslite-ng-simple-ecdsa-support/tlslite/x509.py	2019-09-25 14:20:03.000000000 -0500
@@ -6,10 +6,13 @@
 
 """Class representing an X.509 certificate."""
 
+from ecdsa.keys import VerifyingKey
+
 from .utils.asn1parser import ASN1Parser
 from .utils.cryptomath import *
-from .utils.keyfactory import _createPublicRSAKey
+from .utils.keyfactory import _createPublicRSAKey, _create_public_ecdsa_key
 from .utils.pem import *
+from .utils.compat import compatHMAC
 
 
 class X509(object):
@@ -26,8 +29,8 @@
     :ivar subject: The DER-encoded ASN.1 subject distinguished name.
 
     :vartype certAlg: str
-    :ivar certAlg: algorithm of the public key, "rsa" for RSASSA-PKCS#1 v1.5
-        and "rsa-pss" for RSASSA-PSS
+    :ivar certAlg: algorithm of the public key, "rsa" for RSASSA-PKCS#1 v1.5,
+        "rsa-pss" for RSASSA-PSS, "ecdsa" for ECDSA
     """
 
     def __init__(self):
@@ -90,11 +93,13 @@
 
         # first item of AlgorithmIdentifier is the algorithm
         alg = alg_identifier.getChild(0)
-        rsa_oid = alg.value
-        if list(rsa_oid) == [42, 134, 72, 134, 247, 13, 1, 1, 1]:
+        alg_oid = alg.value
+        if list(alg_oid) == [42, 134, 72, 134, 247, 13, 1, 1, 1]:
             self.certAlg = "rsa"
-        elif list(rsa_oid) == [42, 134, 72, 134, 247, 13, 1, 1, 10]:
+        elif list(alg_oid) == [42, 134, 72, 134, 247, 13, 1, 1, 10]:
             self.certAlg = "rsa-pss"
+        elif list(alg_oid) == [42, 134, 72, 206, 61, 2, 1]:
+            self.certAlg = "ecdsa"
         else:
             raise SyntaxError("Unrecognized AlgorithmIdentifier")
 
@@ -106,9 +111,22 @@
             if params.value != bytearray(0):
                 raise SyntaxError("Unexpected non-NULL parameters in "
                                   "AlgorithmIdentifier")
+        elif self.certAlg == "ecdsa":
+            self._ecdsa_pubkey_parsing(
+                tbs_certificate.getChildBytes(subject_public_key_info_index))
+            return
         else:  # rsa-pss
             pass  # ignore parameters, if any - don't apply key restrictions
 
+        self._rsa_pubkey_parsing(subject_public_key_info)
+
+    def _rsa_pubkey_parsing(self, subject_public_key_info):
+        """
+        Parse the RSA public key from the certificate.
+
+        :param subject_public_key_info: ASN1Parser object with subject
+            public key info of X.509 certificate
+        """
 
         # Get the subjectPublicKey
         subject_public_key = subject_public_key_info.getChild(1)
@@ -135,6 +153,26 @@
         self.publicKey = _createPublicRSAKey(n, e, self.certAlg)
         # pylint: enable=invalid-name
 
+    def _ecdsa_pubkey_parsing(self, subject_public_key_info):
+        """
+        Convert the raw DER encoded ECDSA parameters into public key object
+
+        :param subject_public_key_info: bytes like object with DER encoded
+            public key in it
+        """
+        try:
+            # python ecdsa knows how to parse curve OIDs so re-use that
+            # code
+            public_key = VerifyingKey.from_der(compatHMAC(
+                subject_public_key_info))
+        except Exception:
+            raise SyntaxError("Malformed or unsupported public key in "
+                              "certificate")
+        x = public_key.pubkey.point.x()
+        y = public_key.pubkey.point.y()
+        curve_name = public_key.curve.name
+        self.publicKey = _create_public_ecdsa_key(x, y, curve_name)
+
     def getFingerprint(self):
         """
         Get the hex-encoded fingerprint of this certificate.
diff -urN tlslite-ng/unit_tests/test_tlslite_constants.py tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_constants.py
--- tlslite-ng/unit_tests/test_tlslite_constants.py	2019-09-27 09:14:00.261090599 -0500
+++ tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_constants.py	2019-09-25 14:20:03.000000000 -0500
@@ -8,6 +8,12 @@
     import unittest2 as unittest
 except ImportError:
     import unittest
+try:
+    import mock
+    from mock import call
+except ImportError:
+    import unittest.mock as mock
+    from unittest.mock import call
 
 from tlslite.handshakesettings import HandshakeSettings
 from tlslite.constants import CipherSuite, HashAlgorithm, SignatureAlgorithm, \
@@ -157,6 +163,17 @@
         self.assertEqual(filtered,
                          [CipherSuite.TLS_AES_128_GCM_SHA256])
 
+    def test_getEcdsaSuites(self):
+        hs = HandshakeSettings()
+        hs.keyExchangeNames = ["ecdhe_ecdsa"]
+        hs.cipherNames = ["aes128"]
+
+        filtered = CipherSuite.getEcdsaSuites(hs)
+
+        self.assertEqual(filtered,
+                         [CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
+                          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA])
+
     def test_getTLS13Suites(self):
         hs = HandshakeSettings()
         hs.maxVersion = (3, 4)
@@ -171,6 +188,75 @@
         self.assertEqual(CipherSuite.getTLS13Suites(hs, (3, 3)),
                          [])
 
+    def test_filter_for_certificate_with_no_cert(self):
+        orig_ciphers = [CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+                        CipherSuite.TLS_ECDH_ANON_WITH_3DES_EDE_CBC_SHA,
+                        CipherSuite.TLS_AES_128_GCM_SHA256]
+
+        new_ciphers = CipherSuite.filter_for_certificate(
+            orig_ciphers,
+            None)
+
+        self.assertFalse(orig_ciphers is new_ciphers)
+        self.assertEqual(new_ciphers,
+                         [CipherSuite.TLS_ECDH_ANON_WITH_3DES_EDE_CBC_SHA,
+                          CipherSuite.TLS_AES_128_GCM_SHA256])
+
+    def test_filter_for_certificate_with_rsa(self):
+        cert_list = mock.MagicMock()
+        cert = mock.MagicMock()
+        cert.certAlg = "rsa"
+        cert_list.x509List = [cert]
+
+        orig_ciphers = [CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+                        CipherSuite.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
+                        CipherSuite.TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,
+                        CipherSuite.TLS_AES_128_GCM_SHA256]
+
+        new_ciphers = CipherSuite.filter_for_certificate(
+            orig_ciphers, cert_list)
+
+        self.assertEqual(new_ciphers,
+                         [CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+                          CipherSuite.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
+                          CipherSuite.TLS_AES_128_GCM_SHA256])
+
+    def test_filter_for_certificate_with_rsa_pss(self):
+        cert_list = mock.MagicMock()
+        cert = mock.MagicMock()
+        cert.certAlg = "rsa-pss"
+        cert_list.x509List = [cert]
+
+        orig_ciphers = [CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+                        CipherSuite.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
+                        CipherSuite.TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,
+                        CipherSuite.TLS_AES_128_GCM_SHA256]
+
+        new_ciphers = CipherSuite.filter_for_certificate(
+            orig_ciphers, cert_list)
+
+        self.assertEqual(new_ciphers,
+                         [CipherSuite.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
+                          CipherSuite.TLS_AES_128_GCM_SHA256])
+
+    def test_filter_for_certificate_with_ecdsa(self):
+        cert_list = mock.MagicMock()
+        cert = mock.MagicMock()
+        cert.certAlg = "ecdsa"
+        cert_list.x509List = [cert]
+
+        orig_ciphers = [CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+                        CipherSuite.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
+                        CipherSuite.TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,
+                        CipherSuite.TLS_AES_128_GCM_SHA256]
+
+        new_ciphers = CipherSuite.filter_for_certificate(
+            orig_ciphers, cert_list)
+
+        self.assertEqual(new_ciphers,
+                         [CipherSuite.TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,
+                          CipherSuite.TLS_AES_128_GCM_SHA256])
+
 
 class TestSignatureScheme(unittest.TestCase):
     def test_toRepr_with_valid_value(self):
diff -urN tlslite-ng/unit_tests/test_tlslite_handshakesettings.py tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_handshakesettings.py
--- tlslite-ng/unit_tests/test_tlslite_handshakesettings.py	2019-09-27 09:14:00.262090611 -0500
+++ tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_handshakesettings.py	2019-09-25 14:20:03.000000000 -0500
@@ -235,15 +235,23 @@
     def test_no_signature_hashes_set_with_TLS1_2(self):
         hs = HandshakeSettings()
         hs.rsaSigHashes = []
+        hs.ecdsaSigHashes = []
         with self.assertRaises(ValueError):
             hs.validate()
 
     def test_no_signature_hashes_set_with_TLS1_1(self):
         hs = HandshakeSettings()
         hs.rsaSigHashes = []
+        hs.ecdsaSigHashes = []
         hs.maxVersion = (3, 2)
         self.assertIsNotNone(hs.validate())
 
+    def test_invalid_signature_ecdsa_algorithm(self):
+        hs = HandshakeSettings()
+        hs.ecdsaSigHashes += ['md5']
+        with self.assertRaises(ValueError):
+            hs.validate()
+
     def test_invalid_curve_name(self):
         hs = HandshakeSettings()
         hs.eccCurves = ['P-256']
diff -urN tlslite-ng/unit_tests/test_tlslite_keyexchange.py tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_keyexchange.py
--- tlslite-ng/unit_tests/test_tlslite_keyexchange.py	2019-09-27 09:14:00.263090622 -0500
+++ tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_keyexchange.py	2019-09-25 14:20:03.000000000 -0500
@@ -36,6 +36,7 @@
 from tlslite.extensions import SupportedGroupsExtension, SNIExtension
 from tlslite.utils.ecc import getCurveByName, decodeX962Point, encodeX962Point,\
         getPointByteSize
+from tlslite.utils.compat import a2b_hex
 import ecdsa
 from operator import mul
 try:
@@ -83,6 +84,27 @@
     "-----END CERTIFICATE-----\n"\
     )
 
+srv_raw_ec_key = str(
+    "-----BEGIN PRIVATE KEY-----\n"
+    "MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgCOZr0Ovs0eCmh+XM\n"
+    "QWDYVpsQ+sJdjiq/itp/kYnWNSahRANCAATINGMQAl7cXlPrYzJluGOgmc8sYvae\n"
+    "tO2EsXKYG6lnYhudZiepVYORP8vqLyxCF/bMIuuVKOPWSfsRGo/H8pnK\n"
+    "-----END PRIVATE KEY-----\n"
+    )
+
+srv_raw_ec_certificate = str(
+    "-----BEGIN CERTIFICATE-----\n"
+    "MIIBbTCCARSgAwIBAgIJAPM58cskyK+yMAkGByqGSM49BAEwFDESMBAGA1UEAwwJ\n"
+    "bG9jYWxob3N0MB4XDTE3MTAyMzExNDI0MVoXDTE3MTEyMjExNDI0MVowFDESMBAG\n"
+    "A1UEAwwJbG9jYWxob3N0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEyDRjEAJe\n"
+    "3F5T62MyZbhjoJnPLGL2nrTthLFymBupZ2IbnWYnqVWDkT/L6i8sQhf2zCLrlSjj\n"
+    "1kn7ERqPx/KZyqNQME4wHQYDVR0OBBYEFPfFTUg9o3t6ehLsschSnC8Te8oaMB8G\n"
+    "A1UdIwQYMBaAFPfFTUg9o3t6ehLsschSnC8Te8oaMAwGA1UdEwQFMAMBAf8wCQYH\n"
+    "KoZIzj0EAQNIADBFAiA6p0YM5ZzfW+klHPRU2r13/IfKgeRfDR3dtBngmPvxUgIh\n"
+    "APTeSDeJvYWVBLzyrKTeSerNDKKHU2Rt7sufipv76+7s\n"
+    "-----END CERTIFICATE-----\n"
+    )
+
 class TestKeyExchange(unittest.TestCase):
 
     expected_sha1_SKE = bytearray(
@@ -106,6 +128,20 @@
             b'\n3\x9d5\x14\x05\x06nA\xa0\x19\xd5\xaa\x9d\xd1\x16\xb3\xb9\xae'
             b'\xd1\xe4\xc04\xc1h\xc3\xf5/\xb2\xf6P\r\x1b"\xe9\xc9\x84&\xe1Z')
 
+    expected_tls1_1_ecdsa_SKE = bytearray(
+            b'\x0c\x00\x00P\x03\x00\x17\x03\x04\xff\xfa\x00G0E\x02!\x00\xc6'
+            b'\xa5\x83\xab\x13\xb83"P\xdcl\x817\xcbS\xab\xebxo\x91K@\x19\xe0'
+            b'#\xfe,M\xd7R\'\xb0\x02 <\xd6\x03\xdd\x1fS\x12o\xaaa\x9e\x7f\xf1'
+            b')\x93\xa9cr\xa1\xb3\xa7\r\xdb\xbbV\xb2\xac\xf6ZJ\xe3\x0e'
+            )
+    expected_tls1_2_ecdsa_SKE = bytearray(
+            b'\x0c\x00\x00R\x03\x00\x17\x03\x04\xff\xfa\x02\x03\x00G0E\x02!'
+            b'\x00\xc6\xa5\x83\xab\x13\xb83"P\xdcl\x817\xcbS\xab\xebxo\x91K@'
+            b'\x19\xe0#\xfe,M\xd7R\'\xb0\x02 <\xd6\x03\xdd\x1fS\x12o\xaaa\x9e'
+            b'\x7f\xf1)\x93\xa9cr\xa1\xb3\xa7\r\xdb\xbbV\xb2\xac\xf6ZJ\xe3\x0e'
+            )
+
+class TestKeyExchangeBasics(TestKeyExchange):
     def test___init__(self):
         keyExchange = KeyExchange(0, None, None, None)
 
@@ -171,6 +207,52 @@
 
         self.assertEqual(server_key_exchange.write(), self.expected_tls1_1_SKE)
 
+    def test_signServerKeyExchange_with_sha1_ecdsa_in_TLS1_2(self):
+        srv_private_key = parsePEMKey(srv_raw_ec_key, private=True)
+        client_hello = ClientHello()
+        cipher_suite = CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
+        server_hello = ServerHello().create((3, 3),
+                                            bytearray(32),
+                                            bytearray(0),
+                                            cipher_suite)
+        keyExchange = KeyExchange(cipher_suite,
+                                  client_hello,
+                                  server_hello,
+                                  srv_private_key)
+
+        server_key_exchange = ServerKeyExchange(cipher_suite, (3, 3))\
+                              .createECDH(ECCurveType.named_curve,
+                                          GroupName.secp256r1,
+                                          bytearray(b'\x04\xff\xfa'))
+
+        keyExchange.signServerKeyExchange(server_key_exchange, 'sha1')
+
+        self.maxDiff = None
+        self.assertEqual(server_key_exchange.write(),
+                         self.expected_tls1_2_ecdsa_SKE)
+
+    def test_signServerKeyExchange_in_TLS1_1_with_ecdsa(self):
+        srv_private_key = parsePEMKey(srv_raw_ec_key, private=True)
+        client_hello = ClientHello()
+        cipher_suite = CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
+        server_hello = ServerHello().create((3, 2),
+                                            bytearray(32),
+                                            bytearray(0),
+                                            cipher_suite)
+        keyExchange = KeyExchange(cipher_suite,
+                                  client_hello,
+                                  server_hello,
+                                  srv_private_key)
+        server_key_exchange = ServerKeyExchange(cipher_suite, (3, 2))\
+                              .createECDH(ECCurveType.named_curve,
+                                          GroupName.secp256r1,
+                                          bytearray(b'\x04\xff\xfa'))
+
+        keyExchange.signServerKeyExchange(server_key_exchange)
+
+        self.maxDiff = None
+        self.assertEqual(bytearray(server_key_exchange.write()),
+                         self.expected_tls1_1_ecdsa_SKE)
 
     def test_signServerKeyExchange_in_TLS1_1_signature_invalid(self):
         srv_private_key = parsePEMKey(srv_raw_key, private=True)
@@ -279,6 +361,363 @@
                                                 bytearray(32),
                                                 None)
 
+
+class TestServerKeyExchangeP256(unittest.TestCase):
+    @classmethod
+    def setUpClass(cls):
+        certificate = (
+            "-----BEGIN CERTIFICATE-----\n"
+            "MIIBbTCCARSgAwIBAgIJAPM58cskyK+yMAkGByqGSM49BAEwFDESMBAGA1UEAwwJ\n"
+            "bG9jYWxob3N0MB4XDTE3MTAyMzExNDI0MVoXDTE3MTEyMjExNDI0MVowFDESMBAG\n"
+            "A1UEAwwJbG9jYWxob3N0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEyDRjEAJe\n"
+            "3F5T62MyZbhjoJnPLGL2nrTthLFymBupZ2IbnWYnqVWDkT/L6i8sQhf2zCLrlSjj\n"
+            "1kn7ERqPx/KZyqNQME4wHQYDVR0OBBYEFPfFTUg9o3t6ehLsschSnC8Te8oaMB8G\n"
+            "A1UdIwQYMBaAFPfFTUg9o3t6ehLsschSnC8Te8oaMAwGA1UdEwQFMAMBAf8wCQYH\n"
+            "KoZIzj0EAQNIADBFAiA6p0YM5ZzfW+klHPRU2r13/IfKgeRfDR3dtBngmPvxUgIh\n"
+            "APTeSDeJvYWVBLzyrKTeSerNDKKHU2Rt7sufipv76+7s\n"
+            "-----END CERTIFICATE-----\n")
+        x509 = X509()
+        x509.parse(certificate)
+        cls.x509 = x509
+
+    def test_verify_ecdsa_signature_in_TLS1_2_SHA512(self):
+        skemsg = a2b_hex(
+                  "00009103001741048803928b0f1448237646bd5ae80b5144b315eb"
+                  "f083212f62db03bfd20ff1ec83b086a6b642e9147953b65518b94fdd"
+                  "b7946fa08726478e5d2543e833c24f57da060300483046022100b3ee"
+                  "ead2f6b30b905ce674f6b7c9e5e4e59239931a7836bb18be03f39e60"
+                  "a81c022100b9a064aead86af8e59aaaa30ca57e06f05e0ede23e4745"
+                  "524d830f5b85c7fa14")
+        parser = Parser(skemsg)
+
+        ske = ServerKeyExchange(
+                CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+                (3, 3))
+        ske.parse(parser)
+
+        client_random = a2b_hex("5078aff2993c6cc0d5bbc014a60e348890c"
+                                "ef321469d9f5ecc270be5e453e7c9")
+        server_random = a2b_hex("aa14012f6c6070b585fa53ba1010d5c4c08"
+                                "7314bd272cd52734c44c8f6037679")
+
+
+        KeyExchange.verifyServerKeyExchange(ske,
+                                            self.x509.publicKey,
+                                            client_random,
+                                            server_random,
+                                            [(HashAlgorithm.sha512,
+                                              SignatureAlgorithm.ecdsa)])
+
+    def test_verify_ecdsa_signature_in_TLS1_2_SHA1(self):
+        skemsg = a2b_hex(
+                        "00008f0300174104677708522c34"
+                        "792f4a71864854bc439134baf70cf9ec887db4f8"
+                        "ad39f87071c284f5a07975de42b0beec9dfe08c3"
+                        "ee3cdf53c49daa57aadfddee9c3be3ca05670203"
+                        "0046304402206e3f278d3b54108b40df17c71ac6"
+                        "8a801c7bb863a7c477fd8a21b680ca02fbeb0220"
+                        "1b497a72f9af66f406d1146971623d7087710641"
+                        "dfaff5cfd575a8359165c18f")
+        parser = Parser(skemsg)
+
+        ske = ServerKeyExchange(
+                CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+                (3, 3))
+        ske.parse(parser)
+
+        client_random = a2b_hex("affab7761c9d4882d10c17757f648"
+                                "76c04a25c0ccdbfa98d9c6a545794"
+                                "ab566c")
+        server_random = a2b_hex("21b01edc3232325bc6d761e9d4fea"
+                                "ccd811051c5bc5f3e09d769a5e15d"
+                                "d67273")
+
+        KeyExchange.verifyServerKeyExchange(ske,
+                                            self.x509.publicKey,
+                                            client_random,
+                                            server_random,
+                                            [(HashAlgorithm.sha1,
+                                              SignatureAlgorithm.ecdsa)])
+
+    def test_verify_ecdsa_signature_in_TLS1_2_SHA256(self):
+        skemsg = a2b_hex(
+                        "0000900300174104677708522c34792f4a71864854"
+                        "bc439134baf70cf9ec887db4f8ad39f87071c284f5a0"
+                        "7975de42b0beec9dfe08c3ee3cdf53c49daa57aadfdd"
+                        "ee9c3be3ca05670403004730450220762a8a7bfe61b9"
+                        "13f92f396908c889c4d12812057fe2f41b49c4bf572d"
+                        "a3ec17022100d02bbc51221eb00702856981a36a0958"
+                        "fda7f807f0881c677d20a5cc5cac03f4")
+        parser = Parser(skemsg)
+
+        ske = ServerKeyExchange(
+                CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+                (3, 3))
+        ske.parse(parser)
+
+        client_random = a2b_hex("cd10871a3d49e42ec2a9e6fc871d1049"
+                                "86f5b9c91f4d3f9d693290a611424d2f")
+        server_random = a2b_hex("109f6344e1fad353b2767f63ea152474"
+                                "bb12d21f5bd903880a30bda436f31684")
+
+        KeyExchange.verifyServerKeyExchange(ske,
+                                            self.x509.publicKey,
+                                            client_random,
+                                            server_random,
+                                            [(HashAlgorithm.sha256,
+                                              SignatureAlgorithm.ecdsa)])
+
+    def test_verify_ecdsa_signature_with_mismatched_hash(self):
+        # valid SKE but changed sha256 ID to SHA1 ID
+        skemsg = a2b_hex(
+                        "0000900300174104677708522c34792f4a71864854"
+                        "bc439134baf70cf9ec887db4f8ad39f87071c284f5a0"
+                        "7975de42b0beec9dfe08c3ee3cdf53c49daa57aadfdd"
+                        "ee9c3be3ca05670203004730450220762a8a7bfe61b9"
+                        "13f92f396908c889c4d12812057fe2f41b49c4bf572d"
+                        "a3ec17022100d02bbc51221eb00702856981a36a0958"
+                        "fda7f807f0881c677d20a5cc5cac03f4")
+        parser = Parser(skemsg)
+
+        ske = ServerKeyExchange(
+                CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+                (3, 3))
+        ske.parse(parser)
+
+        client_random = a2b_hex("cd10871a3d49e42ec2a9e6fc871d1049"
+                                "86f5b9c91f4d3f9d693290a611424d2f")
+        server_random = a2b_hex("109f6344e1fad353b2767f63ea152474"
+                                "bb12d21f5bd903880a30bda436f31684")
+
+        with self.assertRaises(TLSDecryptionFailed):
+            KeyExchange.verifyServerKeyExchange(ske,
+                                                self.x509.publicKey,
+                                                client_random,
+                                                server_random,
+                                                [(HashAlgorithm.sha1,
+                                                  SignatureAlgorithm.ecdsa)])
+
+    def test_verify_ecdsa_signature_with_unknown_alg(self):
+        # valid SKE but changed sha256 ID to 10
+        skemsg = a2b_hex(
+                        "0000900300174104677708522c34792f4a71864854"
+                        "bc439134baf70cf9ec887db4f8ad39f87071c284f5a0"
+                        "7975de42b0beec9dfe08c3ee3cdf53c49daa57aadfdd"
+                        "ee9c3be3ca05670a03004730450220762a8a7bfe61b9"
+                        "13f92f396908c889c4d12812057fe2f41b49c4bf572d"
+                        "a3ec17022100d02bbc51221eb00702856981a36a0958"
+                        "fda7f807f0881c677d20a5cc5cac03f4")
+        parser = Parser(skemsg)
+
+        ske = ServerKeyExchange(
+                CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+                (3, 3))
+        ske.parse(parser)
+
+        client_random = a2b_hex("cd10871a3d49e42ec2a9e6fc871d1049"
+                                "86f5b9c91f4d3f9d693290a611424d2f")
+        server_random = a2b_hex("109f6344e1fad353b2767f63ea152474"
+                                "bb12d21f5bd903880a30bda436f31684")
+
+        with self.assertRaises(TLSIllegalParameterException) as e:
+            KeyExchange.verifyServerKeyExchange(ske,
+                                                self.x509.publicKey,
+                                                client_random,
+                                                server_random,
+                                                [(0x0a,
+                                                  SignatureAlgorithm.ecdsa)])
+
+        self.assertIn("Unknown hash algorithm", str(e.exception))
+
+
+class TestServerKeyExchangeP384(unittest.TestCase):
+    @classmethod
+    def setUpClass(cls):
+        certificate = (
+            "-----BEGIN CERTIFICATE-----\n"
+            "MIIBqTCCATGgAwIBAgIJAOg7t3nOR8B6MAkGByqGSM49BAEwFDESMBAGA1UEAwwJ\n"
+            "bG9jYWxob3N0MB4XDTE3MTAyNDA4NDE0NFoXDTE3MTEyMzA4NDE0NFowFDESMBAG\n"
+            "A1UEAwwJbG9jYWxob3N0MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAESTMngPUfYFqz\n"
+            "6c13TgothkDP0NNLb9BxfJ6PeX+Z2Y9Kb/xONDrAil/avCHW3OzYrZjiVrhENRcR\n"
+            "1mtxA2ubSlU4bJwItdRy+frJolg4b27Wl9lSpCAn3rgCff9e0puoo1AwTjAdBgNV\n"
+            "HQ4EFgQUZ6FxONYHIe0yOhDzNfNlogyNkg8wHwYDVR0jBBgwFoAUZ6FxONYHIe0y\n"
+            "OhDzNfNlogyNkg8wDAYDVR0TBAUwAwEB/zAJBgcqhkjOPQQBA2cAMGQCMASrET+o\n"
+            "XSFfkriYgmIW8T5tSHZ7Jys1krAS4GUEHYdTkKWSuGfM+0uqblSNgjjYjAIwPXxK\n"
+            "pSc6nBMwoE0NFnEa+iL8O3Zl7LDnX2AuKOaV4Id8UuW9653fRCn7CPrfaPOm\n"
+            "-----END CERTIFICATE-----\n")
+        x509 = X509()
+        x509.parse(certificate)
+
+        cls.x509 = x509
+
+    def test_verify_ecdsa_signature_in_TLS1_2_SHA512(self):
+        skemsg = a2b_hex(
+            "0000af03001741046d571e6310febf38201af10f823241df990a2887f779e590"
+            "00dd8fb3ee801e0e700313225e3268c3db2d1eaf13495b99ac5fc4bff5c22d71"
+            "c9e867c958aafebb0603006630640230043bc6fd59d5b39296153264a10d63ae"
+            "8937120ca0874e7848004d4ce70d66d133af993edca59e93e31845671a1b6743"
+            "0230710169783ce59742bcff9884105bc85675d757cf3bc6ac3250f795ee8021"
+            "1f086afab96a9aafd3382c96eeb5afde2bc3")
+
+        parser = Parser(skemsg)
+
+        ske = ServerKeyExchange(
+                CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+                (3, 3))
+        ske.parse(parser)
+
+        client_random = a2b_hex("872eca2bd39eaca9eedb31c285f5809b"
+                                "5fd5a51efd6d1dee4e1ce4f741920a36")
+        server_random = a2b_hex("d85951258d55798f93619c38ac4fdd54"
+                                "153c5930cdf2cba6d555eec8d709e303")
+
+        KeyExchange.verifyServerKeyExchange(ske,
+                                            self.x509.publicKey,
+                                            client_random,
+                                            server_random,
+                                            [(HashAlgorithm.sha512,
+                                              SignatureAlgorithm.ecdsa)])
+
+    def test_verify_ecdsa_signature_in_TLS1_2_SHA384(self):
+        skemsg = a2b_hex(
+                "0000b103001741046d571e6310febf38201af10f823241df990a2887f77"
+                "9e59000dd8fb3ee801e0e700313225e3268c3db2d1eaf13495b99ac5fc4"
+                "bff5c22d71c9e867c958aafebb050300683066023100e12366ba68c36ae"
+                "f04c691f0c0067d0c8025f116627c5b963154fd219a9bc27ec4a11d6d1b"
+                "d4b5d33de8d2dcf639501c0231008a99dad2fa99a689e25422127f12dfe"
+                "8fdcaea1b97cb17b6267ebdd97631e004ca323132cc66e651844b40984c"
+                "7aa942")
+
+        parser = Parser(skemsg)
+
+        ske = ServerKeyExchange(
+                CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+                (3, 3))
+        ske.parse(parser)
+
+        client_random = a2b_hex("f706a53d88a5eb52d981c9943413b4f6"
+                                "73d7426dd4373fe517c1b881ab5713d2")
+        server_random = a2b_hex("d35fab56329f6ff1ac36a6fc6b98a393"
+                                "e50bc4cd8b8bf3038f8b914f0c105cd2")
+
+        KeyExchange.verifyServerKeyExchange(ske,
+                                            self.x509.publicKey,
+                                            client_random,
+                                            server_random,
+                                            [(HashAlgorithm.sha384,
+                                              SignatureAlgorithm.ecdsa)])
+
+
+    def test_verify_ecdsa_signature_in_TLS1_2_SHA256(self):
+        skemsg = a2b_hex(
+                "0000b103001741046d571e6310febf38201af10f823241df990a2887f779"
+                "e59000dd8fb3ee801e0e700313225e3268c3db2d1eaf13495b99ac5fc4bf"
+                "f5c22d71c9e867c958aafebb04030068306602310080e64fbb7063b5c424"
+                "4e59611a763adafdbf4bc392e3af7ad29c98251a4dcfd9f59b8c39fa46a8"
+                "f035d90e0b35181bee023100a383176790f00b2731f85ba90e05e6814080"
+                "8f05860c138e0c57eb496b6411792af4662acea03968d1b192afd6dbc2d6"
+                )
+
+        parser = Parser(skemsg)
+
+        ske = ServerKeyExchange(
+                CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+                (3, 3))
+        ske.parse(parser)
+
+        client_random = a2b_hex("2b1ffe918934adb2d66bb085bf56ba31"
+                                "0f6568732f81abc7f60c1bc43b2b8d15")
+        server_random = a2b_hex("5141986a5d3b26cbc051d58c76074643"
+                                "c62d8ba9a0aa77bceaa8ecec59771bfe")
+
+        KeyExchange.verifyServerKeyExchange(ske,
+                                            self.x509.publicKey,
+                                            client_random,
+                                            server_random,
+                                            [(HashAlgorithm.sha256,
+                                              SignatureAlgorithm.ecdsa)])
+
+class TestServerKeyExchangeP521(unittest.TestCase):
+    @classmethod
+    def setUpClass(cls):
+        certificate = (
+            "-----BEGIN CERTIFICATE-----\n"
+            "MIIB9DCCAVegAwIBAgIJALLS/7HVXjvLMAkGByqGSM49BAEwFDESMBAGA1UEAwwJ\n"
+            "bG9jYWxob3N0MB4XDTE3MTAyNDA5MzI1OVoXDTE3MTEyMzA5MzI1OVowFDESMBAG\n"
+            "A1UEAwwJbG9jYWxob3N0MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQA2W4PjcS5\n"
+            "O2XC/BePOpu3qLrIKdEYPTbXPz3kX1KAMUKb7Mndl8gYhmt3orymNfyvw/TjUBeT\n"
+            "D9C/kH87MM0MTdIADcZOQ8Kaq1KB33bNbsXtkV29SF+070tE6B0AdbKkA51Ak1G8\n"
+            "FWmEZtf01e8ajcfsDLzkQenY8nD9/jdXonyRMD6jUDBOMB0GA1UdDgQWBBT8H+nt\n"
+            "DHosWy5fTjmDltyvBB6JUjAfBgNVHSMEGDAWgBT8H+ntDHosWy5fTjmDltyvBB6J\n"
+            "UjAMBgNVHRMEBTADAQH/MAkGByqGSM49BAEDgYsAMIGHAkIB8rNy9Uq2ZZwFwbdw\n"
+            "FBjteJEkJS26E7m3bLf5YmCmdH6wyQd+EjoPVBwOrQxcH0eR/vYEmouTlsBGxdRN\n"
+            "1eIm4DQCQUVPccfLbGV4KK3tkij1GH9ej9AQvLpjVMkyhwNadmGadOcIpbciQyll\n"
+            "+m9uHWVCSntAeSzf2A6nnVBvRvGbZu1w\n"
+            "-----END CERTIFICATE-----\n")
+
+        x509 = X509()
+        x509.parse(certificate)
+
+        cls.x509 = x509
+
+    def test_verify_ecdsa_signature_in_TLS1_2_SHA384(self):
+        skemsg = a2b_hex(
+            "0000d3030017410402f8552b8fb2ce583f6572a872373857de5a4f179c00870"
+            "9305391e847416a894d523759e73205b94c64a683bb61f8a6c01c7fee180591"
+            "24f47e77aad3b32ada0503008a30818702420153e2b6526452f2174c4b70f9c"
+            "de18c63bc8a70bfde5f313e7608fb799893fea45d414e9ff176a9a0a7cd1b8c"
+            "0d659d147501ea6482d8d43ac75e0ce6864674196102415e6f6ac717dad1b10"
+            "cd20e9dc3d4f6d1e483a349cc7d37ecdb68231b3b41dd60cff9068e38cbd62d"
+            "1203be11556991c85c6b9348b958318a91cdaa2e249ea1cb9e")
+        parser = Parser(skemsg)
+
+        ske = ServerKeyExchange(
+                CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+                (3, 3))
+        ske.parse(parser)
+
+        client_random = a2b_hex("ccef6eefa66dda9e90c5e56dc3efa1ec"
+                                "259485ebcd2ec736ad2bcb3598ac3615")
+        server_random = a2b_hex("739fd50e4ecbb177f882536a71828f8e"
+                                "bcbcf3a3217da24fa3eb6f7d7b009401")
+
+        KeyExchange.verifyServerKeyExchange(ske,
+                                            self.x509.publicKey,
+                                            client_random,
+                                            server_random,
+                                            [(HashAlgorithm.sha384,
+                                              SignatureAlgorithm.ecdsa)])
+
+    def test_verify_ecdsa_signature_in_TLS1_2_SHA512(self):
+        skemsg = a2b_hex(
+            "0000d3030017410402f8552b8fb2ce583f6572a872373857de5a4f179c0087"
+            "09305391e847416a894d523759e73205b94c64a683bb61f8a6c01c7fee180591"
+            "24f47e77aad3b32ada0603008a308187024200c1ab9d049e28cdd107b7c180d4"
+            "dc8f78970edcee88a8b8fbd1a68572d342d97fa0ad1a7d1285ae8ea387c00d2d"
+            "f56dcd36146460ccba99e1323078888364604c3202412388817fea69babcb482"
+            "cacfe92056507cb85cd840c6a19c3fbf079e67399d72c81642b11b9e89612405"
+            "57e39a617f25efeebcfdcf3bf68c792f3a91318b0bd695")
+
+        parser = Parser(skemsg)
+
+        ske = ServerKeyExchange(
+                CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+                (3, 3))
+        ske.parse(parser)
+
+        client_random = a2b_hex("455c9402792ab4443cacc8f3bc2c9815"
+                                "7a3f3e1026a49e50fc04a9a3d2ba18d3")
+        server_random = a2b_hex("ae2c2a0b6f65209c10a6766e8d230eb6"
+                                "465927ae363950430ec049d6e32cae24")
+
+        KeyExchange.verifyServerKeyExchange(ske,
+                                            self.x509.publicKey,
+                                            client_random,
+                                            server_random,
+                                            [(HashAlgorithm.sha512,
+                                              SignatureAlgorithm.ecdsa)])
+
+
 class TestCalcVerifyBytes(unittest.TestCase):
     def setUp(self):
         self.handshake_hashes = HandshakeHashes()
diff -urN tlslite-ng/unit_tests/test_tlslite_messages.py tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_messages.py
--- tlslite-ng/unit_tests/test_tlslite_messages.py	2019-09-27 09:14:00.265090644 -0500
+++ tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_messages.py	2019-09-25 14:20:03.000000000 -0500
@@ -2376,6 +2376,21 @@
             b'\x8e?YW\xcd\xad\xc6\x83\x91\x1d.fe,\x17y' +
             b'=\xc4T\x89'))
 
+    def test_hash_with_ecdsa_in_tls1_1(self):
+        ske = ServerKeyExchange(
+                CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
+                (3, 2))
+
+        ske.createECDH(ECCurveType.named_curve,
+                       named_curve=GroupName.secp256r1,
+                       point=bytearray(b'\x04\xff\xab'))
+
+        hash1 = ske.hash(bytearray(32), bytearray(32))
+
+        self.assertEqual(hash1,
+                         bytearray(b' \xa0\xc1P5\xf7K/\xednd'
+                                   b'\xbaQ\xedo\xa13Z\xa5}'))
+
     def test_hash_with_rsa_pss_sha256(self):
         ske = ServerKeyExchange(
                 CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
diff -urN tlslite-ng/unit_tests/test_tlslite_utils_ecdsakey.py tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_utils_ecdsakey.py
--- tlslite-ng/unit_tests/test_tlslite_utils_ecdsakey.py	1969-12-31 19:00:00.000000000 -0500
+++ tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_utils_ecdsakey.py	2019-09-25 14:20:03.000000000 -0500
@@ -0,0 +1,76 @@
+# Copyright (c) 2019, Hubert Kario
+#
+# See the LICENSE file for legal information regarding use of this file.
+
+# compatibility with Python 2.6, for that we need unittest2 package,
+# which is not available on 3.3 or 3.4
+try:
+    import unittest2 as unittest
+except ImportError:
+    import unittest
+
+from tlslite.utils.ecdsakey import ECDSAKey
+
+
+class MockECDSAKey(ECDSAKey):
+    def __init__(self, public_key, private_key):
+        pass
+
+
+class TestECDSAKey(unittest.TestCase):
+
+    @classmethod
+    def setUpClass(cls):
+        cls.k = MockECDSAKey(None, None)
+
+    def test___init___not_implemented(self):
+        with self.assertRaises(NotImplementedError):
+            ECDSAKey(None, None)
+
+    def test___len__(self):
+        with self.assertRaises(NotImplementedError):
+            len(self.k)
+
+    def test_hasPrivateKey(self):
+        with self.assertRaises(NotImplementedError):
+            self.k.hasPrivateKey()
+
+    def test__sign(self):
+        with self.assertRaises(NotImplementedError):
+            self.k._sign(None, None)
+
+    def test__hashAndSign(self):
+        with self.assertRaises(NotImplementedError):
+            self.k._hashAndSign(None, None)
+
+    def test__verify(self):
+        with self.assertRaises(NotImplementedError):
+            self.k._verify(None, None)
+
+    def test_hashAndSign(self):
+        with self.assertRaises(NotImplementedError):
+            self.k.hashAndSign(bytearray(b'text'))
+
+    def test_hashAndVerify(self):
+        with self.assertRaises(NotImplementedError):
+            self.k.hashAndVerify(bytearray(b'sig'), bytearray(b'text'))
+
+    def test_sign(self):
+        with self.assertRaises(NotImplementedError):
+            self.k.sign(bytearray(b'hash value'))
+
+    def test_verify(self):
+        with self.assertRaises(NotImplementedError):
+            self.k.verify(bytearray(b'sig'), bytearray(b'hash value'))
+
+    def test_acceptsPassword(self):
+        with self.assertRaises(NotImplementedError):
+            self.k.acceptsPassword()
+
+    def test_write(self):
+        with self.assertRaises(NotImplementedError):
+            self.k.write()
+
+    def test_generate(self):
+        with self.assertRaises(NotImplementedError):
+            ECDSAKey.generate('NIST256p')
diff -urN tlslite-ng/unit_tests/test_tlslite_utils_python_ecdsakey.py tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_utils_python_ecdsakey.py
--- tlslite-ng/unit_tests/test_tlslite_utils_python_ecdsakey.py	1969-12-31 19:00:00.000000000 -0500
+++ tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_utils_python_ecdsakey.py	2019-09-25 14:20:03.000000000 -0500
@@ -0,0 +1,125 @@
+
+try:
+    import unittest2 as unittest
+except ImportError:
+    import unittest
+
+try:
+    import mock
+    from mock import call
+except ImportError:
+    import unittest.mock as mock
+    from unittest.mock import call
+
+from tlslite.utils.python_key import Python_Key
+from tlslite.utils.python_ecdsakey import Python_ECDSAKey
+
+class TestECDSAKey(unittest.TestCase):
+    @classmethod
+    def setUpClass(cls):
+        # 45 is not a very good or likely private value but it will work for
+        # testing
+        cls.key = Python_ECDSAKey(None, None, "NIST256p", 45)
+
+        # sha1 signature of message 'some message to sign'
+        cls.sha1_sig = \
+                bytearray(b'0E\x02!\x00\xf7Q\x97.\xcfv\x03\xf0\xff,^\xb9'
+                          b'\nZ\xbd\x0e\xaaf\xf2]\xe0\xb0\x91\xa6cY\xa9\xff'
+                          b'{@\x18\xc8\x02 <\x80\x1a\xfa\x14\xd2\\\x02\xfe'
+                          b'\x1a\xb7\x07X\xba\xd8`\xd4\x1d\xa9\x9cm\xc7\xcd'
+                          b'\x11\xbb\x1b\xd1A\xcdO\xa2?')
+
+    def test_parse_from_pem(self):
+        key = (
+            "-----BEGIN EC PRIVATE KEY-----\n"
+            "MHcCAQEEIAjma9Dr7NHgpoflzEFg2FabEPrCXY4qv4raf5GJ1jUmoAoGCCqGSM49\n"
+            "AwEHoUQDQgAEyDRjEAJe3F5T62MyZbhjoJnPLGL2nrTthLFymBupZ2IbnWYnqVWD\n"
+            "kT/L6i8sQhf2zCLrlSjj1kn7ERqPx/KZyg==\n"
+            "-----END EC PRIVATE KEY-----\n")
+
+        parsed_key = Python_Key.parsePEM(key)
+        self.assertIsInstance(parsed_key, Python_ECDSAKey)
+        self.assertTrue(parsed_key.hasPrivateKey())
+        self.assertFalse(parsed_key.acceptsPassword())
+        self.assertEqual(len(parsed_key), 256)
+
+    def test_python_ecdsa_fields(self):
+        self.assertIsInstance(self.key, Python_ECDSAKey)
+        self.assertTrue(self.key.hasPrivateKey())
+        self.assertFalse(self.key.acceptsPassword())
+        self.assertEqual(len(self.key), 256)
+
+    def test_generate(self):
+        with self.assertRaises(NotImplementedError):
+            Python_ECDSAKey.generate(256)
+
+    def test_sign_default(self):
+        msg = b"some message to sign"
+
+        sig = self.key.hashAndSign(msg)
+
+        # we expect deterministic ECDSA by default
+        self.assertEqual(sig, self.sha1_sig)
+
+    def test_verify(self):
+        msg = b'some message to sign'
+
+        r = self.key.hashAndVerify(self.sha1_sig, msg)
+
+        self.assertTrue(r)
+
+    def test_invalid_curve_name(self):
+        with self.assertRaises(ValueError) as e:
+            Python_ECDSAKey(None, None, "secp256r1", 45)
+
+        self.assertIn('not supported by python-ecdsa', str(e.exception))
+
+    def test_no_curve_name(self):
+        with self.assertRaises(ValueError) as e:
+            Python_ECDSAKey(None, None, "", 45)
+
+        self.assertIn("curve_name", str(e.exception))
+
+    def test_sign_and_verify_with_md5(self):
+        msg = b"some message to sign"
+
+        sig = self.key.hashAndSign(msg, hAlg="md5")
+
+        self.key.hashAndVerify(sig, msg, hAlg="md5")
+
+    def test_sign_and_verify_with_sha1(self):
+        msg = b"some message to sign"
+
+        sig = self.key.hashAndSign(msg, hAlg="sha1")
+
+        self.key.hashAndVerify(sig, msg)
+
+    def test_sign_and_verify_with_sha224(self):
+        msg = b"some message to sign"
+
+        sig = self.key.hashAndSign(msg, hAlg="sha224")
+
+        self.key.hashAndVerify(sig, msg, hAlg="sha224")
+
+    def test_sign_and_verify_with_sha256(self):
+        msg = b"some message to sign"
+
+        sig = self.key.hashAndSign(msg, hAlg="sha256")
+
+        self.key.hashAndVerify(sig, msg, hAlg="sha256")
+
+    @unittest.expectedFailure
+    def test_sign_and_verify_with_sha384(self):
+        msg = b"some message to sign"
+
+        sig = self.key.hashAndSign(msg, hAlg="sha384")
+
+        self.key.hashAndVerify(sig, msg, hAlg="sha384")
+
+    @unittest.expectedFailure
+    def test_sign_and_verify_with_sha512(self):
+        msg = b"some message to sign"
+
+        sig = self.key.hashAndSign(msg, hAlg="sha512")
+
+        self.key.hashAndVerify(sig, msg, hAlg="sha512")
diff -urN tlslite-ng/unit_tests/test_tlslite_utils_python_key.py tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_utils_python_key.py
--- tlslite-ng/unit_tests/test_tlslite_utils_python_key.py	1969-12-31 19:00:00.000000000 -0500
+++ tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_utils_python_key.py	2019-09-25 14:20:03.000000000 -0500
@@ -0,0 +1,143 @@
+
+try:
+    import unittest2 as unittest
+except ImportError:
+    import unittest
+
+try:
+    import mock
+    from mock import call
+except ImportError:
+    import unittest.mock as mock
+    from unittest.mock import call
+
+from tlslite.utils.python_key import Python_Key
+from tlslite.utils.python_rsakey import Python_RSAKey
+from tlslite.utils.python_ecdsakey import Python_ECDSAKey
+
+class TestKey(unittest.TestCase):
+    def test_rsa_key(self):
+        key = (
+            "-----BEGIN PRIVATE KEY-----\n"
+            "MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDmM/tmq/2/N0Yy\n"
+            "qBb2Bu2X3+zdAU+6lnUsz+pNN69nM20aNPi9QH4ekyxs/x+uj37Zlw2hDwA5pifA\n"
+            "44kFtOXkw1ex4lS1xxtWCuGu1YXTDgxS1I1dcNa4qdYvwlgBGyx2T0GdIDeG3sWN\n"
+            "WOx2OXBeW6wm0RRxqUhyI9SXaN8yQWsCaajPZxw89OJ1XaSShWrfD2xq6xmQYV6Y\n"
+            "P6KcIORlQG21a6BvDbewE3iM2OGAmlEv/a7OydKlerWrc3oFBBoOmgnbLuBaxkBQ\n"
+            "Nv0UQrRBfB+QOoD3cE3seAjkfkVV22llJ5cMn00YwFRdsRYlgNFkoS3k25YsTMb+\n"
+            "NqlGYnR1AgMBAAECggEAUCu6Wj9716RAZlPz6yrug/4QV8elJK5RkJG4X7wM8jwO\n"
+            "uxnHpuFXCv7mce9H8Vs4Kj9ZF8ZJpcof/iVACyS9C7acS+8u4T++XXDcuC7UtHQo\n"
+            "BpDPysMJhLZhSbC9RWVZTrq7dyVJMUdUNa3KbEIEyFfU1I/sNsll2Zpw52o2kSFe\n"
+            "Ip1TGcnVmFu0uKxPrlNLSSNOVQqz2fOYWBJLk98gk54HAkHpFk92FVorn17seAfS\n"
+            "ksF70B9X6MBUa6PDSgQfKCwGd27KBpTivx6d8QVtMNqrFq/cqZ7TwWDIq1atZ0aF\n"
+            "3mYXfXR0toRyYZEXaa14Ao7iCUt5D8d2IG9u3q88AQKBgQD5x6kiqO+ApY7V0S0g\n"
+            "SyaIdTBjYc9Rbb0qvgy0Mhq68Ekc2fBIdTLc+G9ajkVFIe5blZc0nvwgSLdRfWrJ\n"
+            "bFpX8SS9Aelgp0mcfXgfIpJmLrPijtgEipTCh/73GTJM3ZnHI1z6xrRP0hi1ww2Q\n"
+            "Z8oqF34H6glXfYHfMqy9VaGQ4QKBgQDr74T4BxiXK4dIQ0T4oRE/881dScrVz9Ok\n"
+            "3wPINa5bIvfqHPl3eAJgRYBkxjKRyxt29wvGtWBQvCTHvFgF9F+3v3mfXJPRHaZZ\n"
+            "e1VJn9Eqjz1KuArIOwSrmnCFrd9jim10Qo36AFU0myridllN/NQn4l7yYgnw2a1/\n"
+            "WbLYq2nSFQKBgAkJWyog2IFb+/3qUmqfrWY0byq5SCnXAYgBVi5SvbrTpKGBlPra\n"
+            "Gpv59PVevkzQ/HGdyNmjgtWcK92r3ugonmAeHkkkP5A6nSQnOehOdONzfxiMOG55\n"
+            "oQYkq2m/JJ25Sq30rpF4DN/yZuh0hRIbXyoErY+VvP7IUKGFkNBMv8qhAoGBANDV\n"
+            "pLPJzClanRcIfA86ukMKMPfm7kQM/gAMapOXeGow7JHr7aCiuC+wtTH+ARrtVbUa\n"
+            "fPD48HTl5ARroNo8cVD6idPWJPzPKsQ/l8FgVcs/GHh/qQOMwdiHDhw1R+sax0FF\n"
+            "+9eS3dh/lBj5uph+NufKxlHzF2t5sclsgxKnvzX1AoGAZlNZt2xn3q/kusUXLovS\n"
+            "WN8C3ty06qLbD99kiWqEC2gSXc94rk7K7R/1XgfxXV8uOA9eUPDBpchd9PUnhwBE\n"
+            "tnkuQZ0fZ1P6EpNTumeL/UvIaA2UFtqrzxxJPJQExPRqX5foT6FhXVtGrNGKw78C\n"
+            "Ft7IqSkjX742rx0ephmvZgE=\n"
+            "-----END PRIVATE KEY-----")
+
+        parsed_key = Python_Key.parsePEM(key)
+
+        self.assertIsInstance(parsed_key, Python_RSAKey)
+
+        exp_n = int("29060443439214279856616714317441381282994349643640084870"
+                    "42194472422505198384747878467307665661184232728624861572"
+                    "46118030874616185167217887082030330066913757629456433183"
+                    "57727014263595982166729996386221650476766003639153689499"
+                    "85761113451052281630236293941677142748838601564606627814"
+                    "78871504321887555454323655057925411605057705083616507918"
+                    "02130319371355483088627276339169052633563469569700890323"
+                    "45345689545843561543977465544801728579255200638380126710"
+                    "78271693450544506178122783381759966742683127796190767251"
+                    "31801425088592558384516012482302720815493207137857605058"
+                    "06980478584101642143302393556465736571436454903701271051"
+                    "7")
+
+        self.assertEqual(parsed_key.n, exp_n)
+
+    def test_ecdsa_key_pkcs8(self):
+        key = (
+            "-----BEGIN PRIVATE KEY-----\n"
+            "MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgCOZr0Ovs0eCmh+XM\n"
+            "QWDYVpsQ+sJdjiq/itp/kYnWNSahRANCAATINGMQAl7cXlPrYzJluGOgmc8sYvae\n"
+            "tO2EsXKYG6lnYhudZiepVYORP8vqLyxCF/bMIuuVKOPWSfsRGo/H8pnK\n"
+            "-----END PRIVATE KEY-----\n")
+
+        parsed_key = Python_Key.parsePEM(key)
+
+        self.assertIsInstance(parsed_key, Python_ECDSAKey)
+        self.assertEqual(parsed_key.private_key.privkey.secret_multiplier,
+                         int("40256217329389834316473379676481509423"
+                             "54978248437138490984956489316429083942"))
+        self.assertIsNotNone(parsed_key.public_key)
+
+    def test_ecdsa_key_ssleay(self):
+        key = (
+            "-----BEGIN EC PRIVATE KEY-----\n"
+            "MHcCAQEEIAjma9Dr7NHgpoflzEFg2FabEPrCXY4qv4raf5GJ1jUmoAoGCCqGSM49\n"
+            "AwEHoUQDQgAEyDRjEAJe3F5T62MyZbhjoJnPLGL2nrTthLFymBupZ2IbnWYnqVWD\n"
+            "kT/L6i8sQhf2zCLrlSjj1kn7ERqPx/KZyg==\n"
+            "-----END EC PRIVATE KEY-----\n")
+
+        parsed_key = Python_Key.parsePEM(key)
+
+        self.assertIsInstance(parsed_key, Python_ECDSAKey)
+        self.assertEqual(parsed_key.private_key.privkey.secret_multiplier,
+                         int("40256217329389834316473379676481509423"
+                             "54978248437138490984956489316429083942"))
+        self.assertIsNotNone(parsed_key.public_key)
+
+    def test_ecdsa_p224(self):
+        key = (
+            "-----BEGIN PRIVATE KEY-----\n"
+            "MHgCAQAwEAYHKoZIzj0CAQYFK4EEACEEYTBfAgEBBBxFHtoSt2Sbng5P70Pq04xU\n"
+            "dYOeuyeaf03bQojMoTwDOgAED9EfhLHR46fj4wD1SDbSU7wwgnjzXdCTcidCsuC5\n"
+            "fvLd2Tvc4Pdjmhxc0btlNvWMM5HmoRqj4vk=\n"
+            "-----END PRIVATE KEY-----\n")
+
+        # secp224r1 is not supported by tlslite-ng
+        with self.assertRaises(SyntaxError) as e:
+            Python_Key.parsePEM(key)
+
+        self.assertIn("Unknown curve", str(e.exception))
+
+    def test_ecdsa_p384(self):
+        key = (
+            "-----BEGIN PRIVATE KEY-----\n"
+            "MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDDjdQHtIxZwXVK9qPzt\n"
+            "pE6QSrzpSxmW2HvQm6D2l6+w48insmcdZkIoDSTCclVlZpihZANiAATz74XG7gPG\n"
+            "DOe2ipv1WN3QYQ8dCsJ5evMTX2VmMxF3wByPqrdr9g4dpQo2U9Rm2xxTwi6xZvFK\n"
+            "08lqBXsIjrUYnEahj25AKDMsyiZgiUJPlTFlg9/qprk5+4o9WMQBalQ=\n"
+            "-----END PRIVATE KEY-----\n")
+
+        parsed_key = Python_Key.parsePEM(key)
+
+        self.assertIsInstance(parsed_key, Python_ECDSAKey)
+        self.assertEqual(len(parsed_key), 384)
+
+    def test_ecdsa_p521(self):
+        key = (
+            "-----BEGIN PRIVATE KEY-----\n"
+            "MIHuAgEAMBAGByqGSM49AgEGBSuBBAAjBIHWMIHTAgEBBEIBS376Hksl8eIvBbU1\n"
+            "TgpGdlZK32zjgjFDp5IdaTaK5nkH2g35n2Iv5pWMcCvVA4cHKIi6nsJzNFQIPRZ/\n"
+            "8smb9EmhgYkDgYYABAHrw9Ud/fJGfzIp+EqNU/JlohUG+uidSJQ2E6o2y6qnHslE\n"
+            "U6FqdQItZQze162e6xaDZOrHOMeYGGiO+KdJmCF7pACSOS13NdebB7GH6kgAuM2t\n"
+            "rN12KXJk4qvC65CxpUudQW04fK0zcRi3zRNAuWgSClTQC1WMF2QgjlVgQr3ZD1A5\n"
+            "sw==\n"
+            "-----END PRIVATE KEY-----\n")
+
+        parsed_key = Python_Key.parsePEM(key)
+
+        self.assertIsInstance(parsed_key, Python_ECDSAKey)
+        self.assertEqual(len(parsed_key), 521)
diff -urN tlslite-ng/unit_tests/test_tlslite_x509.py tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_x509.py
--- tlslite-ng/unit_tests/test_tlslite_x509.py	1969-12-31 19:00:00.000000000 -0500
+++ tlslite-ng-simple-ecdsa-support/unit_tests/test_tlslite_x509.py	2019-09-25 14:20:03.000000000 -0500
@@ -0,0 +1,39 @@
+try:
+    import unittest2 as unittest
+except ImportError:
+    import unittest
+
+try:
+    import mock
+    from mock import call
+except ImportError:
+    import unittest.mock as mock
+    from unittest.mock import call
+
+from tlslite.x509 import X509
+from tlslite.utils.python_ecdsakey import Python_ECDSAKey
+
+class TestX509(unittest.TestCase):
+    def test_pem(self):
+        data = (
+            "-----BEGIN CERTIFICATE-----\n"
+            "MIIBbTCCARSgAwIBAgIJAPM58cskyK+yMAkGByqGSM49BAEwFDESMBAGA1UEAwwJ\n"
+            "bG9jYWxob3N0MB4XDTE3MTAyMzExNDI0MVoXDTE3MTEyMjExNDI0MVowFDESMBAG\n"
+            "A1UEAwwJbG9jYWxob3N0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEyDRjEAJe\n"
+            "3F5T62MyZbhjoJnPLGL2nrTthLFymBupZ2IbnWYnqVWDkT/L6i8sQhf2zCLrlSjj\n"
+            "1kn7ERqPx/KZyqNQME4wHQYDVR0OBBYEFPfFTUg9o3t6ehLsschSnC8Te8oaMB8G\n"
+            "A1UdIwQYMBaAFPfFTUg9o3t6ehLsschSnC8Te8oaMAwGA1UdEwQFMAMBAf8wCQYH\n"
+            "KoZIzj0EAQNIADBFAiA6p0YM5ZzfW+klHPRU2r13/IfKgeRfDR3dtBngmPvxUgIh\n"
+            "APTeSDeJvYWVBLzyrKTeSerNDKKHU2Rt7sufipv76+7s\n"
+            "-----END CERTIFICATE-----\n")
+        x509 = X509()
+        x509.parse(data)
+
+        self.assertIsNotNone(x509.publicKey)
+        self.assertIsInstance(x509.publicKey, Python_ECDSAKey)
+        self.assertEqual(x509.publicKey.public_key.pubkey.point.x(),
+            90555129468518880658937518803653422065597446465131062487534800201457796212578)
+        self.assertEqual(x509.publicKey.public_key.pubkey.point.y(),
+            12490546948316647166662676770106859255378658810545502161335656899238893361610)
+        self.assertEqual(x509.publicKey.curve_name, "NIST256p")
+
