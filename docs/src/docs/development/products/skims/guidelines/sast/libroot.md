---
id: libroot
title: Lib root vulnerabilities
sidebar_label: Libroot
slug: /development/products/skims/guidelines/sast/libroot
---

As mentioned in the introduction, for the languages supported by this library
and that are in active development, the following three-step procedure
is used:

## 1. Code parsing

Parse the code to a graph called the AST (Abstract Syntax Tree) using OS
libraries such as [tree-sitter](https://github.com/tree-sitter/)

## 2. Parsing transformation

The parsed graphs generated by external graphs generally have two problems.
First, they usually contain a lot of unnecessary information, such as
all the nodes for code separators and symbols ({}, ;, ...etc.),
which makes search algorithms computationally more expensive.

Additionally, the node types change between languages, which makes it harder
to program the search methods. For example, in java, function calls
are called `method_invocation`, whereas in JavaScript, they are called
`call_expression`.

Thus, this second step converts the AST into an optimized graph
called the **syntax graph**

### Syntax Graph

The purpose of the syntax graph is two-fold:

- Reduce the complexity and size of the AST.
- Generate a standard graph that uses common terminology between languages.

The algorithm uses recursion to perform this extra parsing of the original
AST graph, by following roughly the following steps:

1. The AST root node is delivered to the recursive function.

1. According to the language and the type of the node,
   a specific function `reader` is called.

1. The reader function parses the node and extracts only the relevant
   information. Afterwards, a function `builder` is called depending
   on the type of the node.

1. The builder function, as they name implies, builds the node with all
   the relevant characteristics.

1. The builder function also forks the algorithm, by calling
   the initial recursive function with all the child nodes as parameters.

1. The recursive function is called with all the children of the parent node
   and the process starts again until all the AST graph has been parsed into
   the syntax graph.

1. After all the nodes have been parsed, the graph is sent to a similar
   recursive algorithm that generates the control flow connections between the
   main nodes.

To see the parsed graphs, you can run skims using the debug flag.
This will generate a pair of SVG files with the AST and syntax graph.

(Another two SVG files get generated, whose use is outside the scope
of this documentation because they are in the process of being deprecated)

Before moving on to develop any methods in this library, it is recommended
that you familiarize yourself with the types of nodes of the syntax graph
and see how each part of the code is parsed.

## 3. Vulnerability search

Finally, the library uses methods to search for vulnerabilities in the code
by filtering and searching the syntax graph nodes.

This last step can be furthered subdivided, according to
two basic types of vulnerabilities.

### 3.1 Direct vulnerabilities

When a vulnerability is a direct consequence of an unsafe object or
function, the method searches the nodes of the syntax graph for the method and
reports all the instances.

See the following pseudocode example:

```js
let vuln_var = new danger_object();
```

In this case, the vulnerability can be detected by filtering the syntax graph
and searching for any occurrences of the `danger_object`

Before moving on to the next type of vulnerabilities, it is recommended
that you try to understand and debug one of several methods in lib_root
that only use the syntax graph to search for a given vulnerability.

### 3.2 Symbolic evaluation

Some vulnerabilities cannot be checked directly by only filtering
the syntax graph, because they depend on one or several additional conditions
that have to be met simultaneously.

See the following pseudocode example:

```js
let dangerous_var = "danger";

let vuln_method = potential_danger("danger");
let vuln_method1 = potential_danger(dangerous_var);

let safe_method = potential_danger("safe_var");
```

In this case, the method called `potential_danger` is only a vulnerability
when the parameter `danger` is used.

In order for the method to deliver value to the clients, it needs to be able
to distinguish that the third call use of the method is safe,
and to report both of the first two occurrences of the vulnerability.

This is the purpose of the **symbolic evaluation** module, which is a
semi-recursive algorithm that follows the following procedure:

1. The node that could potentially be dangerous gets sent to a
   generic dispatcher function. (In the example, this would be the parameter
   of the potential_danger method)

1. Depending on the label_type of the node, the node gets dispatched to a
   `evaluator` function.

1. Each node type has its own evaluator function that searches where the node
   symbol is defined or propagates the danger to the children nodes
   depending on the type of the node.

   For example, a `SymbolLookup` evaluator, searches in the graph
   where that symbol is defined and forks the algorithm to that node.
   A `VariableDeclaration` evaluator propagates the danger directly to the
   value node of the variable.

1. If the danger was propagated, the dispatcher function gets called with
   these new parameters and the process is repeated.

1. Depending on what the vulnerability is, each method has one or several
   specific `evaluator` functions, that check if the node is
   dangerous according to the vulnerability conditions and if so, marks the node
   as dangerous.

The algorithm finishes once all possible paths have been evaluated, and it
returns two values:

- A boolean value called danger.
- A set of string values called the `triggers` (Maybe empty when not needed)

Before moving on to understanding and using the `triggers`, it is
recommended that you understand methods that only use the danger
value to evaluate a vulnerability.

#### Triggers

Sometimes, a boolean value is not enough to check for a vulnerability,
because it requires several conditions to be met at the same time.

See the following pseudocode example:

```js
let dangerous_var = "danger";

let transformed_val = danger_transformation(dangerous_var);
let vulnerability = potential_danger(transformed_val);

let safe_method = potential_danger(dangerous_var);
```

In this case, the `danger` variable, needs to go through a
`danger_transformation` method before being used in the `potential_danger`
to cause a true vulnerability.

Ensuring this double condition would not be possible only with the use
of a boolean value. This is the main use of the triggers.

The symbolic evaluation works the same way as explained above, only this time,
at the specific evaluator for the method, a value would get added
to the triggers to represent the additional vulnerable condition.

It is recommended that you use this argument only when you fully understand
its implications and use cases. As guidelines, try to debug one of several
existing methods that use the triggers.
