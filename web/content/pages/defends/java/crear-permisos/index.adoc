:slug: defends/java/crear-permisos/
:category: java
:description: Nuestros ethical hackers explican que son los permisos y la importancia de estos a la hora de controlar y proteger la información. Además, mediante un ejemplo realizado en Java, enseñan la manera de crear permisos personalizados para las diferentes aplicaciones.
:keywords: Java, Seguridad, Permisos, Personalizado, BasicPermission, Acceso.
:defends: yes

= Crear permisos personalizados

== Necesidad

Se requiere crear permisos personalizados
a una aplicación hecha en +Java+.

== Contexto

A continuación se describen las circunstancias
bajo las cuales la siguiente solución tiene sentido:

. Se dispone de un compilador estándar de +Java+.

== Solución

Uno de los temas más recurrentes o,
mejor dicho, tener presente
a la hora de trabajar con la seguridad informática,
es la administración de permisos.
Dicha administración de permisos
es de suma importancia puesto que a la final,
es lo que determina que o quien
puede acceder a un recurso.

En palabras más técnicas,
un permiso es el poder que se le otorga a un usuario,
componente o funcionalidad de un sistema
de interactuar con dicho sistema de una manera controlada.
Por lo tanto, la importancia de los permisos
radica en que se debe definir
y controlar de manera adecuada
que personas indeseadas no accedan,
ni conozcan y/o manipulen la información del sistema.

Entonces, para establecer permisos personalizados en +Java+,
se debe tener en cuenta que el código
está representado bajo un objeto +CodeSource+.
Dicho objeto incluye tanto la ubicación del código
dentro del sistema de archivos
como un conjunto de certificados digitales
que han sido usados para firmar el código fuente.

. Para crear un permiso personalizado
es necesario crear una clase
que herede de +java.security.BasicPermission+.
Dicha clase representa la implementación
de un permiso básico donde se especifique
el nombre del objetivo a proteger.
+
.CustomPermission.java
[source, java, linenums]
----
import java.security.BasicPermission;

public class CustomPermission extends BasicPermission {
----

. Después, se crea una instancia
de la clase +java.security.BasicPermission+.
Para ello hay que invocar
el constructor de dicha clase pasándole como parámetro
el nombre del objetivo involucrado en el permiso.
+
[source, java, linenums]
----
  public CustomPermission(String perm) {
    super(perm);
  }
}
----

. Una vez creado el permiso,
se crea una clase que habilite el gestor de seguridad
para verificar si el código que realiza la invocación
de alguno de los servicios expuestos
tiene los permisos necesarios para poder consumirlos.
+
.api.java
[source, java, linenums]
----
public class API {
  public static void ControlMethod() {
    SecurityManager securityManager = System.getSecurityManager();
    if (securityManager != null) {
      securityManager.checkPermission(new CustomPermission("permission"));
    }
    System.out.println("Method was executing satisfly");
  }
}
----

. Posteriormente, se crea la clase encargada
de invocar el servicio +ControlMethod+ de la clase +API+.
Esta nueva clase debe tener los permisos necesarios
para poder realizar la invocación de manera satisfactoria.
+
.authorized.java
[source, java, linenums]
----
public class Authorized {
  public static void main(String[] args) {
    API.metodoControlado();
  }
}
----

. Como siguiente paso, se crea la clase +Malware+
que invocará el método +Authorized.main+.
+
.malware.java
[source, java, linenums]
----
public class Malware {
  public static void main(String[] args) {
    CLIAutorizado.main(null);
  }
}
----

. También habrá que crear la clase +NotAuthorized+
que llamará directamente el método +API.ControlMethod+.
+
.notauthorized.java
[source, java, linenums]
----
public class NotAuthorized {
  public static void main(String[] args) {
    API.metodoControlado();
  }
}
----

. Por último, se crea el archivo de políticas +java.policy+,
donde el campo +codeBase+
indica la ubicación del código fuente
y se le otorga el permiso al código
que se encuentre en esa ubicación.
En este caso, las clases que se encuentran
en las ubicaciones +src/api+ y +src/authorized+
(+CustomPermission+, +API+, +Authorized+)
tienen habilitado el permiso.
+
.policy.java
[source, java, linenums]
----
grant codebase "file:src/api/" {
  permission CustomPermission "permission";
};
grant codebase "file:src/autorizado/" {
  permission CustomPermission "permission";
};
----

. Se compila y ejecuta.
+
.compile.bash
[source, bash, linenums]
----
$ javac src/api/*.java
$ javac -classpath .:src/api src/authorized/Authorized.java
$ javac -classpath src/Authorized:src/api src/malware/Malware.java
$ javac -classpath .:src/api src/notauthorized/NotAuthorized.java
----

. Clase +Authorized+.
+
[source, bash, linenums]
----
$ java -classpath src/api:src/autorizado -Djava.security.manager
  -Djava.security.policy==java.policy Authorized
Method was executing satisfly
----

. Clases +Malware+ y +NotAuthorized+
+
[source, bash, linenums]
----
$ java -classpath src/api:src/malicioso:src/autorizado -Djava.security.manager
  -Djava.security.policy==java.policy Malware
Exception in thread "main" java.security.AccessControlException: access denied
  (CustomPermission permission)
   at java.security.AccessControlContext.checkPermission(AccessControlContext.java:393)
   at java.security.AccessController.checkPermission(AccessController.java:553)
   at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)
   at API.ControlMethod(API.java:8)
   at Authorized.main(Authorized.java:7)
   at Malware.main(Malware.java:7)

$ java -classpath src/api:src/no_autorizado/ -Djava.security.manager
  -Djava.security.policy==java.policy NotAuthorized
Exception in thread "main" java.security.AccessControlException: access denied
 (CustomPermission permiso)
  at java.security.AccessControlContext.checkPermission(AccessControlContext.java:393)
  at java.security.AccessController.checkPermission(AccessController.java:553)
  at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)
  at API.ControlMethod(API.java:8)
  at NotAuthorized.main(NotAuthorized.java:8)
----

== Descargas

Puedes descargar el código fuente
pulsando en los siguientes enlaces:

[button]#link:src/basicpermission.java[BasicPermission.java]#
Clase BasicPermission.

[button]#link:src/api.java[API.java]#
Clase API.

[button]#link:src/authorized.java[Authorized.java]#
Clase Authorized.

[button]#link:src/malware.java[Malware.java]#
Clase Malware.

[button]#link:src/notauthorized.java[NotAuthorized.java]#
Clase NotAuthorized.

== Referencias

. [[r1]] link:https://docs.oracle.com/javase/tutorial/security/userperm/index.html[Implementing Your Own Permission]
. [[r2]] link:https://docs.oracle.com/javase/7/docs/api/java/security/BasicPermission.html[Class BasicPermission]
. [[r3]] link:../../../rules/176/[REQ.176 Restringir objetos del sistema]
