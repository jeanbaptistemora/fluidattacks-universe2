:slug: trapdoors/
:date: 2019-01-08
:subtitle: Trapdoor functions and their importance in security
:category: math
:tags: encryption, math, security
:image: cover.png
:alt: Cats in a forest
:description: A general overview on the mathematical concept of trapdoors and how they are the foundation of security of information; this article shows the basic concept behind symmetric and asymmetric encryption of shared information and briefly explains the two main algorithms used.
:keywords: AES, Asymmetric, Encryption, Math, Symmetric, RSA
:author: Sebastian Villalobos
:writer: sevilla
:name: Sebastian Villalobos
:about1: Electronic Engineer
:about2: Programming, Electronics, Math
:source: https://unsplash.com/photos/LMnk4WPwo-w

= Don't let the cat out!

Functions! I'm sure you have heard this concept in many ways:
math, programming, economics,  etc.
And they all can be reduced to the same basic thing:
something that takes some inputs and produces some outputs.
Math is the case here, however, there is a lot to add to that short definition,
specially when we apply it to computer security,
because despite you might be unaware,
your security totally depend on a special kind of functions called `Trapdoors`.
<<r1 ,^[1]^>> Let's talk about trapdoor functions
and how they save you from "letting the cat out".

When we talk about inputs producing an output
we usually talk about the reverse process:
given the outputs deduce the inputs,
this is really useful in many applications... but not in security!
knowing an input from an output is a serious problem, you will see why.

A `Trapdoor` is essentially something taking an input and producing an output,
but it is extremely difficult to do the reverse process,
this is because to do so you need to know a "secret" called a private key
and you have to be the luckiest guy in all universes to guess it or
to guess the input.

Suppose:
|====
|*P* : Plain text data +
*E* : Encrypted data +
*K* : Secret key
|====

A `Trapdoor` is a function that encrypts with the properties:
|====
|*E* = f(*P*) (Easy to do) +
*P* = f^-1^(*E*) (Really hard to do!) +
*P* = f^-1^(*E*,*K*) (Easy to do)
|====

Now, `Trapdoors` are not the same as the well known hash functions,
hash functions are one-way functions as well,
but they are not reversible by any means,
whereas `Trapdoors` are reversible with the key.
This is what makes them fundamental for `Encryption` of shared information.

Your lifesaving, precious data is always put in a `Trapdoor`,
encrypted and transmitted and no one
(except the possessor of the secret and the luckiest guy in all universes)
can figure out the data.

== Symmetric and Asymmetric Encryption

When two ends have to exchange sensitive data,
they must agree on the key they both use, this is called `Symmetric Encryption`
<<r2 ,^[2]^>> where the same key is used to encrypt and to decrypt.
This key has to be transmitted first for agreement
before any other communication, but
how can they prevent a third party sniffs and retrieve the key?
they use a type of `Encryption` called `Asymmetric Encryption`:
It encrypts the data with one public key
and decrypts it with a different private key

|====
|*K~p~* : Public key +
*K~s~* : Private key +
|====
The data is encrypted with
|====
|*E* = f(*P*,*K~p~*) +
|====

And decrypted with
|====
|*P* = f^-1^(*E*,*K~p~*) +
|====

This `Encryption` is slow and it's not commonly used in data transmission.
It's only used between parties to agree on a shared key that
they use for `Symmetric Encryption` which
is the one used for large data exchange as it's faster.
The shared key for `Symmetric Encryption` is transmitted over
`Asymmetric Encryption` so no attacker can retrieve this symmetric key.

== RSA Encryption

Rivest, Shamir, Adleman, also know as `RSA` algorithm <<r3 ,^[3]^>> is the most
common algorithm for `Asymmetric Encryption` and
it's based on a `Trapdoor` function called _modular exponentiation_ :

|====
|*E* = *P*^*K*~*P*~^ mod *N*
|====

In this case knowing *P* from *E* is impossible, you need to know a secret
*K*~*S*~ in order to compute it.

`RSA` algorithm uses prime number arithmetics and modular exponentiation to
encrypt a message, the algorithm can be summarized like this :

1. Choose two prime numbers *_p_* and *_q_*.
2. Compute *_n_* = *_pq_*.
3. Compute Euler's function *_&#981;_* = (*_p_ - 1*)(*_q_ - 1*). <<r5 ,^[5]^>>
4. Choose a number *_e_* smaller and _coprime_ <<r6 ,^[6]^>> to *_&#981;_*.
5. Choose a number *_d_* such that (*_ed_ - 1*) mod *_&#981;_  = 0*, This is
know as the _modular multiplicative inverse_,<<r7 ,^[7]^>> in other words,
*_ed_ - 1* must be divisible entirely by *_&#981;_*.
6. (*_e_*,*_n_*) are the public key whereas (*_s_*,*_n_*) are the private key.

A message *_m_* is encrypted into *_c_* by

|====
| *_c_* =  *_m_*^*_e_*^ mod  *_n_*
|====

And decrypted by

|====
| *_m_* =  *_c_*^*_d_*^ mod  *_n_*
|====

Thus, anyone can know the public key value *_e_* to encrypt
but not the private key value *_d_* used to decrypt.
What about *_n_* ? could not they use it to come up with *_d_* ?
Yes, they can, they will just take tenths of years to do it
as *_n_* is chosen to be a very big number,
so breaking it into the prime factors *_p_*, *_q_* used to get *_e_*
and therefore *_d_*, would take long enough
that an attacker cannot crack the key.

== AES Encryption

`AES` (Advanced Encryption System) <<r4 ,^[4]^>> algorithm,
is usually the chosen one for `Symmetric Encryption`.
This algorithm is rather procedural than hard mathematical formula computation,
it basically encrypts a table of data in four steps:

1. `SubBytes` : Each value in a table is substituted by another using a table.
2. `ShiftRows` : Rows of the table are shifted by some offset.
3. `MixColumns` : Columns are mixed by a matrix operation.
4. `AddRoundKey` : The public key is performed over the table with an `XOR`
operation.

All operations performed are reversible and they are made
in order to eliminate or diffuse any possible pattern
or relationship of the ciphered message to the original one and
to the key that might hint an attack.


== Conclusion

You can be sure your data is very well protected and that the communication
won't be disclosed to any attacker thanks to a `Trapdoor`, of course, as
computing power continues to develop,
we might need to create new traps,
but now the assurance of your privacy on communication is really high,
so every time you browse your social networks, bank accounts, etc;
remember there is a `Trapdoor` that won't let any cat out.

== References

. [[r1]] link:http://mathworld.wolfram.com/TrapdoorOne-WayFunction.html[`Trapdoor` functions]
. [[r2]] link:https://hackernoon.com/symmetric-and-asymmetric-encryption-5122f9ec65b1[`Symmetric` and `Asymmetric` `Encryption`]
. [[r3]] link:https://hackernoon.com/how-does-rsa-work-f44918df914b[`RSA` Explained]
. [[r4]] link:https://thebestvpn.com/advanced-encryption-standard-aes/[`AES` Explained]
. [[r5]] link:https://en.wikipedia.org/wiki/Euler%27s_totient_function[Euler's function]
. [[r6]] link:https://simple.wikipedia.org/wiki/Coprime[Coprime number]
. [[r7]] link:https://en.wikipedia.org/wiki/Modular_multiplicative_inverse[Modular multiplicative inverse]
