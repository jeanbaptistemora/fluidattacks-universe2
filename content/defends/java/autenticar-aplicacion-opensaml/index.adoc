:slug: defends/java/autenticar-app-opensaml/
:category: java
:description: Nuestros ethical hackers explican cómo evitar vulnerabilidades de seguridad mediante la programación segura en Java al autenticar la aplicación del cliente usando OpenSAML. Esto es posible gracias a la implementación del servicio Single-Sign-on en el entorno web.
:keywords: Java, Seguridad, Autenticar, Cliente, OpenSAML, Single-Sign-On.
:defends: yes

= Autenticar Aplicación Cliente Usando OpenSAML

== Necesidad

Implementar el servicio de +Single-Sign-On+ en entornos Web.

== Contexto

A continuación se describen las circunstancias
bajo las cuales la siguiente solución tiene sentido:

. Se está desarrollando una aplicación en +Java+.
. Se está haciendo uso de +OpenSAML 2.x+.

== Solución

. El lenguaje +SAML+ (en inglés, +Security Assertion Markup Language+)
es un estándar basado en +XML+
para el intercambio de datos de autenticación y autorización
entre dominios de seguridad, es decir,
un proveedor de identidad y un proveedor de servicio.

. El problema esencial que +SAML+ busca resolver
es el de aportar el servicio de autenticación única +SSO+.
Lo cual es un reto un tanto difícil.

. En +SAML+ el principal (usualmente un usuario o una aplicación de cliente)
se ha autenticado con un proveedor de identidad.
El proveedor de identidad provee servicios de autenticación al principal,
+SAML+ no especifica la implementación de estos servicios,
esto es relevante para el principal y el proveedor de identidad.

. El proveedor de servicios depende de que el proveedor de identidad
autentique e identifique al principal.
Bajo demanda del principal,
el proveedor de identidad pasa una aserción +SAML+ al proveedor de servicios.
Dependiendo de la aserción,
el proveedor de servicios toma una decisión de control de acceso.

. +SAML+ es una especificación definida por +OASIS+.
Y existen diferentes implementaciones de este protocolo.
También existen múltiples implementaciones, algunas son:
* +Enterprise Sign On Engine+ (+ESOE+)
* +simpleSAMLphp+, +SAML V2.0 SP+, +SAML V2.0 IdP+.
* +Lasso+ - +Liberty Alliance Single Sign-On+.
* +OpenSSO+
* +OpenSAML+
* +Shibboleth+
* +SourceID+
* +ZXID+

. Según el autor. La biblioteca +OpenSAML+
es un conjunto de bibliotecas de +C\+\++ y +Java+
para soportar a los desarrolladores que trabajan con +SAML+.

. El primer paso que ha de realizarse
antes de usar la biblioteca
es invocar el método estático de inicialización +bootstrap+
definido en la clase +DefaultBootstrap+.
+
.opensaml.java
[source, java, linenums]
----
try {
  DefaultBootstrap.bootstrap();
  }
  catch (ConfigurationException e) {
    e.printStackTrace();
  }
----

. Continuando con la inicialización,
es necesario instanciar la clase +BasicParserPool+
de manera que se tenga un objeto capaz de interpretar
los mensajes +XML+ que se han de intercambiar.
+
[source, java, linenums]
----
BasicParserPool parserPool = new BasicParserPool();
parserPool.setNamespaceAware(true);
----

. La clase +Request+ define como se comportan las solicitudes a +SAML+.
En este objeto se almacena una lista de +AssertionArtifact+
que son referencias a mensajes de +SAML+.
La siguiente clase muestra
como puede manipularse el +request+ para adicionar +artifacts+.
+
[source, java, linenums]
----
private static Request buildSAML1ArtifactResolve(String base64Artifact)
{
  XMLObjectBuilderFactory bf = Configuration.getBuilderFactory();
  Request request = (Request) bf.getBuilder(Request.DEFAULT_ELEMENT_NAME)
    .buildObject(Request.DEFAULT_ELEMENT_NAME);
  AssertionArtifact assertionArtifact = (AssertionArtifact)bf.getBuilder
    (AssertionArtifact.DEFAULT_ELEMENT_NAME).buildObject(AssertionArtifact.DEFAULT_ELEMENT_NAME);
  assertionArtifact.setAssertionArtifact(base64Artifact);
  request.getAssertionArtifacts().add(assertionArtifact);
  // add other data to Request as appropriate
  return request;
}
----

. Para poder enviar la solicitud en formato +XML+,
se debe usar un envolvente:
+
[source, java, linenums]
----
Envelope envelope = buildSOAP11Envelope(request);

private static Envelope buildSOAP11Envelope(XMLObject payload) {
  XMLObjectBuilderFactory bf = Configuration.getBuilderFactory();
  Envelope envelope = (Envelope)bf.getBuilder(Envelope.DEFAULT_ELEMENT_NAME)
    .buildObject(Envelope.DEFAULT_ELEMENT_NAME);
  Body body = (Body)bf.getBuilder(Body.DEFAULT_ELEMENT_NAME)
    .buildObject(Body.DEFAULT_ELEMENT_NAME);
  body.getUnknownXMLObjects().add(payload);
  envelope.setBody(body);
  return envelope;
}
----

. El paso siguiente es crear el contexto de la comunicación
usando el protocolo de acceso a objetos simple +SOAP+,
inicializar el protocolo seguro +SSL/TLS+
y obtener un objeto que represente el cliente de las solicitudes.
+
[source, java, linenums]
----
// SOAP context used by the SOAP client
BasicSOAPMessageContext soapContext = new BasicSOAPMessageContext();
soapContext.setOutboundMessage(envelope);
// This part is for client TLS support
X509Credential clientTLSCred = getClientTLSCred(clientTLSPrivateKeyResourceName,
   clientTLSCertificateResourceName);
StaticClientKeyManager keyManager = new StaticClientKeyManager(clientTLSCred.getPrivateKey(),
   clientTLSCred.getEntityCertificate());
// Build the SOAP client
HttpClientBuilder clientBuilder = new HttpClientBuilder();
clientBuilder.setHttpsProtocolSocketFactory(new TLSProtocolSocketFactory(keyManager,
   new DelegateToApplicationX509TrustManager()));
HttpSOAPClient soapClient = new HttpSOAPClient(clientBuilder.buildClient(), parserPool);
----

. Con estos datos, es posible intercambiar mensajes de +SAML+.
+
[source, java, linenums]
----
//Ejemplo de envío de mensajes SAML.

String serverEndpoint = "https://idp.ejemplo.org:8443/idp/profile/SAML1/SOAP/ArtifactResolve";
// Send the message
try {
  soapClient.send(serverEndpoint, soapContext);
}
catch (SOAPException e) {
  e.printStackTrace();
}
catch (SecurityException e) {
  e.printStackTrace();
}
----
+
[source, java, linenums]
----
// Ejemplo de recepción de mensajes SAML.
// Access the SOAP response envelope
Envelope soapResponse = (Envelope) soapContext.getInboundMessage();
System.out.println("SOAP Response was:");
System.out.println(XMLHelper.prettyPrintXML(soapResponse.getDOM()));
----

. Código completo:
+
[source, java, linenums]
----
package brent.test;

import java.io.IOException;
import java.net.Socket;
import java.security.KeyException;
import java.security.Principal;
import java.security.PrivateKey;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import javax.net.ssl.X509KeyManager;
import org.opensaml.DefaultBootstrap;
import org.opensaml.saml1.core.AssertionArtifact;
import org.opensaml.saml1.core.Request;
import org.opensaml.ws.soap.client.BasicSOAPMessageContext;
import org.opensaml.ws.soap.client.http.HttpClientBuilder;
import org.opensaml.ws.soap.client.http.HttpSOAPClient;
import org.opensaml.ws.soap.client.http.TLSProtocolSocketFactory;
import org.opensaml.ws.soap.common.SOAPException;
import org.opensaml.ws.soap.soap11.Body;
import org.opensaml.ws.soap.soap11.Envelope;
import org.opensaml.xml.Configuration;
import org.opensaml.xml.ConfigurationException;
import org.opensaml.xml.XMLObject;
import org.opensaml.xml.XMLObjectBuilderFactory;
import org.opensaml.xml.parse.BasicParserPool;
import org.opensaml.xml.security.SecurityException;
import org.opensaml.xml.security.SecurityHelper;
import org.opensaml.xml.security.x509.X509Credential;
import org.opensaml.xml.security.x509.X509Util;
import org.opensaml.xml.util.DatatypeHelper;
import org.opensaml.xml.util.XMLHelper;
import edu.internet2.middleware.shibboleth.DelegateToApplicationX509TrustManager;

public class SAML1ArtifactResolveExample {
  public static void main(String[] args) {
    String base64Artifact = "...base64encodedSAML1ArtifactData...";
    String serverEndpoint = "https://idp.ejemplo.org:8443/idp/profile/SAML1/SOAP/ArtifactResolve";
    String clientTLSPrivateKeyResourceName = "client.key";
    String clientTLSCertificateResourceName = "client.crt";
    try {
      DefaultBootstrap.bootstrap();
    }
    catch (ConfigurationException e) {
      e.printStackTrace();
    }
    BasicParserPool parserPool = new BasicParserPool();
    parserPool.setNamespaceAware(true);
    // Build the outgoing message structures
    Request request = buildSAML1ArtifactResolve(base64Artifact);
    Envelope envelope = buildSOAP11Envelope(request);
    // SOAP context used by the SOAP client
    BasicSOAPMessageContext soapContext = new BasicSOAPMessageContext();
    soapContext.setOutboundMessage(envelope);
    // This part is for client TLS support
    X509Credential clientTLSCred =
    getClientTLSCred(clientTLSPrivateKeyResourceName,
    clientTLSCertificateResourceName);
    StaticClientKeyManager keyManager = new StaticClientKeyManager(clientTLSCred.getPrivateKey(),
      clientTLSCred.getEntityCertificate());
    // Build the SOAP client
    HttpClientBuilder clientBuilder = new HttpClientBuilder();
    clientBuilder.setHttpsProtocolSocketFactory(new TLSProtocolSocketFactory(
      keyManager,
    new DelegateToApplicationX509TrustManager()));
    HttpSOAPClient soapClient = new HttpSOAPClient(clientBuilder.buildClient(),parserPool);
    // Send the message
    try {
      soapClient.send(serverEndpoint, soapContext);
    }
	catch (SOAPException e) {
      e.printStackTrace();
    }
	catch (SecurityException e) {
      e.printStackTrace();
    }
    // Access the SOAP response envelope
    Envelope soapResponse = (Envelope) soapContext.getInboundMessage();
    System.out.println("SOAP Response was:");
    System.out.println(XMLHelper.prettyPrintXML(soapResponse.getDOM()));
  }

  private static Envelope buildSOAP11Envelope(XMLObject payload) {
    XMLObjectBuilderFactory bf = Configuration.getBuilderFactory();
    Envelope envelope = (Envelope)bf.getBuilder(Envelope.DEFAULT_ELEMENT_NAME)
      .buildObject(Envelope.DEFAULT_ELEMENT_NAME);
    Body body = (Body)bf.getBuilder(Body.DEFAULT_ELEMENT_NAME)
      .buildObject(Body.DEFAULT_ELEMENT_NAME);
    body.getUnknownXMLObjects().add(payload);
    envelope.setBody(body);
    return envelope;
  }

  private static Request buildSAML1ArtifactResolve(String base64Artifact)
  {
    XMLObjectBuilderFactory bf = Configuration.getBuilderFactory();
    Request request = (Request) bf.getBuilder(Request.DEFAULT_ELEMENT_NAME)
     .buildObject(Request.DEFAULT_ELEMENT_NAME);
    AssertionArtifact assertionArtifact =(AssertionArtifact)bf.getBuilder
     (AssertionArtifact.DEFAULT_ELEMENT_NAME).buildObject(AssertionArtifact.DEFAULT_ELEMENT_NAME);
    assertionArtifact.setAssertionArtifact(base64Artifact);
    request.getAssertionArtifacts().add(assertionArtifact);
    // add other data to Request as appropriate
    return request;
  }

  private static X509Credential getClientTLSCred(String clientTLSPrivateKeyResourceName,
    String clientTLSCertificateResourceName) {
      PrivateKey privateKey = null;
      X509Certificate cert = null;
      try {
        privateKey = SecurityHelper.decodePrivateKey(DatatypeHelper.inputstreamToString(
          SAML1ArtifactResolveExample.class.getResourceAsStream
		    (clientTLSPrivateKeyResourceName),null).getBytes(), null);
        cert = X509Util.decodeCertificate(DatatypeHelper.inputstreamToString
		   (SAML1ArtifactResolveExample.class.getResourceAsStream
		     (clientTLSCertificateResourceName),null).getBytes()).iterator().next();
      }
	  catch (KeyException e) {
        e.printStackTrace();
      }
	  catch (IOException e) {
        e.printStackTrace();
      }
	  catch (CertificateException e) {
        e.printStackTrace();
      }
      return SecurityHelper.getSimpleCredential(cert, privateKey);
   }
}

class StaticClientKeyManager implements X509KeyManager {
  private static final String clientAlias = "myStaticAlias";
  private PrivateKey privateKey;
  private X509Certificate cert;

  public StaticClientKeyManager(PrivateKey newPrivateKey, X509Certificate newCert) {
    privateKey = newPrivateKey;
    cert = newCert;
  }
  /** {@inheritDoc} */

  public String chooseClientAlias(String[] as, Principal[] aprincipal, Socket socket) {
    System.out.println("chooseClientAlias");
    return clientAlias;
  }
  /** {@inheritDoc} */

  public String chooseServerAlias(String s, Principal[] aprincipal, Socketsocket) {
    System.out.println("chooseServerAlias");
    return null;
  }
  /** {@inheritDoc} */

  public X509Certificate[] getCertificateChain(String s) {
    System.out.println("getCertificateChain");
    return new X509Certificate[] {cert};
  }
  /** {@inheritDoc} */

  public String[] getClientAliases(String s, Principal[] aprincipal) {
    System.out.println("getClientAliases");
    return new String[] {clientAlias};
  }
  /** {@inheritDoc} */

  public PrivateKey getPrivateKey(String s) {
    System.out.println("getPrivateKey");
    return privateKey;
  }

  /** {@inheritDoc} */

  public String[] getServerAliases(String s, Principal[] aprincipal) {
    System.out.println("getServerAliases");
    return null;
  }
}
----

== Descargas

Puedes descargar el código fuente
pulsando en el siguiente enlace:

[button]#link:src/saml.java[SAML1ArtifactResolveExample.java >>]#
Código que muestra como usar +opensaml+.

== Referencias

. [[r1]] link:https://wiki.shibboleth.net/confluence/display/OpenSAML/Home[OpenSAML 2]
. [[r2]] link:https://wiki.shibboleth.net/confluence/display/OpenSAML/OSTwoUserManJavaSOAPClientExample[OSTwoUserManJavaSOAPClientExample]
. [[r3]] REQ.0224: El Proceso de Autenticación unificado
(SSO: Single Sign On) debe implementarse
mediante protocolos estándar (ej: SAML).
