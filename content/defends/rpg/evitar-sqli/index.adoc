:slug: defends/rpg/evitar-sqli/
:category: rpg
:description: Nuestros ethical hackers explican cómo evitar vulnerabilidades de seguridad mediante la programación segura en RPG al evitar ataques de inyección de código SQL. La validación de entradas de las aplicaciones es un proceso fundamental para evitar brechas de seguridad y fugas de información.
:keywords: RPG, SQL, Bases de Datos, Inyección, Ataques, Seguridad.
:defends: yes

= Evitar Inyección SQL

== Necesidad

Evitar que un atacante controle las instrucciones +SQL+ usadas en +iSeries+.

== Contexto

A continuación se describen las circunstancias
bajo las cuales la siguiente solución tiene sentido:

. Se está desarrollando una aplicación en +RPG+ que contiene sentencias +SQL+.
. Debe validarse la entrada de información antes de ser usada.
. La aplicación requiere de una conexión a una base de datos relacional
a través del lenguaje de consulta +SQL+.
. Se desea evitar vulnerabilidades de tipo inyección +SQL+.

== Solución

. El término "SQL dinámico" se refiere a los comandos +SQL+
que se interpretan en tiempo de ejecución.
En esta situación, las sentencias +SQL+ se cargan en una variable del +host+,
luego se realiza un llamado +PREPARE+
para decirle al procesador +SQL+
que compile la sentencia en un comando ejecutable.

. La siguiente aplicación obtiene los campos +nombre+ y +edad+
de la tabla +estudiantes+
según el nombre indicado en la variable +sqlnombre+.​

. Definimos las variables:
+sqlnombre+ que contiene el nombre a buscar en la tabla,
+sqlcommand+ el cual es la sentencia dinámica a ejecutar,
que contiene el carácter que sirve para indicar
la búsqueda de un campo +string+,
+datastructure+ contiene la estructura de datos
donde se almacenará el retorno de la sentencia.
+
.sqlselect.rpgle
[source, sql, linenums]
----
D sqlnombre       S             20A   INZ('fsg')

D sqlcommand      S            256A   INZ('SELECT nombre, edad +
D                                          FROM Fluid-Attacks/ESTUDIANTES +
D                                          WHERE nombre = ')
D                                     VARYING

D quote           S              1A   INZ('''')

D datastructure   DS
D  nombre                       30A   VARYING
D  edad                         10S 0
----

. Asignamos el nombre a la sentencia dinámica:
+SELECT nombre, edad FROM estudiantes WHERE nombre = '$nombre'+ ,
como se muestra a continuación:
+
[source, sql, linenums]
----
C                   EVAL      sqlcommand = sqlcommand +
C                                          quote + sqlnombre + quote
----

. Se definen las configuraciones para almacenar la información
y cerrar los recursos:
+
[source, sql, linenums]
----
C/exec sql
C+   SET OPTION
C+   COMMIT = *NONE,
C+   CLOSQLCSR = *ENDMOD
C/end-exec
----

. Preparamos la sentencia +SQL+ que proviene de +sqlcommand+:
+
[source, sql, linenums]
----
C/exec sql
C+ PREPARE SQLSTATEMENT FROM :sqlcommand
C/end-exec
----

. Definimos el cursos +CURSORSQL+,
con el cual podremos recorrer las filas retornadas por la sentencia:
+
[source, sql, linenums]
----
C/exec sql
C+ DECLARE CURSORSQL CURSOR FOR SQLSTATEMENT
C/end-exec
----

. Abrimos el cursor:
+
[source, sql, linenums]
----
C/exec sql
C+ OPEN CURSORSQL
C/end-exec
----

. Iniciamos la ejecución de la sentencia:
+
[source, sql, linenums]
----
C/exec sql
C+ FETCH NEXT FROM CURSORSQL INTO :datastructure
C/end-exec
----

. Iniciamos el ciclo que recorre cada fila
solo si el estado de la sentencia es igual a +00000+
(La sentencia fue exitosa y no hubo advertencias),
el estado +02000+ es usado cuando no se han encontrado filas.
Imprimimos la estructura:
+
[source, sql, linenums]
----
C                   DOW       SQLSTT = '00000'
C     datastructure DSPLY
----

. Se obtiene la siguiente fila y la insertamos en la estructura de datos:
+
[source, sql, linenums]
----
C/exec sql
C+ FETCH NEXT FROM CURSORSQL INTO :datastructure
C/end-exec
----

. Finalizamos el ciclo y el programa
+
[source, sql, linenums]
----
C                   ENDDO

C                   RETURN
----

. Este tipo de instrucciones son de gran flexibilidad
ya que se puede contener comandos +SQL+ insertados
y cargados por diferentes medios.
Sin embargo, esta flexibilidad puede llevar a problemas de seguridad.
En el ejemplo anterior si la variable +sqlnombre+ contiene datos válidos,
por ejemplo, el nombre +fsg (INZ('fsg'))+,
la sentencia se vería de la siguiente manera:
+
[source, sql, linenums]
----
SELECT nombre, edad FROM estudiantes WHERE nombre = 'fsg'
----

. Sin embargo, si la variable contiene otro tipo de información
por ejemplo +fsg' OR 1=1-- (INZ('fsg'' OR 1=1--'))+,
la sentencia generada es:
+
[source, sql, linenums]
----
SELECT nombre, edad FROM estudiantes WHERE nombre = 'fsg' OR 1=1--'
----

. En este caso, se recuperan todos los registros,
ya que se ha escrito una tautología.

. Para evitar este comportamiento es deseable evitar el uso de +SQL dinámico+.
Si de todas formas es necesario su uso,
se deben utilizar sentencias parametrizadas para evitar la inyección.

. Se define la nueva sentencia, el carácter +?+
es reemplazado al momento de abrir el cursor:
+
[source, sql, linenums]
----
D sqlcommand      S            256A   INZ('SELECT nombre, edad +
D                                          FROM Fluid-Attacks/ESTUDIANTES +
D                                          WHERE nombre = ? ')
D                                     VARYING
----

. Se eliminan las líneas que contienen el siguiente código:
+
[source, sql, linenums]
----
D quote           S              1A   INZ('''')

C                   EVAL      sqlcommand = sqlcommand +
C                                          quote + sqlnombre + quote
----

. Y se modifica la línea que contiene la instrucción
para abrir el cursor por:
+
[source, sql, linenums]
----
C/exec sql
C+ OPEN CURSORSQL USING :sqlnombre
C/end-exec
----

. Cada carácter +?+ en la sentencia
es reemplazado por la variable definida en +USING+.

. Si se usa más de una variable, por ejemplo para la sentencia
+
----
SELECT nombre, edad FROM estudiantes WHERE nombre = '$nombre' AND edad = '$edad'
----
+
el código correspondiente sería:
+
[source, sql, linenums]
----
D sqlcommand      S            256A   INZ('SELECT nombre, edad +
D                                          FROM Fluid-Attacks/ESTUDIANTES +
D                                          WHERE nombre = ? AND edad = ? ')
D                                     VARYING
----

. Y en el cursor:
+
[source, sql, linenums]
----
C/exec sql
C+ OPEN CURSORSQL USING :sqlnombre, :sqledad
C/end-exec
----

== Descargas

[button]#link:src/sqlselect1.rpgle[sqlselect1.rpgle]# y [button]#link:src/sqlselect2.rpgle[sqlselect2.rpgle]#
contienen el código fuente anteriormente descrito,
para evitar inyecciones +SQL+ en +RPG+.


== Referencias

. [[r1]] link:../../../rules/173/[REQ.173 Descartar información insegura].
. [[r2]] link:https://www.itjungle.com/2005/10/05/fhg100505-story02/[The Dangers of Dynamic SQL]
