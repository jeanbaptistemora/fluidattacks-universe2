:slug: pars-orationis-secura/
:date: 2018-03-22
:subtitle: Utilizando intérpretes para detectar fallas
:category: ataques
:tags: detectar, inyección, escáner
:image: cover.png
:alt: Serpiente leyendo un documento
:description: Cómo usar Python y pyparsing para analizar el código de la aplicación para encontrar inyecciones de SQL en bWAPP. Una inyección SQL se define como una consulta SQL con concatenaciones. El intérprete detecta la mayoría de las inyecciones de SQL a pesar de sus limitaciones y no tiene falsos positivos.
:keywords: Prueba, Detección, Intérprete, Python, Inyección, BWAPP
:author: Rafael Ballestas
:writer: raballestasr
:name: Rafael Ballestas
:about1: Mathematician
:about2: with an itch for CS
:source-highlighter: pygments
:translate: pars-orationis-secura/

= Pars orationis non est secura

Nos gusta link:http://itsecgames.com/[+bWAPP+] por aquí,
porque es muy defectuoso !.
Aquí hemos mostrado cómo encontrar y explotar vulnerabilidades como
link:../../../en/blog/fuzzy-bugs-online/#comparison-with-manual-injection[+SQL+]
link:../../../en/blog/importance-pentesting/[injection],
link:../../../en/blog/gherkin-steroids/#dynamic-detection-and-exploitation[directory traversal],
link:../../../en/blog/xml-exploitable-markup-language/#injecting-xpath-into-a-vulnerable-app[+XPath+ injection],
y
link:../../../en/blog/app-pickle/#documenting-attack-vectors[+UNIX+ command injection].
Todos ellas tienen una cosa en común, la cual es:
podrían haberse evitado con un poco de
link:https://www.owasp.org/index.php/Data_Validation[ validación de entradas].
En +PHP+ esto podría haberse hecho
con funciones como +fgetss+,
link:../../../en/blog/app-pickle/[+str_replace+] o
link:../../../en/blog/gherkin-steroids/[+strpos+].

Tomando algunas ideas del
link:../../../en/blog/stand-shoulders-giants/[análisis de código estático]
y el enfoque de
link:../../../en/blog/oracle-code/['código-como-datos']
¿qué pasaría si pudiéramos utilizar algún tipo de código
o herramienta de análisis de sintaxis para obtener información
acerca de dónde se encuentran las debilidades de las aplicaciones?
Para eso están los intérpretes.

== Detección manual

Consideremos por ejemplo,
este sitio en nuestra aplicación web defectuosa favorita:

.Añadiendo una entrada al "blog"
image::add-entry.png["Add entry to blog screenshot"]

Cada vez que cargamos la página las entradas actuales en el blog
son _seleccionadas_ desde una base de datos +MySQL+.

La página en sí es bastante sencilla:
una cabecera, un menú, una barra lateral y un pie de página,
los cuales se mantienen uniformes en todo el sitio,
con la información importante dentro de su propio +<div>+.
El código fuente de dicha página luce así:


.Adaptado de +bWAPP+. Corchetes y cargas de línea removidos
[source,php,numbered]
----
include::/web/content/blog-en/pars-orationis-secura/redux-sqli-7.php[]
----

Por supuesto, estamos interesados principalmente en el +PHP+ y el +HTML+
mezclados en el +<div id="main">+,
lo cual es justo lo que recortamos aquí,
porque es donde está el +SQL+.
Mirando unos pocos códigos fuentes adicionales,
notamos que siempre explotamos la misma vulnerabilidad.

Una petición +SQL+ es realizada al concatenar valores literales,
llamados a funciones +PHP+
y variables +PHP+ como +$entry+, mostrada anteriormente.
Esa variable viene de una petición +POST+
y es enviada a la función de desinfección +sqli+.
Luego de concatenar y construir la petición,
es enviada a la base de datos para ser procesada.

De esta manera, podríamos escribir

[source,sql]
----
a','b'; drop table blog;--
----

En el campo de entrada
para convertir la petición en una peligrosa, una que elimine el blog.

Para detectar exitosamente estas inyecciones +SQL+
necesitamos buscar cadenas que contengan código +SQL+
así como utilizar la concatenación +PHP+ (+first . last+).
Ésto no es suficiente,
debido a que también necesitamos relacionar la variable concatenada
con la entrada o parámetro
donde vamos a colocar el código malicioso +SQL+.

Para cazar las inyecciones +SQL+ en +bWAPP+,
nuestra herramienta elegida será un conjunto de intérpretes,
es decir, una pieza de software usada para escanear una cadena o archivo,
en busca de partes que conformen un conjunto específico de reglas.

== Especificando los Objetivos

Antes de continuar con los problemas del análisis y la  gramática,
permítanos reflexionar sobre lo que queremos encontrar.
Queremos detectar fragmentos de texto en el código,
los cuales conforman la sintaxis de una sentencia +SQL+ +SELECT+ o +INSERT+.
Pero también deben tener concatenaciones,
debido a que una sentencia sencilla como:

[source,sql]
----
SELECT * FROM blog;
----

Es perfectamente segura.¿Dónde podríamos inyectar algo?

Por lo tanto, necesitamos sentencias +SELECT+ o +INSERT+ con concatenaciones.
También queremos que nuestra herramienta sea capaz de identificar:

* Qué variable está en riesgo.

* Dónde y cómo está definida.

* Si está o no protegida por alguna función.

* Cualquier otra información que podamos encontrar.

La sintaxis de +INSERT+, de acuerdo a
link:https://dev.mysql.com/doc/refman/5.7/en/insert.html[+MySQL+],
se muestra a continuación:

[source,sql]
----
INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
    [INTO] tbl_name
    [PARTITION (partition_name [, partition_name] ...)]
    [(col_name [, col_name] ...)]
    {VALUES | VALUE} (value_list) [, (value_list)] ...
    [ON DUPLICATE KEY UPDATE assignment_list]
----

Ésto funciona como una excusa para introducir
la notación de sintaxis de lenguaje
link:https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form#Example['Backus-Naur form'] (+BNF+)
Esencialmente, todo lo contenido dentro de los corchetes es [opcional],
la tubería (+|+) representa una sentencia +or+,
las llaves representan sentencias +{obligatorias}+
y los +...+ representa una repetición opcional.

Para nuestros propósitos, la sentencia +INSERT+ tiene la siguiente forma:

[source,sql]
----
INSERT INTO tbl_name [column-names] VALUES (value-list)
----

Utilizaremos sub-intérpretes para definir el significado de cada elemento.
Por ejemplo +tbl_name+ es cualquier identificador +SQL+,
el cual consiste de símbolos alfanuméricos y guiones bajos (+_+).
Y +value-list+ se compone de un valor único
o una lista de valores separados por comas.

Pero qué es un valor? Aquí es donde se pone interesante.
Considere este ejemplo:

[source,sql]
----
INSERT INTO table VALUES ('1', NOW(), '" . $var1 . "','" . clean($var2, 1) . "'
----

Entonces, un valor puede ser:

* Un número o cadena estática.

* Una función +MySQL+ como +NOW()+.

* Una concatenación de una cadena o número obtenido de:

** Una variable +PHP+ (+$var1+).

** Una función (+clean()+), la cual también puede tomar argumentos

Aquí es cuando los intérpretes muestran su potencial
y el enfoque alternativo de
link:https://en.wikipedia.org/wiki/Regular_expression[expresiones regulares], falla.
Imagine tratar de escribir un +regex+
para hacer coincidir una sentencia +INSERT+ con concatenaciones.
Sería enorme, además de muy difícil de entender.
Otras desventajas de las expresiones regulares
son que tienen que tratar con los espacios en blanco de forma explícita
y son difíciles de mantener
cuando hay algún cambio en la sintaxis del lenguaje.
Como dice el famoso refrán:

[quote,Jamie Zawinski]
Algunas personas, al confrontar un problema piensan
"Ya sé, utilizaré expresiones regulares"
Ahora tienen dos problemas

== Aprendiendo el idioma

Ahora que hemos excluido las expresiones regulares,
tenemos que elegir un intérprete.
Aparentemente el estándar por un tiempo solía ser la combinación de
link:http://dinosaur.compilertools.net/[+lex+ and +yacc+],
lo cual era bastate complicado.
Hoy en día tenemos dos elecciones sólidas:
link:http://www.antlr.org/[+ANTLR+] para los amantes de +Java+
y link:http://pyparsing.wikispaces.com/[+pyparsing+] para nosotros.

.No necesitas ser un mago para utilizar +pyparsing+!
image::parsertongue.png["Comic about pyparsing and Harry Potter"]

Algunas características geniales de +pyparsing+ son:

* Utiliza una sintaxis simple que hace la gramática transparente.

* Se ajusta bien a su código en +Python+.

* Utiliza constructores de clases estándar
y lenguaje plano en lugar de extraños símbolos crípticos.

* Es tolerante a los cambios y fácil de adaptar
a las diferentes entradas u objetivos a encontrar.

* Incluye algunas funciones de ayuda bastante útiles,
como acciones de conversión (convertir una cadena de dígitos a un entero).

En +pyparsing+ el intérprete más externo
para la sentencia +INSERT+ se traduce a:

[source,python]
----
sql_insert = CaselessKeyword("INSERT INTO") + sql_identifier + Optional(column_names)
       + CaselessKeyword("VALUES") + values
----

Las funciones en +SentenceCase+ son construidas en +pyparsing+,
y sus nombres son bastantes ilustrativos.
El operador +++ es sobrecargado para interpretarse como "seguido por"
y es insensitivo a los espacios en blanco.
Los identificadores +snake_case+ sólo son identificadores
y tenemos que definirlos:

[source,python]
----
sql_identifier = Word(alphanums + "_")
values = Group( Literal("(") + delimitedList(value) + Literal(")") ).setResultsName("values")
----

Tome por ejemplo +Palabra+ para representar
cualquier combinación de los caracteres dados.
De esta forma +identificador_sql+
es sólo una combinación de caracteres alfanuméricos y el guión bajo.
Los +valores+ son sólo una lista delimitada,
encerrada entre paréntesis.
Agrupamos esa lista en una sola entidad
de tal forma que podamos referirnos a ella por su nombre después.

Los identificadores +PHP+ son como los nombres +SQL+,
pero deben empezar con el símbolo +$+.
También definimos los llamados a la función.

[source,python]
----
php_identifier = Combine( Literal("$") + sql_identifier ).setResultsName("php identifier")
php_funcall = Combine( sql_identifier + Literal("(") +
             + Optional(delimitedList(php_identifier)) + Literal(")") )
----

A diferencia de +Group+, +Combine+ combina
todos los +tokens+ encontrados en uno solo.
Hacemos eso debido a que en realidad no nos interesa
cada una de las partes de la función de llamado,
sino únicamente los +identificadores_php+ en su interior,
y podemos acceder a ellos utilizando los nombres
con los cuales bautizamos los identificadores +PHP+ anteriormente.
Nótese que, a pesar que los +identificadores_sql+
no pertenecen aquí lógicamente,
tienen la misma sintaxis como nombres de funciones
y cola de identificadores,
por lo que podemos de igual manera reutilizar ese intérprete.

Finalmente, llegamos al centro del tema:
un +valor+ a insertar es, ya sea una palabra o un número,
el resultado de una función, o una *concatenación peligrosa*:

[source,python]
----
value = varchar ^ php_funcall ^ danger_concat
danger = ( ... + (php_identifier ^ php_funcall) + ... ).setResultsName("danger identifier")
----

Aquí, el símbolo +^+ es el conector lógico +OR+,
y hemos omitido algunos intérpretes literales,
por todas las comillas y puntos.
Por cierto, nótese que todas las partes nombradas de nuestro gran intérprete
son intérpretes en sí, y podemos usarlas por separado.

Una forma de utilizar un intérprete es utilizando el método +parseString+.
Éste retornará la estructura de +tokens+
si hay una coincidencia, o arroja un +ParseException+ en caso contrario.

----
>>> print(test_values)
('1', now(), '" . $var1 "')
>>> result = values.parseString(test_values)
>>> print(result)
[['1', 'now()', '$var', '3']]
>>> print(result["values"]["danger identifier"])
['$var']
>>> print(values.parseString("not a list of values")
...
pyparsing.ParseException: Expected "(" (at char 0), (line:1, col:1)
----

Nótese como nos referimos a la lista de valores retornados
como +result["values"]+,
y de ellos podemos obtener los identificadores
que hacen parte de la concatenación peligrosa.

La función +scanString+ busca subcadenas que coincidan con la gramática.
Bastante útil. Además le dice donde se encontraron las subcadenas.
Lo utilizamos para informar al usuario acerca de la línea y columna
en donde la potencial inyección +SQL+ fue encontrada.

[source,python,numbered]
----
for tokens, start, end in sql_injection.scanString(content):
    sqli_line = line(start, content)
    print("In file {0}, line {1}, col {2}:\n{3:^}"
          .format(path.split("/")[-1], lineno(start,content),
          col(start,content), sqli_line.strip() ))
----

Éstas son algunas de las funciones de ayuda
de +pyparsing+ mencionadas anteriormente:
+scanString+ retorna un iterador el cual da +tokens+,
al igual +parseString()+,
pero también caracteres iniciales y finales.
Para convertirlos a números de línea y columna,
utilizamos las funciones +lineno()+ y +colno()+, respectivamente.

Hasta ahora, esto no es nada fuera de este mundo:
nada que no podríamos haber hecho
con +grep+ o expresiones regulares de +Python+.
Donde los intérpretes realmente superan las expresiones regulares
es en la extracción de información y estructura de la entrada,
como hicimos anteriormente para identificar los valores insertados
y de aquellos que son las variables donde podemos inyectar +SQL+.
Para eso, lamentablemente, tenemos que analizar de nuevo
porque no sabemos de antemano si el valor insertado es un llamado a función
o un identificador de +PHP+:

[source,python]
----
injectable_variables = tokens["values"]
for injectable_variable in injectable_variables:
    res = (php_identifier ^ php_funcall).parseString(injectable_variable)
    injectable_variable = res["phpvar"]
    print(" Injectable variable {0}. Other ocurrences:".format(injectable_variable))
----

Recuerde que necesitamos detectar líneas con peticiones +SQL+
que contengan variables concatenadas peligrosamente,
pero también _dónde_ estas variables son tomadas de la entrada del usuario
y si están o no protegidas.
Pero, ya que tenemos la "variable inyectable" como una +cadena+ regular,
podemos crear otro intérprete "sobre la marcha"
para encontrar las líneas donde la variable es mencionada.
Ésta es sencilla:

[source,python,numbered]
----
tpar = Literal(injectable_variable)
for tokens, start, end in tpar.scanString(content):
    print("  L{0:<3} {1}".format(lineno(start2, content),
                                 line(start2,content).strip()))
----

En cualquier punto, si se arroja una +ParseException+ o un +KeyError+,
eso sólo significa que un +parseString+ falló,
o que tratamos de acceder a un elemento
que no ha sido previamente interpretado.
En lenguaje plano,
significa que una petición particular no fue peligrosa realmente.

Finalmente, corremos ente código para cada archivo +PHP+
en la raíz del servidor +bWAPP+.
La salida que obtenemos es muy larga
(ver el link:results.txt[reporte completo])
Aquí una parte de ella:

----
In file sqli_4.php, line 131, col 17:
$sql = "SELECT * FROM movies WHERE title = '" . sqli($title) . "'";
 Injectable variable $title. Other ocurrences:
  L129 $title = $_REQUEST["title"];
  L131 $sql = "SELECT * FROM movies WHERE title = '" . sqli($title) . "'";
Found 1 SQL injection in bWAPP/sqli_4.php.
...
In file sqli_1.php, line 143, col 13:
$sql = "SELECT * FROM movies WHERE title LIKE '%" . sqli($title) . "%'";
 Injectable variable $title. Other ocurrences:
  L141 $title = $_GET["title"];
  L143 $sql = "SELECT * FROM movies WHERE title LIKE '%" . sqli($title) . "%'";
Found 1 SQL injection in bWAPP/sqli_1.php.
...
In file xss_stored_1.php, line 253, col 31:
$sql = "SELECT * FROM blog WHERE owner = '" . $_SESSION["login"] . "'";
 No dangerous concatenations in this query.
...
Total SQL injections found: 56
----

Esas son muchas inyecciones SQL!
Sin embargo, no esperamos que cada una de ellas
sean inyecciones +SQL+ reales (falsos positivos)
y puede que algunos archivos contengan inyecciones +SQL+ efectivas
que han escapado de nuestro escrutinio.

Para encontrar la tasa de vulnerabilidades descubiertas
respecto a las existentes (rendimiento)
utilizamos el link:http://www.mmebvba.com/sites/default/files/downloads/bWAPP_sample_report.pdf[reporte Netsparker de bWAPP]
como referencia.
Este reporte lista +57+ inyecciones +SQL+.
Comparado a nuestras +56+, eso nos da un rendimiento del +98%+.
Nada mal para nuestro sencillo intérprete.
Por lo tanto las fugas, es decir,
la tasa de las vulnerabilidades no encontradas sobre el total existente
es +2%+ en este caso.

Estos números deben ser tomados con cautela,
debido a que algunas de estas vulnerabilidades
pueden ser consideradas +XSS+ o +CSRF+ dependiendo de la fuente.
A pesar de ello, nuestro criterio es claro:
todas las vulnerabilidades que encontramos
son peticiones +SQL+ con concatenaciones,
y todas ellas pueden ser inyectadas,
ya sea de forma fácil o difícil.

Por supuesto, es probable que existan algunos falsos positivos.
Sin embargo, dado el diseño del intérprete,
y revisando la salida del +script+
vemos que sólo las concatenaciones realmente peligrosas son reportadas.
Algunas de estas pueden ser protegidas
a través de buenos desinfectantes de entradas,
como +mysqli_real_escape_+ pero ninguna es a prueba de todo.

Así, podemos decir con una confianza estadística del +95%+
que nuestro +pyparsing+ reporta:

[quote]
Cero falsos positivos.

== Referencias

* McGuire, Paul (2008). 'Getting started with pyparsing'. O'Reilly shortcuts.

== Apéndice: Intérprete SQLi completo

Descargue  el link:./sqli-parser.py[código]
y los link:./test-cases.lst[casos de prueba].
Correr desde la raíz del servidor +PHP+ probado.

.+sqli_parser.py+
[source,python,numbered]
----
include::/web/content/blog-en/pars-orationis-secura/sqli-parser.py[]
----
