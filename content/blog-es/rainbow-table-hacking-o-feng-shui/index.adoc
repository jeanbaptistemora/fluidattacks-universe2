:slug: rainbow-table-hacking-o-feng-shui/
:date: 2018-11-08
:category: ataques
:subtitle: Haciendo escalable la fuerza bruta
:tags: seguridad, criptografía, password
:image: cover.png
:alt: generando cadenas text-hash
:description: Recuperando contraseñas a partir de un hash usando Rainbow Tables, conoce el fundamento teórico de la técnica, aprende que es una Raimbow Chain, observa un ejercicio practico de cracking usando RainbowCrack, y aprende los mecanismos para prevenir y remediar este tipo de ataques.
:keywords: Contraseñas, Seguridad, Cracking, Fuerza Bruta, Rainbow Tables, RainbowCrack.
:author: Kevin Amado
:writer: kamadoatfluid
:name: Kevin Amado
:about1: Ingeniero Civil
:about2: "En la vida, no hay nada que temer, solo hay que comprender" Marie Curie

= Rainbow Table, hacking o feng-shui?

Tal vez te estes imaginando que una Rainbow Table es una pequeña y colorida
tabla de madera que pones en la sala de espera de tu casa para limpiar las
energías y montarte en la corriente _feng shui_.
Pero hoy no te voy a hablar de esto.

Las Rainbow Tables de las que te voy a hablar son usadas diariamente por
los hackers para descifrar tus contraseñas y debes estar al tanto de la
metodología para protegerte de ellas.

== Un poquito de contexto

Una de las maneras en que se almacenan las contraseñas de los usuarios
en una base de datos consiste en aplicar una función hash a la contraseña.
Por si no lo sabes, una función hash consiste en transformar la contraseña
en una serie de letras y números, (un hash), lo que la vuelve ilegible.
La principal propiedad de estas funciones es que solo trabajan en un sentido,
es decir, una función hash transforma tu contraseña en un hash, pero teniendo
el hash, no es fácil recuperar la contraseña.

=== Veamos un ejemplo:

Supongamos, por simplicidad, que tenemos una base de datos con dos usuarios
_fluidattacks_ y _lectordelblog_, cuyas contraseñas son
respectivamente _123456_ y _Str0ngP4%%w0rddd_. Y asumamos que las contraseñas
son almacenadas como un hash SHA256.

Por tanto, la base de datos del servidor sera, mas o menos, de esta manera:

.Base de datos, servidor de dos usuarios
|====
|usuario|contraseña
|fluidattacks|8D969EEF6ECAD3C29A3A629280E686CF0C3F5D5A86AFF3CA12020C923ADC6C92
|lectordelblog|52CA3EF0AD01E8233EA585895CEF41944B2C3B2A671972A1D10D62907E2A8CE1
|====

Ahora supongamos que como hackers, tenemos acceso a esta base de datos, y
queremos encontrar la contraseña original.
Dado que no hay una forma de transformar un hash de SHA256 en la cadena
original directamente, nuestra única esperanza es probar varias contraseñas,
obtener el hash, y con suerte encontrar uno que coincida:

.Intentando encontrar la contraseña probando las mas comunes
|====
|intento de contraseña|SHA256
|contraseña|E7CF3EF4F17C3999A94F2C6F612E8A888E5B1026878E4E19398B23BD38EC221A
|qwerty|65E84BE33532FB784C48129675F9EFF3A682B27168C0EA744B2CF58EE02337C5
|[red]#123456#
|[red]#8D969EEF6ECAD3C29A3A629280E686CF0C3F5D5A86AFF3CA12020C923ADC6C92#
|letmein|1C8BFE8F801D79745C4631D09FFF36C82AA37FC4CCE4FC946683D7B336B63032
|admin|8C6976E5B5410415BDE908BD4DEE15DFB167A9C873FC4BB8A81F6F2AB448A918
|welcome|280D44AB1E9F79B5CCE2DD4F58F5FE91F0FBACDAC9F7447DFFC318CEB79F2D02
|====

Como vemos, el SHA256 de la contraseña 123456 coincide con el que obtuvimos
de nuestra base de datos, por ende, esta es la correspondiente al usuario
_fluidattacks_, y ahora podemos usarla para autenticarnos en su nombre.

== Pero, ¡el método anterior esta bueno! ¿Por que Rainbow Tables?

El método que vimos anteriormente es conocido como
link:https://es.wikipedia.org/wiki/Ataque_de_fuerza_bruta[Fuerza Bruta].
Y es lento en muchos casos reales.

Otro método es escribir una tabla con todas las combinaciones y hash
posibles. A esto se le conoce como
link:https://es.wikipedia.org/wiki/Lookup_table[Tabla de búsqueda].
Sin embargo, esto puede ocupar mucho espacio en disco.

A pesar de que el almacenamiento en disco es económico.
Escribir una tabla con todas las posibles combinaciones para una contraseña
larga, alfa-numérica y con símbolos puede costar peta-bytes de espacio.

Rainbow Tables es un método que nos permite crear una tabla con posibles
combinaciones de contraseñas, ocupando menos espacio en
disco que el método de la tabla de búsqueda, y encontrando la contraseña
usando menos tiempo que el método de fuerza bruta.

== Fundamento teórico de las Rainbow Tables

Si te fijas para encontrar una contraseña numérica de ocho caracteres por medio
de una _tabla de búsqueda_ hubiésemos necesitado almacenar 100'000'000 de
filas, cada una con una combinación posible, y su hash correspondiente.

Gracias a las Rainbow Tables, podemos hacerlo almacenando solamente 1'000.000 de
filas, cien veces menos.

=== ¿En donde esta el truco?

El truco esta en generar _Cadenas Arcoíris_ (Rainbow Chains, en ingles), y
almacenarlas.

* Para esto, necesitamos tres cosas:
. un valor inicial.
. una función de reducción.
. una longitud de cadena.

El valor inicial puede ser cualquier texto plano, como nosotros queremos
generar una Rainbow Table para encontrar contraseñas numéricas de ocho
caracteres, un buen valor inicial podría ser 12345678.

La función de reducción es, en esencia, una función que te transforma un hash,
en una contraseña cualquiera, para este ejemplo usemos la siguiente función de
reducción:

.Función de reduccion
[source, gherkin, linenums]
----
Feature: Reduction Function
  Scenario: Generate a numeric password of length eight from a hash
    Given I have a hash
    Then I take the first eight numbers in this hash
    And I return this value as the numeric password
----

La longitud de cadena, es un parámetro definido por el usuario, en este caso,
por simplicidad, usaremos tres.

=== Generando una Cadena

Una cadena se forma a partir de eslabones, cada eslabón se forma a partir de
tres pasos:

1. toma el valor inicial
2. aplica la función de hash sobre resultado del paso 1
3. aplica la función de reducción sobre el resultado del paso 2

.Eslabón de una Cadena Arcoíris
|====
|valor inicial|función hash MD5|función de reducción
|12345678|25d55ad283aa400af464c76d713c07ad|25552834
|====

Para formar una cadena de longitud tres, completemos tres eslabones:

.Ejemplo de Cadena Arcoiris
|====
|valor inicial|función hash MD5|función de reducción
|12345678|25d55ad283aa400af464c76d713c07ad|25552834
|25552834|49fb0035549c59b3213d2affdf524ef0|49003554
|49003554|5a8a25c1490f5b4f48a0dcde7686d028|58251490
|====

Finalmente en nuestra Rainbow Table almacenaremos como una fila el valor
inicial, y el valor final de cada _Cadena Arcoíris_.
Por tanto, en lugar de almacenar dos valores que representan un par
contraseña-hash como en una _Tabla de Búsqueda_ , en una Rainbow
Table estamos almacenando dos valores, que representan tantos pares
contraseña-hash, como eslabones tenia la cadena antes de almacenarla.

.Codificando nuestra Rainbow Chain en una Rainbow Table
|====
|valor inicial|valor final
|12345678|58251490
|====

Si por algún motivo nos fuese dado el hash MD5

|====
|5a8a25c1490f5b4f48a0dcde7686d028
|====

El procedimiento para encontrar la contraseña es el siguiente:

1 - toma el hash y aplica la función de reducción

|====
|hash|aplicando función de reducción
|5a8a25c1490f5b4f48a0dcde7686d028|58251490
|====

2 - busca en la Rainbow Table si algún valor final coincide con el resultado
del paso 1

|====
|valor inicial|función hash MD5|función de reducción
|12345678|25d55ad283aa400af464c76d713c07ad|25552834
|25552834|49fb0035549c59b3213d2affdf524ef0|49003554
|[green]#49003554#|[red]#5a8a25c1490f5b4f48a0dcde7686d028#|58251490
|====

dado que 58251490 es un valor final de la Rainbow Table, entonces ahora seguimos
la cadena desde el comienzo hasta encontrar la contraseña que produce el hash
que buscamos. Por tanto la contraseña es _49003554_

== Rainbow Tables en Acción

Rompamos un contraseña numérica de ocho caracteres proveniente de la función
hash SHA256.

Para esto vamos a usar
[button]#link:https://project-rainbowcrack.com/index.htm[RainbowCrack]#
el cual esta disponible en Linux y Windows, y vamos a intentar encontrar la
contraseña que produce como hash:

|====
|C639FB319E252D72D4C74A96A20F25EA730D4134C79AFB78CBAF6B70A5882BDC
|====

Abramos una terminal de Linux y generemos una Rainbow Table con 1'000.000 de
entradas:

.Comando
[source, bash, linenums]
----
$ ./rtgen sha256 numeric 8 8 0 100 1000000 1
----

Tras 30 segundos nuestra Rainbow Table esta lista.
Para agilizar la búsqueda, ordenemos esta tabla:

.Comando
[source, bash, linenums]
----
$ ./rtsort .
----

Y finalmente procedamos a obtener la contraseña

.Comando
[source, bash, linenums]
----
$ ./rcrack . -h C639FB319E252D72D4C74A96A20F25EA730D4134C79AFB78CBAF6B70A5882BDC

statistics
plaintext found:                             1 of 1
total time:                                  0.02 s
performance of chain traverse:               0.70 million/s

result
c639fb319e252d72d4c74a96a20f25ea730d4134c79afb78cbaf6b70a5882bdc  84736181
----

En donde observamos que la contraseña es [green]#84736181#

== Como protejo mi base de datos contra este tipo de ataques?

No uses funciones de hash que son conocidas como vulnerables, dentro de estas se
encuentran LN, MD5, SHA1, entre otras.

Inclusive, en este
[button]#link:https://project-rainbowcrack.com/table.htm[enlace]#
encontraras una lista de Rainbow Tables pre-calculadas que permiten reversar el
99% de contraseñas alfanuméricas, y con símbolos que fueron _protegidas_ con
funciones de hash vulnerables.

Prefiere siempre las funciones SHA-2 y SHA-3.

=== Esta sin sal

Otro mecanismo de protección ante este tipo de ataques es utilizar "sal",
esto es, antes de calcular el hash, agrega bytes _aleatorios_ al password:

.Proceso de almacenamiento de contraseñas
|====
|Usuario |Sal |Contraseña |Texto final |SHA256 (Texto final)
|fluidattacks |82e072fdb43d4c27be59963bfe8f7b45 |123456|
12345682e072fdb43d4c27be59963bfe8f7b45 |
88CE9422C363D8A2F1CFCDE2922A8BD212C346890D37845408765CA1D6DF28CB
|fluidattacks2 |8f84b930ea66118eaf89fad77297948e |123456|
1234568f84b930ea66118eaf89fad77297948e |
2C1D67A9361F9AF92C025357AA4318664109283638283AA3BD4670A8A19073D4
|====

Como ves, dos usuarios con la misma contraseña producen un diferente hash.
Como hemos usado una sal de 128 bits,
necesitaríamos pre-calcular aproxidamamente 3e38
Rainbow Tables para encontrar la contraseña, una por cada posible valor de sal.

== Finalmente

Espero que este articulo haya sido nutritivo, y nos vemos en otra entrada
del blog!

== Referencias

. [[r1]] Philippe Oechslin (2018).
'Making a Faster Cryptanalytic Time-Memory Trade-Off'.
link:https://passwordsgenerator.net/sha256-hash-generator/[PDF].
Laboratoire de Securite et de Cryptographie (LASEC)

. [[r2]] RainbowCrack project - Official Website (2018).
'Hash Cracking with Rainbow Tables'.
link:https://project-rainbowcrack.com/crack.htm[Website].

. [[r3]] RainbowCrack project - Official Website (2018).
'Rainbow Table Generation and Sort'.
link:https://project-rainbowcrack.com/generate.htm[Website].

. [[r4]] PasswordsGenerator.net (2018).
'SHA256 Hash Generator'.
link:https://passwordsgenerator.net/sha256-hash-generator/[Website].
