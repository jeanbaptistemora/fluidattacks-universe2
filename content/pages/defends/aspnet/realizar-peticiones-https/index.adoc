:slug: defends/aspnet/realizar-peticiones-https/
:category: aspnet
:description: Nuestros ethical hackers explican cómo evitar vulnerabilidades de seguridad mediante la programación segura en ASP.NET al utilizar protocolos seguros en aplicaciones web. El protocolo HTTPS cifra la comunicación entre el servidor y el cliente, evitando que sea espiada o alterada.
:keywords: ASP.NET, Seguridad, Peticiones, HTTPS, Protocolo, SSL/TLS
:defends: yes

= Realizar Peticiones Seguras con HTTPS

== Necesidad

Realizar peticiones seguras usando +HTTPS+ en +ASP.NET+.

== Contexto

A continuación se describen las circunstancias
bajo las cuales la siguiente solución tiene sentido:

. Se está desarrollando una aplicación en +ASP.NET+.
. Se cuenta con un servidor corriendo +HTTPS+ con certificados válidos.

== Solución

Cuando creamos una aplicación web,
muy seguramente vamos a necesitar de un sistema de tipo +petición-respuesta+
para intercambiar información entre nuestro servidor y el cliente.
Para realizar esta comunicación
es común utilizar protocolos como el +HTTP+,
sin embargo este último protocolo es inseguro,
debido a que la información enviada no es protegida ni cifrada,
de modo que puede ser espiada o alterada por un usuario malicioso.

Para solucionar este problema, se creó el protocolo +HTTPS+
(_Hypertext Transfer Protocol Secure_),
el cual combina los protocolos +HTTP+ y +SSL/TLS+
para establecer una comunicación segura entre un cliente y el servidor.
La principal diferencia del protocolo +HTTPS+ respecto al +HTTP+
es el uso de una conexión cifrada
que solo es visible por el servidor y el cliente,
además del uso de certificados +SSL+ para identificar sitios de confianza.
Por esta razón es altamente recomendable utilizar peticiones +HTTPS+
en las aplicaciones web.
A continuación mostraremos cómo implementar este protocolo en +ASP.NET+

. Esta solución muestra el uso de peticiones +HTTPS+
usando el método +HttpWebRequest+.
Note que para que la conexión sea exitosa,
es importante que el servidor cuente con certificados
firmados por un tercero reconocido.
De lo contrario,
esta solución puede generar la excepción +System.Net.WebException+.
Para iniciar se requieren los siguientes espacios de nombres.
+
.SecureRequest.cs
[source, csharp, linenums]
----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;
using System.Net;

namespace ConsoleApplication1 {
  class Program {
    static void Main(string[] args) {
----

. Se define cuales son los datos +POST+ que se van a enviar
y el servidor al cual se le hace la solicitud.
+
[source, csharp, linenums]
----
    string post_data = "foo=bar&baz=oof";
    string uri = "https://www.verisign.com/";
----

. Se configura la solicitud haciendo uso del +API+.
+
[source, csharp, linenums]
----
    HttpWebRequest request = (HttpWebRequest)
    WebRequest.Create(uri);
    request.KeepAlive = false;
    request.ProtocolVersion = HttpVersion.Version10;
    request.Method = "POST";
----

. Se configuran los datos post y se prepara la solicitud:
+
[source, csharp, linenums]
----
    byte[] postBytes = Encoding.ASCII.GetBytes(post_data);
    request.ContentType = "application/x-www-form-urlencoded";
    request.ContentLength = postBytes.Length;
    Stream requestStream = request.GetRequestStream();
----

.  Se envía la solicitud y se cierra la conexión.
+
[source, csharp, linenums]
----
    requestStream.Write(postBytes, 0, postBytes.Length);
    requestStream.Close();
----

. Finalmente, se reciben los datos y se imprimen en pantalla.
+
[source, csharp, linenums]
----
    HttpWebResponse response = (HttpWebResponse)request.GetResponse();
    Console.WriteLine(new StreamReader(response.GetResponseStream()).ReadToEnd());
    Console.WriteLine(response.StatusCode);
    }
  }
}
----

. No se recomienda el uso de certificados autofirmados
o el uso de terceros no confiables,
si usted decide tomar ese riesgo, la forma de adaptar esta solución es:
+
* Implementar una subclase de +ICertificatePolicy+.
* Forzar la validación de los certificados a verdadera.
+
.MyPolicy.cs
[source, csharp, linenums]
----
using System.Security.Cryptography.X509Certificates;
using System.Net;

public class MyPolicy : ICertificatePolicy {
  public bool CheckValidationResult(ServicePoint srvPoint,
    X509Certificate certificate, WebRequest request,
    int certificateProblem) {
      return true;
    }
}
----

. Una vez se ha hecho esto,
simplemente se debe asignar esta política
antes de enviar las peticiones.
+
.SecureRequest.cs
[source, csharp, linenums]
----
System.Net.ServicePointManager.CertificatePolicy = new MyPolicy();
----

. El compilador emitirá advertencias de obsolescencia,
de nuevo, sugerimos no usar este enfoque excepto para propósitos de pruebas.

== Descargas

Puedes descargar el código fuente pulsando en el siguiente enlace:

* [button]#link:src/secure-request.cs[SecureRequest.cs]#
* [button]#link:src/mypolicy.cs[MyPolicy.cs]#

== Referencias

. [[r1]] link:https://docs.microsoft.com/en-us/dotnet/api/system.net.httpwebrequest?redirectedfrom=MSDN&view=netframework-4.7.2[Microsoft .NET HttpWebRequest Class].

. [[r2]] link:../../../rules/181[REQ.181 Transmitir por medio de protocolos seguros].
