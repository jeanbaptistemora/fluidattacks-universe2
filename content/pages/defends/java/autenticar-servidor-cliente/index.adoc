:slug: defends/java/autenticar-servidor-cliente/
:category: java
:description: Nuestros ethical hackers explican cómo evitar vulnerabilidades de seguridad mediante la configuración segura en Java al autenticar el servidor para clientes sin un certificado digital. Ésto resulta útil cuando no es práctico o implementable la generación de certificados en el lado del cliente.
:keywords: Java, Seguridad, Autenticar, Servidor, Cliente, Certificado.
:defends: yes

= Autenticar Servidor para Clientes Sin Certificado

== Necesidad

Autenticar servidor de red para clientes que no poseen un certificado digital.

== Contexto

A continuación se describen las circunstancias
bajo las cuales la siguiente solución tiene sentido:

. Se está desarrollando una aplicación en +Java+.
. No es práctico o implementable la generación de certificados digitales
del lado del cliente.

== Solución

Los siguientes pasos describen la manera
en que un cliente se autentica ante un servidor:

. Las conexiones +SSL+ soportan autenticación de una y dos vías.

. En la autenticación de una vía,
el servidor presenta un certificado digital al cliente
para probar su identidad.
El cliente realiza dos pasos para validar el certificado:
* Verifica que el certificado digital fue firmado por una autoridad confiable.
* Valida que el nombre de +host+ en el certificado
coincide con el nombre del servidor

. Si las validaciones son exitosas, se establece la conexión +SSL+.

. Para poder soportar de manera adecuada
los requerimientos de la +PKI+ en las conexiones +SSL+,
es necesario contar con un sistema
de almacenamiento de material criptográfico.

. La clase +Keystore+ permite administrar esta información.
Como tal, soporta:
* Claves privadas.
* Clave secreta (para criptografía simétrica).
* Certificados confiables (para validar la identidad de otras partes).

. En el siguiente código se crea un contenedor de llaves.
+
.keystore.java
[source, java, linenums]
----
String KEYSTORE = "cacerts";
// ¿dónde tenemos las claves?
KeyStore keystore = KeyStore.getInstance("JKS");
keystore.load(new FileInputStream(KEYSTORE), null);
----

. Primero se obtiene una instancia de contenedor de tipo +Java keystore+,
y se carga el archivo para administrar la información.

. La fábrica abstracta de administradores de claves
requiere un tipo de algoritmo a usar.
En este caso usamos certificados +X.509+
que son los apropiados para +SSL+.
Además,inicializamos el administrador con el contenedor de llaves.
+
[source, java, linenums]
----
// ¿quién nos las va a administrar?
KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
kmf.init(keystore, null);
----

. La fábrica abstracta de administradores de confianza
crea objetos que permiten validar
la identidad utilizando certificados confiables.
Su inicialización es similar a la de los administradores de claves.
+
[source, java, linenums]
----
// ¿quién nos va a verificar las claves?
TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
tmf.init(keystore);
----

. El paso siguiente es crear una fábrica de fábricas de +sockets+ seguros,
para esto es necesario relacionar los administradores creados previamente.
+
[source, java, linenums]
----
// ¿quién nos va a cifrar la conexión?
ServerSocketFactory ssf = sslc.getServerSocketFactory();
----

. Con la fábrica de +sockets+ de servidores
se puede crear el servidor que va a atender las conexiones seguras.
Note que para configurar el comportamiento de una vía
se establece que el cliente no requiere autenticación.
+
[source, java, linenums]
----
SSLServerSocket server = (SSLServerSocket) ssf.createServerSocket(port);
server.setNeedClientAuth(false);
// recibir conexión
SSLSocket client = (SSLSocket) server.accept();
----

. La clase +SSLServerSocket+ en realidad deriva de +Socket+,
por lo que la comunicación puede hacerse como un +socket+ convencional.
+
[source, java, linenums]
----
// escribir
BufferedOutputStream outputStream = new BufferedOutputStream(client.getOutputStream());
outputStream.write("Este es el mensaje enviado".getBytes());
outputStream.flush();
System.out.println("Servidor: mensaje enviado.");
// cerrar
client.close();
server.close();
----

. Es importante aclarar que el servidor y el cliente
difieren en la forma que usan el +socket+.
Es decir, los clientes invocan objetos de tipo +SSLSocket+
quién nos va a cifrar la conexión
+
[source, java, linenums]
----
SocketFactory sf = sslc.getSocketFactory();
SSLSocket client = (SSLSocket) sf.createSocket(host, port);
----

. Código del servidor:
+
[source, java, linenums]
----
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.security.KeyStore;
import javax.net.ServerSocketFactory;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLServerSocket;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.TrustManagerFactory;

public class Server {
  public static void main(String[] args) throws Exception {
    int port = 3333;
    String KEYSTORE = "certs";
    char[] KEYSTOREPW = "storepass".toCharArray();
    char[] KEYPW = "keypass".toCharArray();

    // ¿dónde tenemos las claves?

    KeyStore keystore = KeyStore.getInstance("JKS");
    keystore.load(new FileInputStream(KEYSTORE), KEYSTOREPW);

    // ¿quién nos las va a administrar?

    KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
    vkmf.init(keystore, KEYPW);

    // ¿quién nos va a verificar las claves?
    // (no se requiere si no se realiza autenticacion de cliente)

    TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
    tmf.init(keystore);

    // ¿cómo nos van a cifrar la conexión?

    SSLContext sslc = SSLContext.getInstance("SSLv3");
    sslc.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

  // ¿quién nos va a cifrar la conexión?

    ServerSocketFactory ssf = sslc.getServerSocketFactory();
    SSLServerSocket server = (SSLServerSocket) ssf.createServerSocket(port);
    server.setNeedClientAuth(false);

  // recibir conexión

    SSLSocket client = (SSLSocket) server.accept();

  // leer

    BufferedOutputStream outputStream = new BufferedOutputStream(client.getOutputStream());
    outputStream.write("Este es el mensaje enviado".getBytes());
    outputStream.flush();
    System.out.println("Servidor: mensaje enviado.");

  // cerrar

  client.close();
    server.close();
  }
}
----

. Código del cliente:
+
[source, java, linenums]
----
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.security.KeyStore;
import javax.net.SocketFactory;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.TrustManagerFactory;

public class Client
{
 public static void main(String[] args) throws Exception
 {
   String host = "localhost";
   int port = 3333;
   String KEYSTORE = "cacerts";

   // ¿dónde tenemos las claves?

   KeyStore keystore = KeyStore.getInstance("JKS");
   keystore.load(new FileInputStream(KEYSTORE), null);

   // ¿quién nos las va a administrar?

   KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
   kmf.init(keystore, null);

   // ¿quién nos va a verificar las claves?

   TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
   tmf.init(keystore);

   // ¿cómo nos van a cifrar la conexion?

   SSLContext sslc = SSLContext.getInstance("SSLv3");
   sslc.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

   // ¿quién nos va a cifrar la conexion?

   SocketFactory sf = sslc.getSocketFactory();
   SSLSocket client = (SSLSocket) sf.createSocket(host, port);

   // leer

   BufferedInputStream inputStream = new BufferedInputStream(client.getInputStream());
   byte[] message = new byte[64];
   inputStream.read(message);
   System.out.println("Cliente: mensaje: " + new String(message));

   // cerrar

   client.close();
  }
}
----

== Descargas

Puedes descargar el código fuente
pulsando en los siguientes enlaces:

[button]#link:src/client.java[client.java]#
Código de autenticación del lado cliente.

[button]#link:src/server.java[server.java]#
Código de autenticación del lado servidor.

== Referencias

. [[r1]] link:https://docs.oracle.com/javase/1.5.0/docs/api/java/security/KeyStore.html[Class KeyStore]
. [[r2]] link:https://docs.oracle.com/javase/6/docs/api/javax/net/ssl/KeyManagerFactory.html[Class KeyManagerFactory]
. [[r3]] link:https://docs.oracle.com/javase/7/docs/api/javax/net/ServerSocketFactory.html[Class ServerSocketFactory]
. [[r4]] link:http://www.java2s.com/Code/Java/Network-Protocol/SSL-Server-Socket.htm[SSL Server Socket]
. [[r5]] link:../../../rules/088/[REQ.088 Requerir certificados de cliente]
