:slug: defends/java/generar-sha2/
:category: java
:description: Nuestros ethical hackers explican en que consiste el algoritmo de resumen criptográfico SHA2, el cual es una evolución de SHA1. Además, explican mediante un ejemplo la manera de utilizarlo en Java con el fin de generar textos cifrados de manera segura.
:keywords: Java, SHA2, HASH, Seguridad, Criptografía, Cifrado.
:defends: yes

= Generar Resumen SHA2 Usando Derivación de Claves

== Necesidad

Generar resumen +SHA2+ usando derivación de claves +salt+ en +Java+.

== Contexto

A continuación se describen las circunstancias
bajo las cuales la siguiente solución tiene sentido:

. Se dispone de un compilador estándar de Java.

== Solución

+SHA2+ son un conjunto de funciones +hash+ criptográficas,
es decir, un conjunto de algoritmos que transforman
una determinada cantidad de elementos de datos,
como puede ser un fichero de texto, una imagen o, incluso,
un archivo ejecutable en un único valor de longitud fija o +hash+.
El valor +hash+ calculado puede ser utilizado
para la verificación de la integridad de copias de un dato original
sin la necesidad de proveer el dato original.
Esta irreversibilidad significa que un valor +hash+
puede ser libremente distribuido o almacenado,
ya que sólo se utiliza para fines de comparación.

Por otro lado, +SHA2+ es la evolución de +SHA1+
y por tanto incluye un significativo número de mejoras,
además de que está conformado por cuatro funciones +hash+
de +224+, +256+, +384+ ó +512+ +bits+.

. Entonces, en +Java+,
para utilizar el algoritmo de resumen criptográfico +SHA2+
se debe entonces importar la clase +java.security.MessageDigest+.
También se debe incluir +SecureRandom+
para generar la semilla aleatoria
y dos excepciones que podrían lanzarse durante la ejecución.
+
.cli.java
[source, java, linenums]
----
import java.security.MessageDigest;
import javax.xml.bind.DatatypeConverter;
import java.security.SecureRandom;
import java.security.NoSuchAlgorithmException;
import java.io.UnsupportedEncodingException;

class CLI
{
----

. Por otra parte, es necesario utilizar
el método estático +getInstance+ de la clase +MessageDigest+
pasando como parámetro el nombre del algoritmo a ser empleado.
+
[source, java, linenums]
----
public static void main(String[] args) throws Exception {
  String data = "hola";
  MessageDigest md = MessageDigest.getInstance("SHA-256");
----

. Existen tres variantes de +SHA2+ que pueden ser utilizados:
+SHA256+, +SHA384+ y +SHA512+.

. Para obtener el resumen criptográfico
del contenido de la variable +data+,
se debe invocar el método +digest+ de la clase +MessageDigest+.
+
[source, java, linenums]
----
//byte[] seed = generateSeed();
//md.update(seed);
byte[] digest = md.digest(data.getBytes("UTF-8"));
----

. A continuación, se imprime los resultados obtenidos
tanto cuando se cifra como cuando se descifra el texto.
+
[source, java, linenums]
----
  System.out.println("data: " + data);
  //String encodedSeedBase64 = DatatypeConverter.printBase64Binary(seed);
  //System.out.println("Seed: " + encodedSeedBase64);
  String encodedDigestBase64 = DatatypeConverter.printBase64Binary(digest);
  System.out.println("Digest (base 64): " + encodedDigestBase64);
}
----

. Finalmente, luego de cerrar el método +main+,
se define el método encargado de generar semillas aleatorias.
Una vez hecho eso, se debe cerrar la clase +CLI+.
+
[source, java, linenums]
----
  private static byte[] generateSeed() {
    byte[] seed = new byte[32];
    SecureRandom random = new SecureRandom();
    random.nextBytes(seed);
   return seed;
 }
}
----

. Se compila el programa
+
.compilacion.shell
[source, shell, linenums]
----
javac CLI.java
----

. Luego, se ejecuta el programa dos veces
con el fin de comprobar que la salida
siempre es la misma para una misma entrada.
+
[source, shell, linenums]
----
java CLI
Data: hola
Digest (base 64): siHZ27CDp/M0KNfCo8MZiuklYU1wIQ4ocWzKp81N23k=

java CLI
Data: hola
Digest (base 64): siHZ27CDp/M0KNfCo8MZiuklYU1wIQ4ocWzKp81N23k=
----

. Si se incluye la semilla
generada aleatoriamente mediante +md.update(seed)+,
se observa que se generan diferentes salidas para una misma entrada.
Para observar este comportamiento,
se eliminan todos los comentarios del código anterior.
+
[source, shell, linenums]
----
java CLI
Data: hola
Seed: 5l7DBkMxb0jjyO+jXwmsHOsYt2vx/5GER3AQNWHTbXE=
Digest (base 64): HYg2/GhkEzWvUYN0UEl42XAWOtoTC0TA4WX582DOU6M=

java CLI
Data: hola
Seed: sfDHjaw3gVtX7CkTjQlIFLC0XF/3+3a9yTcniY9GLF0=
Digest (base 64): 4WbFDcbS+FQdtAPK1S0t0KTDIBra2vMJstpG/7LNaNo=
----

== Descargas

Puedes descargar el código fuente
pulsando en el siguiente enlace:

[button]#link:src/cli.java[CLI.java]#
Clase CLI.

== Referencias

. [[r1]] link:https://docs.oracle.com/javase/6/docs/api/javax/xml/bind/DatatypeConverter.html[Class DatatypeConverter]
. [[r2]] link:https://wiki.sei.cmu.edu/confluence/display/java/MSC02-J.+Generate+strong+random+numbers[MSC02-J. Generate strong random numbers]
. [[r3]] link:https://www.owasp.org/index.php/Hashing_Java[Hashing Java]
. [[r4]] link:../../../rules/127/[REQ.127 Almacenar contraseña mediante criptografía]
