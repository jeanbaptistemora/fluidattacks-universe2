:slug: security/
:description: This page summarizes all the best practices and technology Fluid Attacks implements in order to keep internal products and customer data secure. It goes from philosophies as having open source code, to particular ciphering algorithms used and internal behavioral policies.
:keywords: Fluid Attacks, Security, Data, Policy, Breach, Best practices
:subtitle: How we keep things secure

= Security

As a security company,
Fluid Attacks is aware of the importance of:

. Having honesty, team work and discipline
  as immovable principles.
  Our full manifest can be found
  [inner]#link:../values/[here]#
. Developing products
  that comply with the highest worldwide
  [inner]#link:../products/rules/[security standards]#.
. Aquiring only
  [inner]#link:../rules/262/[compliant services and products for internal use]#.
. Implementing best security practices within our organization.
. Being completely transparent with our clients,
  especially regarding their data:
  [inner]#link:../rules/315/[how we use it, and what we do to protect it]#.

These concerns,
concieved since the early days of the company,
have allowed us to implement
a big number of measures
throughout the years.
In this page we will mention
the ones that provide the highest
value to our customers in
terms of security.

== 1. Transparency

This section focuses on what we do to keep our client informed
about the status of all our services
and their data.

[OPENSOURCE]
=== 1.1 Open Source

The source code of all our applications
is available to the entire Internet.
There are no backdoors or exposed sensitive data.
The code is transparent and can be reviewed by anyone.
All our source code can be found
link:https://gitlab.com/fluidattacks[here].

Commit history of all repositories:

- link:https://gitlab.com/fluidattacks/web/-/commits/master[Web]
- link:https://gitlab.com/fluidattacks/integrates/-/commits/master[Integrates]
- link:https://gitlab.com/fluidattacks/asserts/-/commits/master[Asserts]
- link:https://gitlab.com/fluidattacks/public/-/commits/master[Public]
- link:https://gitlab.com/fluidattacks/writeups/-/commits/master[Writeups]

=== 1.2 Public incidents

All incidents are reported in our
link:https://community.fluidattacks.com/tag/transparency/[Community Site]
with details like *_what happened_*, *_what we've done_*,
*_what's the impact_* and *_what are we doing to help_*.

=== 1.3 Data leakeage policy

In case Fluid Attacks detects a breach,
emails notyifing the involved parties will be sent.
Emails will contain information on what data was leaked or compromised,
when and for how long (to the extent this information is available).
For a breach that exposes private data for a large number of users,
the public will also be informed via email.

=== 1.4 Status page

We continuously monitor
[inner]#link:../products/integrates[Integrates]#,
its [inner]#link:../../integrates/api[API]#
and [inner]#link:../[our website]#.
Monitoring checks run
in North America and Europe servers
every minute
for all aplications.
They send HTTP GET requests.
This information is real-time and available on our
link:http://status.fluidattacks.com/[Status Site].


== 2. Confidentiality

This section provides details on what we do
to keep confidential information always protected.

=== 2.1 Encryption at rest

All our applications and services have
industry-standard
[inner]#link:../rules/224/[encryption at rest]#.

- All the sesitive data provided by our clients
  (Repository access keys, VPN credentials, etc)
  is ciphered using a key management system KMS
  symmetric algorithm
  based on Advanced Encryption Standard (AES)
  in Galois Counter Mode (GCM)
  with
  [inner]#link:../rules/150/[256-bit]#
  [inner]#link:../rules/145/[private keys]#.
- All our clients repositories are
  stored in private,
  [inner]#link:../rules/185/[AES256 ciphered]#
  redundant datacenters.
- Forces exploits are stored encrypted using AES256 keys.
- All
  [inner]#link:../products/integrates[Integrates]#
  data is stored in a AES256 encrypted database.
- All our products use our KMS
  for both development and production secrets.
- All our Windows laptops
  have their hard drives encrypted
  using Bitlocker.
  Adherence to this policy is continuously checked
  by a domain controller.
- All our Linux laptos
  have their hard drives encrypted
  from bootloader using LUKS.

=== 2.2 Encryption in transit

All our applications and services have
industry-standard
[inner]#link:../rules/224/[encryption in transit]#.

- The [inner]#link:../../[Fluid Attacks]# domain
  uses the latest
  [inner]#link:../rules/181/[TLSv1.3]#
  cryptographic protocol for maximum in transit protection.
- [inner]#link:../products/integrates[Integrates]#'s
  database uses TLSv1.2 for in transit protection.
- We possess fully dedicated network channels with some of our biggest clients,
  allowing us to isolate all unwanted traffic. This is especially useful
  for running secure dynamic application hacking.
- For the rest of our clients, we use fully encrypted VPNs.
- <<EPH, Ephemeral environments>>
  always bring a digital certificate,
  validated with ACME protocol and
  [inner]#link:../rules/092/[not self-signed]#.

=== 2.3 We hack ourselves

We have full-time projects focused on hacking our own software.
To us, seting an example of secure software is essential,
that is why today,
our entire technological stack goes through a
[inner]#link:../services/continuous-hacking[Continuous Hacking]#
process.

Aditionally, all our development projects run
<<CI, Continuous Integration>>
pipelines,
Including Forces exploits and strict linters
to ensure that
[inner]#link:../rules/155/[no known vulnerabilities]#
are released to production.

=== 2.4 All our hired personnel must accept a NDA

Everyone within our company knows
how important it is to keep our
clients's information secure.
We enforce this by requiring
all our new employees to sign a
Non disclosure agreement.

=== 2.5 No physical keys to our offices

All our offices have digital locks.
Employees have their own password to open the doors.
All successful and failed access attempts are logged.

=== 2.6 We only hire directly

All our employees have indefinite time contracts
directly with the company.
Due to the nature of our business, we never
hire through contractors, freelance or any
other third parties.

== 3. Authentication

Authentication refers to the process
of validating your identity within a service or platform.
In this context,
we talk about our own services
and other third party services we use.

=== 3.1 For Clients

[inner]#link:../products/integrates[Integrates]#
only uses
link:https://en.wikipedia.org/wiki/Single_sign-on[SSO]
with Google and Microsoft Accounts.
link:https://oauth.net/2/[Oauth2] protocol is used.
Such protocol only accepts login attempts from trusted URLs
and has industry-standard 2048 bytes access tokens.
We do not store any account passwords.
The only personal information we store of our clients is:

- Full name (Provided by Google or Microsoft).
- Company and cellphone (Only if shared, user can decide).

It is also worth noting that once users lose their
corporate email,
[inner]#link:../rules/114/[they also lose access]#
to their
[inner]#link:../products/integrates[Integrates]#
account. Allowing clients to
[inner]#link:../rules/034/[easily manage]#
who has and who does not have access to
their projects.

=== 3.2 Internal

==== 3.2.1 Centralized authentication

We use a centralized authentication platform (IAM),
that allows us to manage all the applications
we internally use from just one place. Our employees do
not know any of the passwords of the managed applications,
they only know their own IAM passphrase.
Once they log in to IAM,
they can access applications
[inner]#link:../rules/096/[assigned to them]#.

Some of our IAM specifications and requirements are:

- [inner]#link:../rules/132/[Passphrases instead of passwords]#
  (More information [inner]#link:../blog/requiem-password/[here]#).
- [inner]#link:../rules/130/[Passphrases expire every 30 days]#.
- Previous passphrases can only be reused after a
  [inner]#link:../rules/129/[24 reset cycle]#.
- [inner]#link:../rules/328/[Multi-factor authentication]#
  from a mobile device must be set.
- Our MFA uses
  [inner]#link:../rules/153/[OOB]#,
  which is a mechanism that transports all the MFA data
  through a different channel than the application's channel itself.
  Text messages and emails are examples of OBB.
  It reduces risk in case a comunnication channel becomes compromised.
- We use both
  link:https://en.wikipedia.org/wiki/Security_Assertion_Markup_Language[SAML]
  and
  link:https://oauth.net/2/[Oauth2]
  for logging in.
  These two protocols allow us to login to external applications
  by only having our IAM active account.
  No passwords or users are needed.
- In case a mobile phone supports
  [inner]#link:../rules/231/[biometric authentication]#,
  our IAM enforces its usage.
- All successful sessions have a duration of 9 hours.

==== 3.2.2 GPG signature for repository commits

In order to avoid identity hijacking,
all our source code repositories
require developers to use a
link:https://en.wikipedia.org/wiki/GNU_Privacy_Guard[GPG digital signature]
that verifies the developer's identity on the Internet.
Signatures can be found on the repository commit histories linked in the
<<OPENSOURCE, Open Source section>>.

== 4. Authorization

Authorization refers to the ability of giving
users within an application,
the
[inner]#link:../rules/186/[minimum privileges]#
they need to do
their work. No users should have the ability
to do what they should not.

=== 4.1 For Clients

[inner]#link:../products/integrates[Integrates]#
has a set of
[inner]#link:../rules/096/[roles]#
that are necessary on every hacking project.
Once the client decides
which members of its team
should be *_project managers_*,
Fluid Attacks assigns them to such role,
providing them with the
[inner]#link:../rules/035/[ability to assign]#
the
[inner]#link:../rules/186/[minimum required permissions]#
to other members of their team.
Some of the available roles are:
_hacker_, _admin_, _releaser_, _escaper_,
_user_, _project manager_, etc.

=== 4.2 Internal

Every application we use must have user-granular authorization settings
in order to grant minimum-privilege policy at all times.
Some examples are:

- *IAM and KMS:*
  These two tools are widely used within Fluid Attacks.
  They allow us to ensure
  that hackers can only access source code,
  environments, exploits and secrets
  from projects they have access to.
  Access can be easily removed
  should the need arise,
  with no users/passwords leaked.
  These tools also let us keep application
  production secrets hidden from developers
  (Production-Development secrets separation).
- *IAM:*
  It is possible to give application access on a user level.
  Granting us the ability to give employees access
  [inner]#link:../rules/176/[only to what they need]#
  to execute their tasks.
  [inner]#link:../rules/034/[Giving or removing access to applications]#
  is simple, and no users/passwords are leaked.

=== 4.3 Secret rotation

[inner]#link:../rules/130/[Key rotation]#
is of the essence when dealing with
sensitive data. The best way to prevent a key leakage is by
regularily changing it. We continuously rotate:

- *KMS keys:*
  They rotate on a yearly basis or before in case it is needed.
- *JWT Tokens:*
  They rotate on a daily basis.
- *Digital Certificates:*
  They rotate [inner]#link:../rules/089/[every three months]#.
- *IAM passphrases:*
  They rotate every three months.

Rotations are done in two different ways:

- *Automatic rotation:*
  Some secrets are stored in secret vaults.
  They are only accesible by administrators
  and are rotated on a daily basis.
  These secrets include JWT Tokens,
  IAM passphrases and digital certificates.

- *Manual rotation:*
  Some secrets are stored versioned and encrypted
  in git repositories using AES256 symmetric keys.
  They are treated as code,
  meaning that in order to be rotated,
  a <<PR, manual approval>> needs to be done.
  These secrets include KMS keys and
  other application credentials.

=== 4.4 Access revocation

When employees go on vacation or leave the company,
revocating access to the systems and information
they had access to is essential.
In Fluid Attacks we have a two-step process for
access revocation:

  . *Deactivating IAM account:*
    By doing this, users lose
    access to all the company applications and client's
    data they used to have.
    This includes
    Integrates, Forces, mail, etc.
  . *Removing git repository access:*
    Users can no longer see repository confidential information
    like registry images, confidential issues,
    link:https://docs.gitlab.com/ee/user/project/merge_requests/[Merge requests],
    etc.

It is worth noting that ease of access revocation
is fundamental when dealing with sensitive data in an organization,
that is why we have put so much effort
on making this process as simple as possible.

== 5. Privacy

This section talks about our efforts to protect
both Fluid Attacks's and the client's privacy.

=== 5.1 Project pseudonymization

All projects have a pseudonym within our systems,
briging with it advantages like:

- Employees without direct access to the project do not
  know the client's name or any other information
  that can help them
  [inner]#link:../rules/313/[vinculate a project with the client]#.
- Internal analytics charts and other documents
  never use client names, they user their projects pseudonyms.

Generally speaking, only the people who need to know
whose client a project is, do actually know it.

=== 5.2 Secure delivery of sensitive data

What we do to reduce information leakage
when delivering data to the client.

==== 5.2.1 Secure information sharing system

We use an information sharing system with
link:https://en.wikipedia.org/wiki/Data_loss_prevention_software[DLP]
when sending any sensitive information to our clients.
This includes contracts, portfolios and other sensitive documents.

==== 5.2.2 Signed URLs

[inner]#link:../products/integrates[Integrates]#
has the feature of creating signed download URLs
with expiration date when downloading reports,
meaning that links expire
and can only be used
by the user who requested the download.

==== 5.2.3 Passphrase protected reports

All downloaded reports via
[inner]#link:../products/integrates[Integrates]#
have a four-word randomly generated passphrase.
Such passphrase is sent to the email of the
user that requested the download.
This applies for both XLS and PDF formats.

==== 5.2.4 Watermarked reports

All downloaded reports via
[inner]#link:../products/integrates[Integrates]#
come with a watermark in all its pages
specifying that only the individual who
generated such report is allowed to read it.
This is used as a measure to identify
who generated the report in the first place
and discourage its share across other channels
different than
[inner]#link:../products/integrates[Integrates]# itself.

=== 5.3 Email unsusbcribe

In order to be respectful with users
regarding what information they want to recieve,
for all commercial and informative emails,
receptors have the possibility
to stop getting them by clicking on
the *_unsubscribe from this list_* link.
By doing so, their email is placed in a
list of unsubscribed emails
and new emails will no longer be sent to it.

=== 5.4 Transparent cookie usage

Both [inner]#link:../products/integrates[Integrates]#
and [inner]#link:../[Web]#
utilize a
link:https://en.wikipedia.org/wiki/General_Data_Protection_Regulation[GDPR]
module that:

- Informs the user about
  every cookie the site creates.
- Lets users specify
  which ones to allow,
  thus giving them full control
  over what information we're creating
  and manipulating within their browser.

By doing this, we become compliant with
security rules like:

- [inner]#link:../rules/310/[Request user consent]#
- [inner]#link:../rules/312/[Allow user consent revocation]#
- [inner]#link:../rules/315/[Provide processed data information]#

=== 5.5 Data policies

The following policies apply to all the information
provided by a client in a project context.

==== 5.5.1 Data use policy

We are commited to use our clients data
exclusively for vulnerability seeking
in the context of the service we are providing.
No other activities will be executed
over the provided information.

==== 5.5.2 Data retention policy

All the data related to a project
can be deleted from
[inner]#link:../products/integrates[Integrates]#
by a user with a *_project manager_* role.
Once this action is triggered,
a [inner]#link:../rules/317/[deletion window]# of 30 days begins.
Any *_project manager_* can undo the deletion action.
After the 30 days waiting period, the project,
source code, secrets, metadata and any other project related
[inner]#link:../rules/183/[data is completely removed]#
from all our systems.

=== 5.6 OTR Messaging

We use a messaging system with
link:https://en.wikipedia.org/wiki/Off-the-Record_Messaging[OTR]
and
link:https://en.wikipedia.org/wiki/End-to-end_encryption[E2EE]
for communication within the organization.
Also, all chat histories
[inner]#link:../rules/183/[reset on a weekly basis]#
as an extra measure to avoid leaks.

=== 5.7 Employee time tracking software

We use a time tracking system that takes periodical
screnshots from laptop screens when
employees are working. Only managers have access to such
screenshots in case an incident happens. Employees
have control over the software, which means once they
stop working, no screen recording occurs.

=== 5.8 Poligraph tests

We regularily run poligraph tests on all
employees with access to sensitive information.
Tests fully focus on identifying
if an employee disclosed sensitive information
to a third party.
Personal questions are never aksed.

== 6. Non-repudiation

Non-repudiation refers to the capability
of keeping a log of every action
taken in a system.
What was done, who did it and when.
By knowing this,
no one can deny their actions.

We implement this in several ways
depending of the context.

[EAC]
=== 6.1 Everything as code

At Fluid Attacks we try to keep everything we can
versioned in a Git repository.
By doing so, we are capable of having
comprenhensive logs of:

- What was exactly changed
- Who changed it
- When was it changed
- Who approved a change

Currently, we keep the following systems as code:

- link:https://gitlab.com/fluidattacks/integrates/-/commits/master[Integrates]
- link:https://gitlab.com/fluidattacks/asserts/-/commits/master[Asserts]
- link:https://gitlab.com/fluidattacks/web/-/commits/master[Website]
- [inner]#link:../services/continuous-hacking[Continuous Hacking]#
- <<IAC, Infrastructure>>
- General documentation

=== 6.2 Extensive logs

Typical logs are also essential
for a non-repudiation policy to be successful.
Currently, we store logs for:

- *[inner]#link:../products/integrates[Integrates]#'s*
  *logging system:*
  Integrates stores a historic state
  of projects, findings, vulnerabilities
  and other critical components.
  Changes made to these components
  are always tied to a user and a date.
  The historic state never expires.
- *[inner]#link:../products/integrates[Integrates]#'s*
  *error tracking system:*
  It provides real-time logging
  of errors that occur in its production environments.
  It is especially useful for quickly detecting
  new errors and hacking attempts.
  These logs never expire.
- *Redundant datacenters:*
  They store comprehensive logs
  of all our infrastrucutre components.
  Logs here never expire.
- *Forces executions:*
  Every time a client's <<CI, CI pipeline>> runs Forces,
  logs containing information like who ran it,
  vulnerability status and other relevant data
  are uploaded to our datacenters,
  allowing us to always know the current status
  of our client's Forces service.
  These logs never expire.
- *IAM authentication:*
  Our IAM stores logs of
  login attempts made by users,
  accessed applications
  and possible threats.
  Logs here expire after 7 days.
- *Collaboration systems activity:*
  Our collaboration systems like mail, calendar, etc.
  Store comprehensive logs of employee activity,
  spam, phising and malware emails,
  suspicious login attempts,
  and other possible threats.
  Employee activity logs never expire.
  Other security logs expire after 30 days.
- *CI job logs:*
  All our <<CI, CI pipelines>> provide full logging
  of who triggerd them, when,
  and console output.
  These logs never expire.

== 7. Integrity

Integrity refers to the ability
of:

- Avoiding data loss or corruption.
- Having clear definitions
  of all technological components
  within the organization
  and making sure
  such definitions are followed.
- Having a clear developing cycle
  that ensures applications are
  secure and true to their source code.

=== 7.1 Secure emails

The [inner]#link:../../[Fluid Attacks]# domain
has DKIM and SPF protocols enabled.
Aditionally, it has the DMARCv1 protocol
enabled in verbose mode
for running advanced diagnostics.
These protocols help email receptors
to verify if an email comes from a trusted source,
thus helping them to avoid
phising and fake emails.

=== 7.2 Developing for integrity

This section describes everything
we do in our development cycle
in order to reach a high integrity level.

==== 7.2.1 Monorepo

We have a Git repository for each one of our applications.
By taking this approach instead of dividing applications
into smaller repositories, we get:

- *A centralized source of truth:*
  Everything regarding the application
  can be found in a single place.
- *Centralized knowledge:*
  Teams have traversal knowledge of
  the application, as they spend
  their time working in the same
  repository.
- *Standarization:*
  Standarizing a project
  (folder structure, naming conventions, etc)
  is a lot easier when there is only one repo
  where everyone works, as no duplicated
  efforts or repository synchronization is needed.

==== 7.2.2 Everything as code

As mentioned in the
<<EAC, Everything as code previous section>>,
we try to keep everything we can
versioned in a Git repository.
By making the source code the only
variable affecting an application,
application integrity becomes a matter of
keeping a healthy source code.

[IAC]
==== 7.2.3 Infrastructure as code (IaC)

Our entire infrastructure is versioned
in a Git repository written as code.
Such code can be deployed anywhere
and has all the properties of any
other source code,
such as auditability, history,
revert capabilities, etc.

==== 7.2.4 Regenerable infrastrucutre

By having our infrastrucutre written as code,
we can recreate it
in a daily basis.
Regenerating our infrastrcture everyday
brings the following advantages:

- Any injected trojans or malicious scripts are removed.
- Having fresh new servers every 24 hours let us avoid
  availability and performance issues generated by
  memory leaks and not released resources.
- The capability of deploying our infrastructure
  from 0 to production in an automated process.

==== 7.2.5 Immutable infrastructure

The infrastructure code can be audited
and changes can only be made by
[inner]#link:../rules/265/[changing such code]#.
This provides full transparency on
[inner]#link:../rules/046/[what was changed, when and who did it]#.
Also, no administrative protocols like ssh
or administrative accounts are needed.

[#CI]
==== 7.2.6 Continuous Integration

We run an Application Build Process for every change a
developer wants to introduce to the source
code of the application via
link:https://docs.gitlab.com/ee/user/project/merge_requests/[Merge request].
The Application Build Process includes steps like:

- Forces exploits tests
- Linting tests
- Compilation tests
- Unit tests
- End to end tests
- Commit message tests
- Commit deltas tests
- Creation of <<EPH, Ephemeral environment>>
- <<EPH, Ephemeral environment>> tests

By always building and testing everything,
we can guarantee that every change
is compliant with the application's quality standards.

[#PR]
==== 7.2.7 Peer review

We recognize that not all the steps of
a building process can be automatized,
especially some tests.
That is why developers also need
to ask a peer to review their code changes
before their Merge Request can be merged
to production.
Reviewers usually evaluate code quality,
commit message coherence,
and other semantic properties of the change.

==== 7.2.8 Continuous Deployment

In addition to running an automated building process
for every change,
we also run an automated deploying process.
Once a Merge Request is accepted,
an aditional Continuous Deployment pipeline triggers,
automatically deploying a new production version
based on the new source code.

[#EPH]
==== 7.2.9 Ephemeral environments

Instead of having long-term development environments
like *_staging_*,
we use testing environments
that get created during a CI pipeline.
We call them ephemeral environments,
as they only exist in pipeline time.
These environments get created on demand
when a developer triggers a CI pipeline.
They are also written as code,
regenerable and immutable,
allowing us to certify
that a new version of an application
is stable and secure
before it reaches production environments.
Once a change reaches production,
its ephemeral environment
is destroyed forever.

==== 7.2.10 Trunk based development

We use
link:https://trunkbaseddevelopment.com/[Trunk based develoment]
in order to keep only one long-term master branch.
Such branch is the source of truth regarding
what code is running in the production environments.

==== 7.2.11 Microchanges

Merge requests made by developers
can not be bigger than 200 deltas of code.
A consists of
either a removed or an added line of code.
Some advantages of working with microchanges are:

- Merge requests are small and easy to review
  by peer reviewers.
- Introducing critical bugs to production
  becomes harder as changes are smaller.
- In case something goes wrong with
  a deployment, identifying the error
  within those 200 deltas is
  easier.
- Developers go to production
  multiple times in a day and
  no code goes stale.
- Users of the application
  see it evolve in a daily basis.

==== 7.2.12 One branch per developer

Developers can only have one short-term branch
with their names (employeeatfluid) for every application.
Once they develop a portion of code (200 deltas maximum),
they run the Continuous Integration phase,
create a Merge Request and ask for peer review.
If everything goes well, their branch is
merged to the master branch,
their change is deployed to production
and the developer's short-term branch is deleted.

==== 7.2.13 No dependency auto-update

All external dependencies are pinned to a specific version
(this is highly related to the immutability property).
Meaning that in order to update a dependency,
a developer must:

. Change the version in the source code.
. Run all CI tests on the generated ephemeral environment
  with the new dependency version.
. Get the change approved from a colleague
  after running a peer review.
. In case all tests and peer review pass,
  a new production version with the updated
  dependency will be automatically deployed.

=== 7.3 Static website

Our [inner]#link:../[Website]# is a
link:https://en.wikipedia.org/wiki/Static_web_page[Static website],
meaning that it only serves plain HTML files.
As it does not have any complex functionality
that would require an application server,
it cannot be hacked.

=== 7.4 Everything is backed up

As data is most likely our most important asset,
we have strong backup policies for everything.
For example:

- Our redundant datacenters are fully versioned,
  meaning that any file can be recovered
  or returned to a previous version.
- [inner]#link:../products/integrates[Integrates]#'s
  database has weekly, trimestral
  and annual full backup schedules.
- [inner]#link:../products/integrates[Integrates]#'s
  database has point-in-time
  recovery with the capability of recovering
  the database to the state it was
  in a specific datetime (hours, minutes and seconds)
  during the last 35 days.
- All Forces exploits are versioned.

== 8. Availability

Availability refers to the capacity
of keeping all our systems up and running.
Avoiding service interruptions is crucial here.

=== 8.1 Distributed applications

[inner]#link:../products/integrates[Integrates]#
is hosted in an application cluster with
autoscaling policies and distributed
replicas. This ensures high availability,
as the there is always an instance ready to
recieve user requests in case another stops
working. Every cluster node has at least one
[inner]#link:../products/integrates[Integrates]#
instance running in it.
Aditionally,
its front side is served via a region-distributed
link:https://en.wikipedia.org/wiki/Content_delivery_network[CDN],
providing maximum speed and availability across the globe.

=== 8.2 Forever-lasting backups

As all our backups are stored in descentralized datacenters,
problems like hard drive lifespans
are not a concern to us.
Backups seamlessly exist
for as long as we want to,
Giving us full traceability
and recoverability.

== 9. Resilency

By resilency,
we refer to the organizational capability
of adapting to unexpected circumstances
that would affect the way our team
usually work.

=== 9.1 Redundant roles

Every role within the organization
has a minimum of two different employees
executing its tasks.
This allows us to be able to fill the gap
in case an employee goes on sick leave,
vacation, etc.

=== 9.2 Everything is descentralized

All our infrastructure is descentralized,
meaning that we have independent datacenters
spread across multiple regions.
No hardware maintainance is needed
as it is done by a third party.
No local networks are used.
We only use Wifi connections with
[inner]#link:../rules/253/[strong random generated passwords]#
with the sole purpose of accessing the Internet.
Connections are always encrypted
[inner]#link:../rules/252/[using WPA2-AES]#.

=== 9.3 Only laptops

A standard laptop is given to every employee.
Going to the office is the rule,
but employees can always fill out an exception form
to do telework in case they need to.
Employees are encouraged to take their laptops home,
as not keeping them in the same place
decreases the risk of massive thefts.
Also, in case our offices close
(link:https://en.wikipedia.org/wiki/Coronavirus_disease_2019[COVID-19]),
everyone can still do their job seamlessly.
All laptops have a password-secured BIOS,
link:https://docs.microsoft.com/en-us/windows/security/information-protection/tpm/trusted-platform-module-overview[TPM]
hardware and
[inner]#link:../rules/231/[biometric fingerprint reader]#.
By owning the laptops, siezing the computer should the
need arise becomes possible.
link:https://en.wikipedia.org/wiki/Bring_your_own_device[BYOD]
is not allowed.

== 10. Information security culture

This section provides details
regarding all the best practices
we follow in order to have a strong
information security culture.

=== 10.1 Certified hackers

We continuously encourage our hackers
to certify their knowledge.
Usually, hackers start applying for
certificates after spending 6 months
in the company.
[inner]#link:../services/certifications/[Here]#
you can find a comprenhensive list of certifications
our hackers team currently has.

=== 10.2 Extensive hiring process

All job applicans must go through
an extense [inner]#link:../careers[testing process]# in order to prove
their technical capabilities and human values.

The technical part of the testing process
consists of solving programming and hacking challenges,
upload them to a git repository with highly strict linters and compilers,
and ascend in a [inner]#link:../training/[organizational ranking]#.

The human values part of the testing process
includes creating a portfolio with the five most
important achievements of the candidate,
going to the office during a training
phase to work alongside the team,
job inverviews, among others.

=== 10.3 Secure policies for enrolled mobile devices

Our collaboration systems also provide security requirements
mobile devices must comply with
before being enrolled with the organization systems.
This is especially useful,
as personal mobile devices
are common targets for malicious hackers.

=== 10.4 Laptop rotation

We continuously renew the laptops of our employees.
There are two main reasons for this:

. *Hardware Improvement:*
  As usual, older laptops get
  replaced with new ones due to
  performance reasons.
. *Information flow:*
  As laptops continuously rotate
  among different employees,
  formatting happens often
  and information does not accumulate
  in a single hard drive.
