:slug: kb/java/usar-ejb-time-service/
:eth: no
:category: java
:description: TODO
:keywords: TODO
:kb: yes

= Usar EJB Timer Service

== Necesidad

Uso de EJB Timer Service en Java EE.

== Contexto

A continuación se describen las circunstancias 
bajo las cuales la siguiente solución tiene sentido:

. Se está desarrollando una aplicación JEE con soporte para EJB 2.1 o superior.

== Solución

En ciertas circunstancias, el manejo de hilos en una aplicación web 
está prohibido por el estándar Java EE 
puesto que siempre está altamente propenso a generar errores 
debido a que es probable que los hilos interfieran 
con el contenedor de aplicaciones y pueden dar origen a problemas 
que son difíciles de detectar y diagnosticar. 

Estos problemas pueden ser interbloqueos, condiciones de carrera 
y otros relacionados con la sincronización. 
Un antipatrón común es utilizar, en servlets, 
instancias de la clase java.lang.Thread invocando sobre ellas 
métodos como start o sleep entre otros. 

. Por tanto, se recomienda, en cambio, 
delegar la responsabilidad directamente al servidor de aplicaciones 
usado a través de APIs ofrecidas para ello [1] [2].

. En el siguiente ejemplo se ilustra como utilizar la interfaz TimerService [3] 
para indicar a un servidor de aplicaciones JEE 
que debe retrasar la ejecución de un llamado por 20 segundos.

. Para esto inicialmente se crea un EJB 
que posee el método startTimer 
que crea un temporizador del siguiente modo (src/fsg/TimeService.java):
+
.test.py
[source, java, linenums]
----
package fsg;

import java.util.logging.Logger;
import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import javax.ejb.Startup;
import javax.ejb.Timeout;
import javax.ejb.Timer;
import javax.ejb.Singleton;

@Singleton

@Startup

public class TimeService {
  static Logger log = Logger.getLogger("");
  
  @Resource  
  javax.ejb.TimerService timerService; 
  public void startTimer(){
    timerService.createTimer(20000, "FLUID Timer");
    log.info("FLUID Timer created at: " + new java.util.Date());
  }
----

. Note que no se instancia el servicio directamente, 
sino que la instancia será inyectada cuando se requiera.

. Pasados esos 20 segundos, se llamará el método delayedAction, 
dado que está marcado con la anotación @Timeout.
+
[source, java, linenums]
----
@Timeout
  public void delayedAction(Timer timer) {
    try {
      log.info("Executing timer: " + timer.getInfo());
      log.info("FLUID Timer action executed at: " + new java.util.Date());
    }
    catch (Exception e) {
      log.warning("Exception while getting timer information");
    }
  }
}
----

. Ahora se crea un servlet que atenderá la petición del usuario 
e inicializará el EJB (dependencia que también es inyectada 
y no requiere ser instanciada directamente) 
(src/fsg/TimeServlet.java):
+
[source, java, linenums]
----
package fsg;

import java.io.IOException;
import javax.ejb.EJB;
import javax.ejb.EJBs;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/Time")
public class TimeServlet extends HttpServlet {
  private static final long serialVersionUID = 1L;
 
  @EJB
  private TimeService timerEJB;
  public TimeServlet() {
    super();
  }
----

. Al recibir una petición GET, el servlet llamará el método startTimer del EJB:
+
[source, java, linenums]
----
  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws
     ServletException, IOException {
       response.setContentType("text/html;charset=UTF-8");
       java.io.PrintWriter out = response.getWriter();
       timerEJB.startTimer();
       out.println("Processing the request at: " + new java.util.Date());
       out.close();
    }
}
----

. Luego de desplegar la aplicación y acceder a /Time, 
tal como fue especificado en el servlet, 
puede observarse el tiempo exacto en el que se hace la petición:
+
image::peticion.png[tiempo exacto]

. Al consultar los logs de la aplicación 
puede comprobarse que en ese mismo instante 
se crea una entrada, y pasados 20 segundos 
aparecen dos nuevas entradas correspondientes a lo ejecutado en delayedAction:
+
[source, shell, linenums]
----
% tail -F /home/ryepes/workspace/glassfish3122eclipsedefaultdomain/logs/server.log
----

image::log.png[entradas creadas]

== Referencias

. http://cwe.mitre.org/data/definitions/383.html[CWE-383: J2EE Bad Practices: Direct Use of Threads]
. http://cwe.mitre.org/data/definitions/381.html[CWE CATEGORY: J2EE Time and State Issues]
. https://docs.oracle.com/javaee/6/api/javax/ejb/TimerService.html[javax.ejb Interface TimerService]
. REQ.0153: La codificación del sistema debe estar implementada en una versión 
de un lenguaje de programación estable, actualizada, probada y libre de 
vulnerabilidades conocidas.