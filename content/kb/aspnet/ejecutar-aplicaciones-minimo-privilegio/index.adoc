:slug: kb/aspnet/ejecutar-aplicaciones-minimo-privilegio
:eth: no
:category: aspnet
:kb: yes

= Ejecutar las Aplicaciones con Mínimo Privilegio

== Necesidad

Ejecutar las aplicaciones con el principio de mínimo privilegio

== Contexto

A continuación se describe las circunstancias bajo las cuales la siguiente solución tiene sentido:

. Se está desarrollando una aplicación en ASP.Net.

. Se desean aplicar los principios de mínimo privilegio.

== Solución

. Cuando se diseña, construye o despliega una aplicación, se debe asumir que la aplicación va a ser atacada. Con frecuencia, los ataques a las aplicaciones son lanzados utilizando código que se ejecuta con privilegios del usuario que ejecuta el código. Para controlar esta situación, se puede aplicar el principio de mínimo privilegio, es decir, los privilegios se deben otorgar la menor cantidad de tiempo a la menor cantidad de código que sea requerido para realizar las tareas.

. La mejor práctica para crear aplicaciones seguras es comenzar sin permisos y luego, añadir los mínimos privilegios que requiera una tarea para poder ejecutarse. El contraste, que es iniciar con todos los privilegios y luego negar los permisos que no se requieren puede llevar a aplicaciones inseguras que son difíciles de probar y mantener.

. En el espacio de nombres _System.security_ del ensamblado _mscorlib_ (en mscorlib.dll) existen diferentes llamadas para manipular los privilegios con los que cuenta una aplicación a nivel de código. Entre ellos, podemos destacar _PermitOnly_ y _Deny_. Con _Deny_ podemos restringir el acceso a algún privilegio para las llamadas que se realicen a posteriori del llamado. _PermitOnly_ es similar a _Deny_, en cuanto a que permite restringir a nivel de código los llamados que pueden realizarse. La diferencia está en que _Deny_ especifica los permisos que originan un error en el recorrido por la pila, mientras que _PermitOnly_ especifica únicamente los que no lo originan.

. Llame a este método para garantizar que el código puede utilizarse para obtener sólo acceso a los recursos especificados. La llamada a _PermitOnly_ es eficaz hasta que el código de llamada vuelve al llamador. Sólo puede haber un método _PermitOnly_ activo en cada marco. Un intento de llamar a _PermitOnly_ cuando hay otro método _PermitOnly_ activo en el marco da como resultado _SecurityException_. El método _PermitOnly_ de un permiso no concedido se pasará por alto, pues ninguna demanda para ese permiso podrá tener éxito. No obstante, si hay código situado en la parte inferior de la pila de llamadas que llame a Demand para ese permiso, se produce una excepción _SecurityException_ cuando el recorrido por la pila alcanza el código que intentó llamar a _PermitOnly_. Esto es debido a que el código que llamó a PermitOnly no dispone del permiso, aunque haya llamado a _PermitOnly_ para dicho permiso. La pila de llamadas suele representarse de forma decreciente, por lo que los métodos que se encuentran en las posiciones superiores de la pila de llamadas, llaman a métodos de las posiciones inferiores. Ejemplo de uso:

[source,java,linenums]
----
// Dar acceso al clipboard
Console.WriteLine("Dando acceso a clipboard.");
clipboardPermission.PermitOnly();
DemandAllClipboardAccess();
// Revertir el privilegio
Console.WriteLine("Revertir el permiso sobre el clipboard.");
CodeAccessPermission.RevertPermitOnly();
DemandAllClipboardAccess();
----

[start = 5]
. El método _PermitOnly_ solo debe usarse para proteger los recursos frente a un acceso accidental por parte del código de plena confianza. No debe usarse para proteger los recursos frente a un uso incorrecto intencionado por parte de código que no es de confianza. Por ejemplo, si el método A emite _PermitOnly_ para un permiso y, a continuación, llama al método B, el método B puede invalidar abiertamente _PermitOnly_ emitiendo _Assert_. El método al que se llama siempre está situado en la parte superior de la pila. Por lo tanto, si el método B intenta obtener acceso a un recurso protegido, el sistema de seguridad iniciará una comprobación de permisos con él puesto que el método B es el llamador inmediato y, a continuación, se desplazará hacia abajo en la pila para confirmar que no haya ningún _Deny_ o _PermitOnly_ situado por debajo en la pila. El método B, que está intentando obtener acceso al recurso, puede detener inmediatamente el recorrido de pila utilizando el método _Assert_. En ese caso, el _PermitOnly_ que el método A (el método de llamada) colocó en la pila no se detectará nunca.

== Referencias

. https://msdn.microsoft.com/es-es/library/system.security.codeaccesspermission.permitonly.aspx[Microsoft, CodeAccessPermission PermitOnly]

. REQ.0171: El sistema debe restringir el acceso a objetos del sistema que tengan contenido sensible. Solo permitirá acceso a usuarios autorizados.